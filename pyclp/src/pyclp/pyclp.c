/* Generated by Cython 0.29.34 */

#ifndef PY_SSIZE_T_CLEAN
#define PY_SSIZE_T_CLEAN
#endif /* PY_SSIZE_T_CLEAN */
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
    #error Cython requires Python 2.6+ or Python 3.3+.
#else
#define CYTHON_ABI "0_29_34"
#define CYTHON_HEX_VERSION 0x001D22F0
#define CYTHON_FUTURE_DIVISION 0
#include <stddef.h>
#ifndef offsetof
  #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#define __PYX_COMMA ,
#ifndef HAVE_LONG_LONG
  #if PY_VERSION_HEX >= 0x02070000
    #define HAVE_LONG_LONG
  #endif
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
  #define CYTHON_COMPILING_IN_PYPY 1
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #define CYTHON_COMPILING_IN_NOGIL 0
  #undef CYTHON_USE_TYPE_SLOTS
  #define CYTHON_USE_TYPE_SLOTS 0
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #if PY_VERSION_HEX < 0x03050000
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #undef CYTHON_USE_UNICODE_INTERNALS
  #define CYTHON_USE_UNICODE_INTERNALS 0
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #undef CYTHON_AVOID_BORROWED_REFS
  #define CYTHON_AVOID_BORROWED_REFS 1
  #undef CYTHON_ASSUME_SAFE_MACROS
  #define CYTHON_ASSUME_SAFE_MACROS 0
  #undef CYTHON_UNPACK_METHODS
  #define CYTHON_UNPACK_METHODS 0
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #undef CYTHON_PEP489_MULTI_PHASE_INIT
  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
  #undef CYTHON_USE_TP_FINALIZE
  #define CYTHON_USE_TP_FINALIZE 0
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
  #endif
#elif defined(PYSTON_VERSION)
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 1
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #define CYTHON_COMPILING_IN_NOGIL 0
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #undef CYTHON_USE_ASYNC_SLOTS
  #define CYTHON_USE_ASYNC_SLOTS 0
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #undef CYTHON_PEP489_MULTI_PHASE_INIT
  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
  #undef CYTHON_USE_TP_FINALIZE
  #define CYTHON_USE_TP_FINALIZE 0
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
  #endif
#elif defined(PY_NOGIL)
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #define CYTHON_COMPILING_IN_NOGIL 1
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #ifndef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
  #endif
  #ifndef CYTHON_USE_TP_FINALIZE
    #define CYTHON_USE_TP_FINALIZE 1
  #endif
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
#else
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 1
  #define CYTHON_COMPILING_IN_NOGIL 0
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYTYPE_LOOKUP
    #define CYTHON_USE_PYTYPE_LOOKUP 0
  #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
    #define CYTHON_USE_PYTYPE_LOOKUP 1
  #endif
  #if PY_MAJOR_VERSION < 3
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYLONG_INTERNALS
    #define CYTHON_USE_PYLONG_INTERNALS 0
  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
  #endif
  #ifndef CYTHON_USE_PYLIST_INTERNALS
    #define CYTHON_USE_PYLIST_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #if PY_VERSION_HEX < 0x030300F0 || PY_VERSION_HEX >= 0x030B00A2
    #undef CYTHON_USE_UNICODE_WRITER
    #define CYTHON_USE_UNICODE_WRITER 0
  #elif !defined(CYTHON_USE_UNICODE_WRITER)
    #define CYTHON_USE_UNICODE_WRITER 1
  #endif
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #if PY_VERSION_HEX >= 0x030B00A4
    #undef CYTHON_FAST_THREAD_STATE
    #define CYTHON_FAST_THREAD_STATE 0
  #elif !defined(CYTHON_FAST_THREAD_STATE)
    #define CYTHON_FAST_THREAD_STATE 1
  #endif
  #ifndef CYTHON_FAST_PYCALL
    #define CYTHON_FAST_PYCALL (PY_VERSION_HEX < 0x030A0000)
  #endif
  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
    #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
  #endif
  #ifndef CYTHON_USE_TP_FINALIZE
    #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
  #endif
  #ifndef CYTHON_USE_DICT_VERSIONS
    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
  #endif
  #if PY_VERSION_HEX >= 0x030B00A4
    #undef CYTHON_USE_EXC_INFO_STACK
    #define CYTHON_USE_EXC_INFO_STACK 0
  #elif !defined(CYTHON_USE_EXC_INFO_STACK)
    #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
  #endif
  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
  #endif
#endif
#if !defined(CYTHON_FAST_PYCCALL)
#define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
#endif
#if CYTHON_USE_PYLONG_INTERNALS
  #if PY_MAJOR_VERSION < 3
    #include "longintrepr.h"
  #endif
  #undef SHIFT
  #undef BASE
  #undef MASK
  #ifdef SIZEOF_VOID_P
    enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
  #endif
#endif
#ifndef __has_attribute
  #define __has_attribute(x) 0
#endif
#ifndef __has_cpp_attribute
  #define __has_cpp_attribute(x) 0
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
#ifndef CYTHON_MAYBE_UNUSED_VAR
#  if defined(__cplusplus)
     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
#  else
#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
#  endif
#endif
#ifndef CYTHON_NCP_UNUSED
# if CYTHON_COMPILING_IN_CPYTHON
#  define CYTHON_NCP_UNUSED
# else
#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
# endif
#endif
#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
#ifdef _MSC_VER
    #ifndef _MSC_STDINT_H_
        #if _MSC_VER < 1300
           typedef unsigned char     uint8_t;
           typedef unsigned int      uint32_t;
        #else
           typedef unsigned __int8   uint8_t;
           typedef unsigned __int32  uint32_t;
        #endif
    #endif
#else
   #include <stdint.h>
#endif
#ifndef CYTHON_FALLTHROUGH
  #if defined(__cplusplus) && __cplusplus >= 201103L
    #if __has_cpp_attribute(fallthrough)
      #define CYTHON_FALLTHROUGH [[fallthrough]]
    #elif __has_cpp_attribute(clang::fallthrough)
      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
    #elif __has_cpp_attribute(gnu::fallthrough)
      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
    #endif
  #endif
  #ifndef CYTHON_FALLTHROUGH
    #if __has_attribute(fallthrough)
      #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
    #else
      #define CYTHON_FALLTHROUGH
    #endif
  #endif
  #if defined(__clang__ ) && defined(__apple_build_version__)
    #if __apple_build_version__ < 7000000
      #undef  CYTHON_FALLTHROUGH
      #define CYTHON_FALLTHROUGH
    #endif
  #endif
#endif

#ifndef CYTHON_INLINE
  #if defined(__clang__)
    #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
  #elif defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif

#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
  #define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_DefaultClassType PyType_Type
#if PY_VERSION_HEX >= 0x030B00A1
    static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int k, int l, int s, int f,
                                                    PyObject *code, PyObject *c, PyObject* n, PyObject *v,
                                                    PyObject *fv, PyObject *cell, PyObject* fn,
                                                    PyObject *name, int fline, PyObject *lnos) {
        PyObject *kwds=NULL, *argcount=NULL, *posonlyargcount=NULL, *kwonlyargcount=NULL;
        PyObject *nlocals=NULL, *stacksize=NULL, *flags=NULL, *replace=NULL, *call_result=NULL, *empty=NULL;
        const char *fn_cstr=NULL;
        const char *name_cstr=NULL;
        PyCodeObject* co=NULL;
        PyObject *type, *value, *traceback;
        PyErr_Fetch(&type, &value, &traceback);
        if (!(kwds=PyDict_New())) goto end;
        if (!(argcount=PyLong_FromLong(a))) goto end;
        if (PyDict_SetItemString(kwds, "co_argcount", argcount) != 0) goto end;
        if (!(posonlyargcount=PyLong_FromLong(0))) goto end;
        if (PyDict_SetItemString(kwds, "co_posonlyargcount", posonlyargcount) != 0) goto end;
        if (!(kwonlyargcount=PyLong_FromLong(k))) goto end;
        if (PyDict_SetItemString(kwds, "co_kwonlyargcount", kwonlyargcount) != 0) goto end;
        if (!(nlocals=PyLong_FromLong(l))) goto end;
        if (PyDict_SetItemString(kwds, "co_nlocals", nlocals) != 0) goto end;
        if (!(stacksize=PyLong_FromLong(s))) goto end;
        if (PyDict_SetItemString(kwds, "co_stacksize", stacksize) != 0) goto end;
        if (!(flags=PyLong_FromLong(f))) goto end;
        if (PyDict_SetItemString(kwds, "co_flags", flags) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_code", code) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_consts", c) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_names", n) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_varnames", v) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_freevars", fv) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_cellvars", cell) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_linetable", lnos) != 0) goto end;
        if (!(fn_cstr=PyUnicode_AsUTF8AndSize(fn, NULL))) goto end;
        if (!(name_cstr=PyUnicode_AsUTF8AndSize(name, NULL))) goto end;
        if (!(co = PyCode_NewEmpty(fn_cstr, name_cstr, fline))) goto end;
        if (!(replace = PyObject_GetAttrString((PyObject*)co, "replace"))) goto cleanup_code_too;
        if (!(empty = PyTuple_New(0))) goto cleanup_code_too; // unfortunately __pyx_empty_tuple isn't available here
        if (!(call_result = PyObject_Call(replace, empty, kwds))) goto cleanup_code_too;
        Py_XDECREF((PyObject*)co);
        co = (PyCodeObject*)call_result;
        call_result = NULL;
        if (0) {
            cleanup_code_too:
            Py_XDECREF((PyObject*)co);
            co = NULL;
        }
        end:
        Py_XDECREF(kwds);
        Py_XDECREF(argcount);
        Py_XDECREF(posonlyargcount);
        Py_XDECREF(kwonlyargcount);
        Py_XDECREF(nlocals);
        Py_XDECREF(stacksize);
        Py_XDECREF(replace);
        Py_XDECREF(call_result);
        Py_XDECREF(empty);
        if (type) {
            PyErr_Restore(type, value, traceback);
        }
        return co;
    }
#else
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
#endif
  #define __Pyx_DefaultClassType PyType_Type
#endif
#ifndef Py_TPFLAGS_CHECKTYPES
  #define Py_TPFLAGS_CHECKTYPES 0
#endif
#ifndef Py_TPFLAGS_HAVE_INDEX
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#ifndef Py_TPFLAGS_HAVE_NEWBUFFER
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#ifndef Py_TPFLAGS_HAVE_FINALIZE
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#ifndef METH_STACKLESS
  #define METH_STACKLESS 0
#endif
#if PY_VERSION_HEX <= 0x030700A3 || !defined(METH_FASTCALL)
  #ifndef METH_FASTCALL
     #define METH_FASTCALL 0x80
  #endif
  typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
  typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                          Py_ssize_t nargs, PyObject *kwnames);
#else
  #define __Pyx_PyCFunctionFast _PyCFunctionFast
  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
#endif
#if CYTHON_FAST_PYCCALL
#define __Pyx_PyFastCFunction_Check(func)\
    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)))))
#else
#define __Pyx_PyFastCFunction_Check(func) 0
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
  #define PyObject_Malloc(s)   PyMem_Malloc(s)
  #define PyObject_Free(p)     PyMem_Free(p)
  #define PyObject_Realloc(p)  PyMem_Realloc(p)
#endif
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030400A1
  #define PyMem_RawMalloc(n)           PyMem_Malloc(n)
  #define PyMem_RawRealloc(p, n)       PyMem_Realloc(p, n)
  #define PyMem_RawFree(p)             PyMem_Free(p)
#endif
#if CYTHON_COMPILING_IN_PYSTON
  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
#else
  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
#endif
#if !CYTHON_FAST_THREAD_STATE || PY_VERSION_HEX < 0x02070000
  #define __Pyx_PyThreadState_Current PyThreadState_GET()
#elif PY_VERSION_HEX >= 0x03060000
  #define __Pyx_PyThreadState_Current _PyThreadState_UncheckedGet()
#elif PY_VERSION_HEX >= 0x03000000
  #define __Pyx_PyThreadState_Current PyThreadState_GET()
#else
  #define __Pyx_PyThreadState_Current _PyThreadState_Current
#endif
#if PY_VERSION_HEX < 0x030700A2 && !defined(PyThread_tss_create) && !defined(Py_tss_NEEDS_INIT)
#include "pythread.h"
#define Py_tss_NEEDS_INIT 0
typedef int Py_tss_t;
static CYTHON_INLINE int PyThread_tss_create(Py_tss_t *key) {
  *key = PyThread_create_key();
  return 0;
}
static CYTHON_INLINE Py_tss_t * PyThread_tss_alloc(void) {
  Py_tss_t *key = (Py_tss_t *)PyObject_Malloc(sizeof(Py_tss_t));
  *key = Py_tss_NEEDS_INIT;
  return key;
}
static CYTHON_INLINE void PyThread_tss_free(Py_tss_t *key) {
  PyObject_Free(key);
}
static CYTHON_INLINE int PyThread_tss_is_created(Py_tss_t *key) {
  return *key != Py_tss_NEEDS_INIT;
}
static CYTHON_INLINE void PyThread_tss_delete(Py_tss_t *key) {
  PyThread_delete_key(*key);
  *key = Py_tss_NEEDS_INIT;
}
static CYTHON_INLINE int PyThread_tss_set(Py_tss_t *key, void *value) {
  return PyThread_set_key_value(*key, value);
}
static CYTHON_INLINE void * PyThread_tss_get(Py_tss_t *key) {
  return PyThread_get_key_value(*key);
}
#endif
#if CYTHON_COMPILING_IN_CPYTHON || defined(_PyDict_NewPresized)
#define __Pyx_PyDict_NewPresized(n)  ((n <= 8) ? PyDict_New() : _PyDict_NewPresized(n))
#else
#define __Pyx_PyDict_NewPresized(n)  PyDict_New()
#endif
#if PY_MAJOR_VERSION >= 3 || CYTHON_FUTURE_DIVISION
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
#define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
#else
#define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #if PY_VERSION_HEX >= 0x030C0000
    #define __Pyx_PyUnicode_READY(op)       (0)
  #else
    #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
                                                0 : _PyUnicode_Ready((PyObject *)(op)))
  #endif
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
  #if PY_VERSION_HEX >= 0x030C0000
    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
  #else
    #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
    #else
    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
    #endif
  #endif
#else
  #define CYTHON_PEP393_ENABLED 0
  #define PyUnicode_1BYTE_KIND  1
  #define PyUnicode_2BYTE_KIND  2
  #define PyUnicode_4BYTE_KIND  4
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None || (PyString_Check(b) && !PyString_CheckExact(b)))) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None || (PyUnicode_Check(b) && !PyUnicode_CheckExact(b)))) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION < 3 && !defined(PyObject_ASCII)
  #define PyObject_ASCII(o)            PyObject_Repr(o)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#ifndef PyObject_Unicode
  #define PyObject_Unicode             PyObject_Str
#endif
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#if PY_VERSION_HEX >= 0x030900A4
  #define __Pyx_SET_REFCNT(obj, refcnt) Py_SET_REFCNT(obj, refcnt)
  #define __Pyx_SET_SIZE(obj, size) Py_SET_SIZE(obj, size)
#else
  #define __Pyx_SET_REFCNT(obj, refcnt) Py_REFCNT(obj) = (refcnt)
  #define __Pyx_SET_SIZE(obj, size) Py_SIZE(obj) = (size)
#endif
#if CYTHON_ASSUME_SAFE_MACROS
  #define __Pyx_PySequence_SIZE(seq)  Py_SIZE(seq)
#else
  #define __Pyx_PySequence_SIZE(seq)  PySequence_Size(seq)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
  #ifndef PyUnicode_InternFromString
    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
  #endif
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsHash_t
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? ((void)(klass), PyMethod_New(func, self)) : __Pyx_NewRef(func))
#else
  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
#endif
#if CYTHON_USE_ASYNC_SLOTS
  #if PY_VERSION_HEX >= 0x030500B1
    #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
    #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
  #else
    #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
  #endif
#else
  #define __Pyx_PyType_AsAsync(obj) NULL
#endif
#ifndef __Pyx_PyAsyncMethodsStruct
    typedef struct {
        unaryfunc am_await;
        unaryfunc am_aiter;
        unaryfunc am_anext;
    } __Pyx_PyAsyncMethodsStruct;
#endif

#if defined(_WIN32) || defined(WIN32) || defined(MS_WINDOWS)
  #if !defined(_USE_MATH_DEFINES)
    #define _USE_MATH_DEFINES
  #endif
#endif
#include <math.h>
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif
#if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
#define __Pyx_truncl trunc
#else
#define __Pyx_truncl truncl
#endif

#define __PYX_MARK_ERR_POS(f_index, lineno) \
    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
#define __PYX_ERR(f_index, lineno, Ln_error) \
    { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#define __PYX_HAVE__pyclp__pyclp
#define __PYX_HAVE_API__pyclp__pyclp
/* Early includes */
#include "eclipse.h"
#include "error.h"
#include <string.h>
#include <stdio.h>
#include "pythread.h"
#include <stdlib.h>
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
#define CYTHON_WITHOUT_ASSERTIONS
#endif

typedef struct {PyObject **p; const char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_UTF8 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT (PY_MAJOR_VERSION >= 3 && __PYX_DEFAULT_STRING_ENCODING_IS_UTF8)
#define __PYX_DEFAULT_STRING_ENCODING ""
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#define __Pyx_uchar_cast(c) ((unsigned char)c)
#define __Pyx_long_cast(x) ((long)x)
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (\
    (sizeof(type) < sizeof(Py_ssize_t))  ||\
    (sizeof(type) > sizeof(Py_ssize_t) &&\
          likely(v < (type)PY_SSIZE_T_MAX ||\
                 v == (type)PY_SSIZE_T_MAX)  &&\
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
                                v == (type)PY_SSIZE_T_MIN)))  ||\
    (sizeof(type) == sizeof(Py_ssize_t) &&\
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
                               v == (type)PY_SSIZE_T_MAX)))  )
static CYTHON_INLINE int __Pyx_is_valid_index(Py_ssize_t i, Py_ssize_t limit) {
    return (size_t) i < (size_t) limit;
}
#if defined (__cplusplus) && __cplusplus >= 201103L
    #include <cstdlib>
    #define __Pyx_sst_abs(value) std::abs(value)
#elif SIZEOF_INT >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) abs(value)
#elif SIZEOF_LONG >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) labs(value)
#elif defined (_MSC_VER)
    #define __Pyx_sst_abs(value) ((Py_ssize_t)_abs64(value))
#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define __Pyx_sst_abs(value) llabs(value)
#elif defined (__GNUC__)
    #define __Pyx_sst_abs(value) __builtin_llabs(value)
#else
    #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyBytes_AsWritableString(s)     ((char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsWritableSString(s)    ((signed char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsWritableUString(s)    ((unsigned char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsString(s)     ((const char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsSString(s)    ((const signed char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsUString(s)    ((const unsigned char*) PyBytes_AS_STRING(s))
#define __Pyx_PyObject_AsWritableString(s)    ((char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u) {
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
#define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
#define __Pyx_PySequence_Tuple(obj)\
    (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject*);
#if CYTHON_ASSUME_SAFE_MACROS
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
#else
#define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
#endif
#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c) + 1);
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */
static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }

static PyObject *__pyx_m = NULL;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_cython_runtime = NULL;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static PyObject *__pyx_empty_unicode;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "src\\pyclp\\pyclp.pyx",
  "stringsource",
  ".venv\\lib\\site-packages\\Cython\\Includes\\cpython\\type.pxd",
  ".venv\\lib\\site-packages\\Cython\\Includes\\cpython\\bool.pxd",
  ".venv\\lib\\site-packages\\Cython\\Includes\\cpython\\complex.pxd",
};
/* ForceInitThreads.proto */
#ifndef __PYX_FORCE_INIT_THREADS
  #define __PYX_FORCE_INIT_THREADS 0
#endif

/* NoFastGil.proto */
#define __Pyx_PyGILState_Ensure PyGILState_Ensure
#define __Pyx_PyGILState_Release PyGILState_Release
#define __Pyx_FastGIL_Remember()
#define __Pyx_FastGIL_Forget()
#define __Pyx_FastGilFuncInit()


/*--- Type declarations ---*/
struct __pyx_obj_5pyclp_5pyclp_Ref;
struct __pyx_obj_5pyclp_5pyclp_Term;
struct __pyx_obj_5pyclp_5pyclp_Atom;
struct __pyx_obj_5pyclp_5pyclp_PList;
struct __pyx_obj_5pyclp_5pyclp_Compound;
struct __pyx_obj_5pyclp_5pyclp_Var;
struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator;
struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator;
struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments;

/* "pyclp/pyclp.pyx":182
 * 
 * 
 * cdef class Ref:             # <<<<<<<<<<<<<<
 *     cdef pyclp.ec_ref ref
 *     cdef object __weakref__
 */
struct __pyx_obj_5pyclp_5pyclp_Ref {
  PyObject_HEAD
  struct __pyx_vtabstruct_5pyclp_5pyclp_Ref *__pyx_vtab;
  ec_ref ref;
  PyObject *__weakref__;
};


/* "pyclp/pyclp.pyx":506
 *         raise pyclpEx("Unsupported option")
 * 
 * cdef class Term:             # <<<<<<<<<<<<<<
 *     """Class for prolog Term.
 *     Compound, Atom,PList and Var are derived from this class.
 */
struct __pyx_obj_5pyclp_5pyclp_Term {
  PyObject_HEAD
  struct __pyx_vtabstruct_5pyclp_5pyclp_Term *__pyx_vtab;
  struct __pyx_obj_5pyclp_5pyclp_Ref *ref;
  pword cached_pword;
};


/* "pyclp/pyclp.pyx":638
 * 
 * 
 * cdef class Atom(Term):             # <<<<<<<<<<<<<<
 *     """
 *     Class to create Atom.
 */
struct __pyx_obj_5pyclp_5pyclp_Atom {
  struct __pyx_obj_5pyclp_5pyclp_Term __pyx_base;
  dident ec_dict_ptr;
};


/* "pyclp/pyclp.pyx":679
 *         return string
 * 
 * cdef class PList(Term):             # <<<<<<<<<<<<<<
 *     """
 *     Class to create and read Prolog lists.
 */
struct __pyx_obj_5pyclp_5pyclp_PList {
  struct __pyx_obj_5pyclp_5pyclp_Term __pyx_base;
};


/* "pyclp/pyclp.pyx":898
 * 
 * 
 * cdef class Compound(Term):             # <<<<<<<<<<<<<<
 *     """
 *     Class to create compound terms.
 */
struct __pyx_obj_5pyclp_5pyclp_Compound {
  struct __pyx_obj_5pyclp_5pyclp_Term __pyx_base;
  dident ec_dict_ptr;
};


/* "pyclp/pyclp.pyx":1031
 * 
 * 
 * cdef class Var(Term):             # <<<<<<<<<<<<<<
 *     """
 *     Class to create Prolog variable.
 */
struct __pyx_obj_5pyclp_5pyclp_Var {
  struct __pyx_obj_5pyclp_5pyclp_Term __pyx_base;
};


/* "pyclp/pyclp.pyx":771
 *             self.ref.set(tail_pword)
 * 
 *     def head_generator(self):             # <<<<<<<<<<<<<<
 *         cdef pyclp.pword tail
 *         cdef pyclp.pword head
 */
struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator {
  PyObject_HEAD
  pword __pyx_v_head;
  int __pyx_v_res;
  struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self;
  pword __pyx_v_tail;
};


/* "pyclp/pyclp.pyx":781
 *             else:
 *                 return
 *     def head_tail_generator(self):             # <<<<<<<<<<<<<<
 *         cdef pyclp.pword tail
 *         cdef pyclp.pword head
 */
struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator {
  PyObject_HEAD
  pword __pyx_v_head;
  struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self;
  pword __pyx_v_tail;
};


/* "pyclp/pyclp.pyx":970
 *         """
 *         return self.get_functor_string()
 *     def arguments(self):             # <<<<<<<<<<<<<<
 *         """
 *         Return an iterator over compound term arguments
 */
struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments {
  PyObject_HEAD
  pword __pyx_v_arg_pword;
  int __pyx_v_index;
  int __pyx_v_result;
  struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self;
  int __pyx_t_0;
  int __pyx_t_1;
  int __pyx_t_2;
};



/* "pyclp/pyclp.pyx":182
 * 
 * 
 * cdef class Ref:             # <<<<<<<<<<<<<<
 *     cdef pyclp.ec_ref ref
 *     cdef object __weakref__
 */

struct __pyx_vtabstruct_5pyclp_5pyclp_Ref {
  pword (*get)(struct __pyx_obj_5pyclp_5pyclp_Ref *);
  void (*set)(struct __pyx_obj_5pyclp_5pyclp_Ref *, pword);
};
static struct __pyx_vtabstruct_5pyclp_5pyclp_Ref *__pyx_vtabptr_5pyclp_5pyclp_Ref;


/* "pyclp/pyclp.pyx":506
 *         raise pyclpEx("Unsupported option")
 * 
 * cdef class Term:             # <<<<<<<<<<<<<<
 *     """Class for prolog Term.
 *     Compound, Atom,PList and Var are derived from this class.
 */

struct __pyx_vtabstruct_5pyclp_5pyclp_Term {
  pword (*get_pword)(struct __pyx_obj_5pyclp_5pyclp_Term *);
  int (*set_pword)(struct __pyx_obj_5pyclp_5pyclp_Term *, pword);
  int (*compare_pword)(struct __pyx_obj_5pyclp_5pyclp_Term *, PyObject *);
};
static struct __pyx_vtabstruct_5pyclp_5pyclp_Term *__pyx_vtabptr_5pyclp_5pyclp_Term;


/* "pyclp/pyclp.pyx":638
 * 
 * 
 * cdef class Atom(Term):             # <<<<<<<<<<<<<<
 *     """
 *     Class to create Atom.
 */

struct __pyx_vtabstruct_5pyclp_5pyclp_Atom {
  struct __pyx_vtabstruct_5pyclp_5pyclp_Term __pyx_base;
};
static struct __pyx_vtabstruct_5pyclp_5pyclp_Atom *__pyx_vtabptr_5pyclp_5pyclp_Atom;


/* "pyclp/pyclp.pyx":679
 *         return string
 * 
 * cdef class PList(Term):             # <<<<<<<<<<<<<<
 *     """
 *     Class to create and read Prolog lists.
 */

struct __pyx_vtabstruct_5pyclp_5pyclp_PList {
  struct __pyx_vtabstruct_5pyclp_5pyclp_Term __pyx_base;
  int (*get_head_tail)(struct __pyx_obj_5pyclp_5pyclp_PList *, pword *, pword *);
  int (*isNil)(struct __pyx_obj_5pyclp_5pyclp_PList *, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_5pyclp_5pyclp_PList *__pyx_vtabptr_5pyclp_5pyclp_PList;


/* "pyclp/pyclp.pyx":898
 * 
 * 
 * cdef class Compound(Term):             # <<<<<<<<<<<<<<
 *     """
 *     Class to create compound terms.
 */

struct __pyx_vtabstruct_5pyclp_5pyclp_Compound {
  struct __pyx_vtabstruct_5pyclp_5pyclp_Term __pyx_base;
  int (*arity)(struct __pyx_obj_5pyclp_5pyclp_Compound *, int __pyx_skip_dispatch);
  PyObject *(*get_functor_string)(struct __pyx_obj_5pyclp_5pyclp_Compound *);
};
static struct __pyx_vtabstruct_5pyclp_5pyclp_Compound *__pyx_vtabptr_5pyclp_5pyclp_Compound;


/* "pyclp/pyclp.pyx":1031
 * 
 * 
 * cdef class Var(Term):             # <<<<<<<<<<<<<<
 *     """
 *     Class to create Prolog variable.
 */

struct __pyx_vtabstruct_5pyclp_5pyclp_Var {
  struct __pyx_vtabstruct_5pyclp_5pyclp_Term __pyx_base;
  PyObject *(*value)(struct __pyx_obj_5pyclp_5pyclp_Var *, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_5pyclp_5pyclp_Var *__pyx_vtabptr_5pyclp_5pyclp_Var;

/* --- Runtime support code (head) --- */
/* Refnanny.proto */
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          if (acquire_gil) {\
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
              PyGILState_Release(__pyx_gilstate_save);\
          } else {\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext()\
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_XDECREF(tmp);\
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_DECREF(tmp);\
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

/* PyObjectGetAttrStr.proto */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

/* GetBuiltinName.proto */
static PyObject *__Pyx_GetBuiltinName(PyObject *name);

/* RaiseArgTupleInvalid.proto */
static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);

/* RaiseDoubleKeywords.proto */
static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);

/* ParseKeywords.proto */
static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
    const char* function_name);

/* PyObjectSetAttrStr.proto */
#if CYTHON_USE_TYPE_SLOTS
#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o, n, NULL)
static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value);
#else
#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
#endif

/* IncludeStringH.proto */
#include <string.h>

/* decode_c_string_utf16.proto */
static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16(const char *s, Py_ssize_t size, const char *errors) {
    int byteorder = 0;
    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
}
static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16LE(const char *s, Py_ssize_t size, const char *errors) {
    int byteorder = -1;
    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
}
static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16BE(const char *s, Py_ssize_t size, const char *errors) {
    int byteorder = 1;
    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
}

/* decode_c_string.proto */
static CYTHON_INLINE PyObject* __Pyx_decode_c_string(
         const char* cstring, Py_ssize_t start, Py_ssize_t stop,
         const char* encoding, const char* errors,
         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors));

/* PyCFunctionFastCall.proto */
#if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
#else
#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
#endif

/* PyFunctionFastCall.proto */
#if CYTHON_FAST_PYCALL
#define __Pyx_PyFunction_FastCall(func, args, nargs)\
    __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs);
#else
#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
#endif
#define __Pyx_BUILD_ASSERT_EXPR(cond)\
    (sizeof(char [1 - 2*!(cond)]) - 1)
#ifndef Py_MEMBER_SIZE
#define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
#endif
#if CYTHON_FAST_PYCALL
  static size_t __pyx_pyframe_localsplus_offset = 0;
  #include "frameobject.h"
#if PY_VERSION_HEX >= 0x030b00a6
  #ifndef Py_BUILD_CORE
    #define Py_BUILD_CORE 1
  #endif
  #include "internal/pycore_frame.h"
#endif
  #define __Pxy_PyFrame_Initialize_Offsets()\
    ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
     (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
  #define __Pyx_PyFrame_GetLocalsplus(frame)\
    (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
#endif // CYTHON_FAST_PYCALL
#endif

/* PyObjectCall.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

/* PyObjectCall2Args.proto */
static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);

/* PyObjectCallMethO.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
#endif

/* PyObjectCallOneArg.proto */
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);

/* PyThreadStateGet.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
#define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
#else
#define __Pyx_PyThreadState_declare
#define __Pyx_PyThreadState_assign
#define __Pyx_PyErr_Occurred()  PyErr_Occurred()
#endif

/* PyErrFetchRestore.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
#else
#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
#endif
#else
#define __Pyx_PyErr_Clear() PyErr_Clear()
#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
#endif

/* RaiseException.proto */
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);

/* PyObjectCallNoArg.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
#else
#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
#endif

/* PyDictVersioning.proto */
#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
#define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
#define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
    (version_var) = __PYX_GET_DICT_VERSION(dict);\
    (cache_var) = (value);
#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP) {\
    static PY_UINT64_T __pyx_dict_version = 0;\
    static PyObject *__pyx_dict_cached_value = NULL;\
    if (likely(__PYX_GET_DICT_VERSION(DICT) == __pyx_dict_version)) {\
        (VAR) = __pyx_dict_cached_value;\
    } else {\
        (VAR) = __pyx_dict_cached_value = (LOOKUP);\
        __pyx_dict_version = __PYX_GET_DICT_VERSION(DICT);\
    }\
}
static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj);
static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj);
static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version);
#else
#define __PYX_GET_DICT_VERSION(dict)  (0)
#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
#endif

/* GetModuleGlobalName.proto */
#if CYTHON_USE_DICT_VERSIONS
#define __Pyx_GetModuleGlobalName(var, name)  do {\
    static PY_UINT64_T __pyx_dict_version = 0;\
    static PyObject *__pyx_dict_cached_value = NULL;\
    (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
        (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
        __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
} while(0)
#define __Pyx_GetModuleGlobalNameUncached(var, name)  do {\
    PY_UINT64_T __pyx_dict_version;\
    PyObject *__pyx_dict_cached_value;\
    (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
} while(0)
static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
#else
#define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
#define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
#endif

/* GetItemInt.proto */
#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                     int is_list, int wraparound, int boundscheck);

/* ObjectGetItem.proto */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key);
#else
#define __Pyx_PyObject_GetItem(obj, key)  PyObject_GetItem(obj, key)
#endif

/* GetTopmostException.proto */
#if CYTHON_USE_EXC_INFO_STACK
static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
#endif

/* SaveResetException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
#else
#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
#endif

/* PyErrExceptionMatches.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
#else
#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
#endif

/* GetException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
#endif

/* WriteUnraisableException.proto */
static void __Pyx_WriteUnraisable(const char *name, int clineno,
                                  int lineno, const char *filename,
                                  int full_traceback, int nogil);

/* StringJoin.proto */
#if PY_MAJOR_VERSION < 3
#define __Pyx_PyString_Join __Pyx_PyBytes_Join
#define __Pyx_PyBaseString_Join(s, v) (PyUnicode_CheckExact(s) ? PyUnicode_Join(s, v) : __Pyx_PyBytes_Join(s, v))
#else
#define __Pyx_PyString_Join PyUnicode_Join
#define __Pyx_PyBaseString_Join PyUnicode_Join
#endif
#if CYTHON_COMPILING_IN_CPYTHON
    #if PY_MAJOR_VERSION < 3
    #define __Pyx_PyBytes_Join _PyString_Join
    #else
    #define __Pyx_PyBytes_Join _PyBytes_Join
    #endif
#else
static CYTHON_INLINE PyObject* __Pyx_PyBytes_Join(PyObject* sep, PyObject* values);
#endif

/* KeywordStringCheck.proto */
static int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed);

/* ExtTypeTest.proto */
static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);

/* PyIntCompare.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_EqObjC(PyObject *op1, PyObject *op2, long intval, long inplace);

/* ModInt[int].proto */
static CYTHON_INLINE int __Pyx_mod_int(int, int);

/* ModInt[long].proto */
static CYTHON_INLINE long __Pyx_mod_long(long, long);

/* SwapException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_ExceptionSwap(type, value, tb)  __Pyx__ExceptionSwap(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);
#endif

/* None.proto */
static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);

/* RaiseTooManyValuesToUnpack.proto */
static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);

/* RaiseNeedMoreValuesToUnpack.proto */
static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);

/* IterFinish.proto */
static CYTHON_INLINE int __Pyx_IterFinish(void);

/* UnpackItemEndCheck.proto */
static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);

/* ListAppend.proto */
#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        __Pyx_SET_SIZE(list, len + 1);
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
#endif

/* SetItemInt.proto */
#define __Pyx_SetItemInt(o, i, v, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_SetItemInt_Fast(o, (Py_ssize_t)i, v, is_list, wraparound, boundscheck) :\
    (is_list ? (PyErr_SetString(PyExc_IndexError, "list assignment index out of range"), -1) :\
               __Pyx_SetItemInt_Generic(o, to_py_func(i), v)))
static int __Pyx_SetItemInt_Generic(PyObject *o, PyObject *j, PyObject *v);
static CYTHON_INLINE int __Pyx_SetItemInt_Fast(PyObject *o, Py_ssize_t i, PyObject *v,
                                               int is_list, int wraparound, int boundscheck);

/* PyObject_GenericGetAttrNoDict.proto */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
#else
#define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
#endif

/* PyObject_GenericGetAttr.proto */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name);
#else
#define __Pyx_PyObject_GenericGetAttr PyObject_GenericGetAttr
#endif

/* SetVTable.proto */
static int __Pyx_SetVtable(PyObject *dict, void *vtable);

/* PyObjectGetAttrStrNoError.proto */
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);

/* SetupReduce.proto */
static int __Pyx_setup_reduce(PyObject* type_obj);

/* TypeImport.proto */
#ifndef __PYX_HAVE_RT_ImportType_proto
#define __PYX_HAVE_RT_ImportType_proto
#if __STDC_VERSION__ >= 201112L
#include <stdalign.h>
#endif
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#define __PYX_GET_STRUCT_ALIGNMENT(s) alignof(s)
#else
#define __PYX_GET_STRUCT_ALIGNMENT(s) sizeof(void*)
#endif
enum __Pyx_ImportType_CheckSize {
   __Pyx_ImportType_CheckSize_Error = 0,
   __Pyx_ImportType_CheckSize_Warn = 1,
   __Pyx_ImportType_CheckSize_Ignore = 2
};
static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize check_size);
#endif

/* Import.proto */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);

/* CalculateMetaclass.proto */
static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases);

/* FetchCommonType.proto */
static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);

/* CythonFunctionShared.proto */
#define __Pyx_CyFunction_USED 1
#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
#define __Pyx_CYFUNCTION_CCLASS        0x04
#define __Pyx_CyFunction_GetClosure(f)\
    (((__pyx_CyFunctionObject *) (f))->func_closure)
#define __Pyx_CyFunction_GetClassObj(f)\
    (((__pyx_CyFunctionObject *) (f))->func_classobj)
#define __Pyx_CyFunction_Defaults(type, f)\
    ((type *)(((__pyx_CyFunctionObject *) (f))->defaults))
#define __Pyx_CyFunction_SetDefaultsGetter(f, g)\
    ((__pyx_CyFunctionObject *) (f))->defaults_getter = (g)
typedef struct {
    PyCFunctionObject func;
#if PY_VERSION_HEX < 0x030500A0
    PyObject *func_weakreflist;
#endif
    PyObject *func_dict;
    PyObject *func_name;
    PyObject *func_qualname;
    PyObject *func_doc;
    PyObject *func_globals;
    PyObject *func_code;
    PyObject *func_closure;
    PyObject *func_classobj;
    void *defaults;
    int defaults_pyobjects;
    size_t defaults_size;  // used by FusedFunction for copying defaults
    int flags;
    PyObject *defaults_tuple;
    PyObject *defaults_kwdict;
    PyObject *(*defaults_getter)(PyObject *);
    PyObject *func_annotations;
} __pyx_CyFunctionObject;
static PyTypeObject *__pyx_CyFunctionType = 0;
#define __Pyx_CyFunction_Check(obj)  (__Pyx_TypeCheck(obj, __pyx_CyFunctionType))
static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject* op, PyMethodDef *ml,
                                      int flags, PyObject* qualname,
                                      PyObject *self,
                                      PyObject *module, PyObject *globals,
                                      PyObject* code);
static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *m,
                                                         size_t size,
                                                         int pyobjects);
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *m,
                                                            PyObject *tuple);
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *m,
                                                             PyObject *dict);
static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *m,
                                                              PyObject *dict);
static int __pyx_CyFunction_init(void);

/* CythonFunction.proto */
static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml,
                                      int flags, PyObject* qualname,
                                      PyObject *closure,
                                      PyObject *module, PyObject *globals,
                                      PyObject* code);

/* SetNameInClass.proto */
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
#define __Pyx_SetNameInClass(ns, name, value)\
    (likely(PyDict_CheckExact(ns)) ? _PyDict_SetItem_KnownHash(ns, name, value, ((PyASCIIObject *) name)->hash) : PyObject_SetItem(ns, name, value))
#elif CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_SetNameInClass(ns, name, value)\
    (likely(PyDict_CheckExact(ns)) ? PyDict_SetItem(ns, name, value) : PyObject_SetItem(ns, name, value))
#else
#define __Pyx_SetNameInClass(ns, name, value)  PyObject_SetItem(ns, name, value)
#endif

/* Py3ClassCreate.proto */
static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name, PyObject *qualname,
                                           PyObject *mkw, PyObject *modname, PyObject *doc);
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases, PyObject *dict,
                                      PyObject *mkw, int calculate_metaclass, int allow_py2_metaclass);

/* CLineInTraceback.proto */
#ifdef CYTHON_CLINE_IN_TRACEBACK
#define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
#else
static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
#endif

/* CodeObjectCache.proto */
typedef struct {
    PyCodeObject* code_object;
    int code_line;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

/* AddTraceback.proto */
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

/* GCCDiagnostics.proto */
#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
#define __Pyx_HAS_GCC_DIAGNOSTIC
#endif

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);

/* CIntFromPy.proto */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

/* FastTypeChecks.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
#else
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
#define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
#endif
#define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)

/* PyObjectGetMethod.proto */
static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method);

/* PyObjectCallMethod1.proto */
static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg);

/* CoroutineBase.proto */
typedef PyObject *(*__pyx_coroutine_body_t)(PyObject *, PyThreadState *, PyObject *);
#if CYTHON_USE_EXC_INFO_STACK
#define __Pyx_ExcInfoStruct  _PyErr_StackItem
#else
typedef struct {
    PyObject *exc_type;
    PyObject *exc_value;
    PyObject *exc_traceback;
} __Pyx_ExcInfoStruct;
#endif
typedef struct {
    PyObject_HEAD
    __pyx_coroutine_body_t body;
    PyObject *closure;
    __Pyx_ExcInfoStruct gi_exc_state;
    PyObject *gi_weakreflist;
    PyObject *classobj;
    PyObject *yieldfrom;
    PyObject *gi_name;
    PyObject *gi_qualname;
    PyObject *gi_modulename;
    PyObject *gi_code;
    PyObject *gi_frame;
    int resume_label;
    char is_running;
} __pyx_CoroutineObject;
static __pyx_CoroutineObject *__Pyx__Coroutine_New(
    PyTypeObject *type, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
    PyObject *name, PyObject *qualname, PyObject *module_name);
static __pyx_CoroutineObject *__Pyx__Coroutine_NewInit(
            __pyx_CoroutineObject *gen, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
            PyObject *name, PyObject *qualname, PyObject *module_name);
static CYTHON_INLINE void __Pyx_Coroutine_ExceptionClear(__Pyx_ExcInfoStruct *self);
static int __Pyx_Coroutine_clear(PyObject *self);
static PyObject *__Pyx_Coroutine_Send(PyObject *self, PyObject *value);
static PyObject *__Pyx_Coroutine_Close(PyObject *self);
static PyObject *__Pyx_Coroutine_Throw(PyObject *gen, PyObject *args);
#if CYTHON_USE_EXC_INFO_STACK
#define __Pyx_Coroutine_SwapException(self)
#define __Pyx_Coroutine_ResetAndClearException(self)  __Pyx_Coroutine_ExceptionClear(&(self)->gi_exc_state)
#else
#define __Pyx_Coroutine_SwapException(self) {\
    __Pyx_ExceptionSwap(&(self)->gi_exc_state.exc_type, &(self)->gi_exc_state.exc_value, &(self)->gi_exc_state.exc_traceback);\
    __Pyx_Coroutine_ResetFrameBackpointer(&(self)->gi_exc_state);\
    }
#define __Pyx_Coroutine_ResetAndClearException(self) {\
    __Pyx_ExceptionReset((self)->gi_exc_state.exc_type, (self)->gi_exc_state.exc_value, (self)->gi_exc_state.exc_traceback);\
    (self)->gi_exc_state.exc_type = (self)->gi_exc_state.exc_value = (self)->gi_exc_state.exc_traceback = NULL;\
    }
#endif
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyGen_FetchStopIterationValue(pvalue)\
    __Pyx_PyGen__FetchStopIterationValue(__pyx_tstate, pvalue)
#else
#define __Pyx_PyGen_FetchStopIterationValue(pvalue)\
    __Pyx_PyGen__FetchStopIterationValue(__Pyx_PyThreadState_Current, pvalue)
#endif
static int __Pyx_PyGen__FetchStopIterationValue(PyThreadState *tstate, PyObject **pvalue);
static CYTHON_INLINE void __Pyx_Coroutine_ResetFrameBackpointer(__Pyx_ExcInfoStruct *exc_state);

/* PatchModuleWithCoroutine.proto */
static PyObject* __Pyx_Coroutine_patch_module(PyObject* module, const char* py_code);

/* PatchGeneratorABC.proto */
static int __Pyx_patch_abc(void);

/* Generator.proto */
#define __Pyx_Generator_USED
static PyTypeObject *__pyx_GeneratorType = 0;
#define __Pyx_Generator_CheckExact(obj) (Py_TYPE(obj) == __pyx_GeneratorType)
#define __Pyx_Generator_New(body, code, closure, name, qualname, module_name)\
    __Pyx__Coroutine_New(__pyx_GeneratorType, body, code, closure, name, qualname, module_name)
static PyObject *__Pyx_Generator_Next(PyObject *self);
static int __pyx_Generator_init(void);

/* CheckBinaryVersion.proto */
static int __Pyx_check_binary_version(void);

/* InitStrings.proto */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);

static pword __pyx_f_5pyclp_5pyclp_3Ref_get(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self); /* proto*/
static void __pyx_f_5pyclp_5pyclp_3Ref_set(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self, pword __pyx_v_pr_word); /* proto*/
static pword __pyx_f_5pyclp_5pyclp_4Term_get_pword(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self); /* proto*/
static int __pyx_f_5pyclp_5pyclp_4Term_set_pword(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self, pword __pyx_v_in_pword); /* proto*/
static int __pyx_f_5pyclp_5pyclp_4Term_compare_pword(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self, PyObject *__pyx_v_other); /* proto*/
static int __pyx_f_5pyclp_5pyclp_4Atom_set_pword(struct __pyx_obj_5pyclp_5pyclp_Atom *__pyx_v_self, pword __pyx_v_in_pword); /* proto*/
static int __pyx_f_5pyclp_5pyclp_5PList_get_head_tail(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self, pword *__pyx_v_head_ptr, pword *__pyx_v_tail_ptr); /* proto*/
static int __pyx_f_5pyclp_5pyclp_5PList_isNil(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static int __pyx_f_5pyclp_5pyclp_8Compound_arity(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static int __pyx_f_5pyclp_5pyclp_8Compound_set_pword(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self, pword __pyx_v_in_pword); /* proto*/
static PyObject *__pyx_f_5pyclp_5pyclp_8Compound_get_functor_string(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self); /* proto*/
static PyObject *__pyx_f_5pyclp_5pyclp_3Var_value(struct __pyx_obj_5pyclp_5pyclp_Var *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/

/* Module declarations from 'cpython.version' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.type' */
static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;

/* Module declarations from 'libc.string' */

/* Module declarations from 'libc.stdio' */

/* Module declarations from 'cpython.object' */

/* Module declarations from 'cpython.ref' */

/* Module declarations from 'cpython.exc' */

/* Module declarations from 'cpython.module' */

/* Module declarations from 'cpython.mem' */

/* Module declarations from 'cpython.tuple' */

/* Module declarations from 'cpython.list' */

/* Module declarations from 'cpython.sequence' */

/* Module declarations from 'cpython.mapping' */

/* Module declarations from 'cpython.iterator' */

/* Module declarations from 'cpython.number' */

/* Module declarations from 'cpython.int' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.bool' */
static PyTypeObject *__pyx_ptype_7cpython_4bool_bool = 0;

/* Module declarations from 'cpython.long' */

/* Module declarations from 'cpython.float' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.complex' */
static PyTypeObject *__pyx_ptype_7cpython_7complex_complex = 0;

/* Module declarations from 'cpython.string' */

/* Module declarations from 'cpython.unicode' */

/* Module declarations from 'cpython.dict' */

/* Module declarations from 'cpython.instance' */

/* Module declarations from 'cpython.function' */

/* Module declarations from 'cpython.method' */

/* Module declarations from 'cpython.weakref' */

/* Module declarations from 'cpython.getargs' */

/* Module declarations from 'cpython.pythread' */

/* Module declarations from 'cpython.pystate' */

/* Module declarations from 'cpython.cobject' */

/* Module declarations from 'cpython.oldbuffer' */

/* Module declarations from 'cpython.set' */

/* Module declarations from 'cpython.buffer' */

/* Module declarations from 'cpython.bytes' */

/* Module declarations from 'cpython.pycapsule' */

/* Module declarations from 'cpython' */

/* Module declarations from 'libc.stdlib' */

/* Module declarations from 'libc' */

/* Module declarations from 'pyclp.pyclp' */
static PyTypeObject *__pyx_ptype_5pyclp_5pyclp_Ref = 0;
static PyTypeObject *__pyx_ptype_5pyclp_5pyclp_Term = 0;
static PyTypeObject *__pyx_ptype_5pyclp_5pyclp_Atom = 0;
static PyTypeObject *__pyx_ptype_5pyclp_5pyclp_PList = 0;
static PyTypeObject *__pyx_ptype_5pyclp_5pyclp_Compound = 0;
static PyTypeObject *__pyx_ptype_5pyclp_5pyclp_Var = 0;
static PyTypeObject *__pyx_ptype_5pyclp_5pyclp___pyx_scope_struct__head_generator = 0;
static PyTypeObject *__pyx_ptype_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator = 0;
static PyTypeObject *__pyx_ptype_5pyclp_5pyclp___pyx_scope_struct_2_arguments = 0;
static struct __pyx_obj_5pyclp_5pyclp_Var *__pyx_v_5pyclp_5pyclp_toPython = 0;
static int __pyx_v_5pyclp_5pyclp_eclipse_initialized;
static PyObject *__pyx_f_5pyclp_5pyclp_tounicode(char *); /*proto*/
static PyObject *__pyx_f_5pyclp_5pyclp_tounicode_with_length(char *, size_t); /*proto*/
static PyObject *__pyx_f_5pyclp_5pyclp_tobytes(PyObject *); /*proto*/
__PYX_EXTERN_C int call_python(void); /*proto*/
static int __pyx_f_5pyclp_5pyclp_register_call_python_pred(void); /*proto*/
static PyObject *__pyx_f_5pyclp_5pyclp_formatTermStr(PyObject *, int __pyx_skip_dispatch); /*proto*/
static PyObject *__pyx_f_5pyclp_5pyclp_destroy_all_refs(void); /*proto*/
static PyObject *__pyx_f_5pyclp_5pyclp_recreate_all_refs(void); /*proto*/
static PyObject *__pyx_f_5pyclp_5pyclp_pword2object(pword); /*proto*/
#define __Pyx_MODULE_NAME "pyclp.pyclp"
extern int __pyx_module_is_main_pyclp__pyclp;
int __pyx_module_is_main_pyclp__pyclp = 0;

/* Implementation of 'pyclp.pyclp' */
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_TypeError;
static PyObject *__pyx_builtin_IOError;
static PyObject *__pyx_builtin_NotImplemented;
static PyObject *__pyx_builtin_range;
static PyObject *__pyx_builtin_IndexError;
static PyObject *__pyx_builtin_map;
static const char __pyx_k_[] = "";
static const char __pyx_k_0[] = "[{0}]";
static const char __pyx_k_b[] = "b";
static const char __pyx_k_n[] = "n";
static const char __pyx_k__2[] = "\"";
static const char __pyx_k_io[] = "io";
static const char __pyx_k_0_1[] = "[{0}|{1}]";
static const char __pyx_k_Ref[] = "Ref";
static const char __pyx_k_Var[] = "Var";
static const char __pyx_k__24[] = ",";
static const char __pyx_k__30[] = "_";
static const char __pyx_k_add[] = "add";
static const char __pyx_k_arg[] = "arg";
static const char __pyx_k_cut[] = "cut";
static const char __pyx_k_doc[] = "__doc__";
static const char __pyx_k_map[] = "map";
static const char __pyx_k_msg[] = "msg";
static const char __pyx_k_str[] = "__str__";
static const char __pyx_k_sys[] = "sys";
static const char __pyx_k_Atom[] = "Atom";
static const char __pyx_k_FAIL[] = "FAIL";
static const char __pyx_k_Term[] = "Term";
static const char __pyx_k_args[] = "args";
static const char __pyx_k_func[] = "func";
static const char __pyx_k_init[] = "__init__";
static const char __pyx_k_join[] = "join";
static const char __pyx_k_main[] = "__main__";
static const char __pyx_k_name[] = "name";
static const char __pyx_k_read[] = "read";
static const char __pyx_k_self[] = "self";
static const char __pyx_k_send[] = "send";
static const char __pyx_k_size[] = "size";
static const char __pyx_k_tail[] = "tail";
static const char __pyx_k_test[] = "__test__";
static const char __pyx_k_0_s_1[] = "{0!s}({1})";
static const char __pyx_k_PList[] = "PList";
static const char __pyx_k_THROW[] = "THROW";
static const char __pyx_k_YIELD[] = "YIELD";
static const char __pyx_k_arity[] = "arity";
static const char __pyx_k_ascii[] = "ascii";
static const char __pyx_k_cinit[] = "cinit";
static const char __pyx_k_close[] = "close";
static const char __pyx_k_flush[] = "flush";
static const char __pyx_k_isNil[] = "isNil";
static const char __pyx_k_range[] = "range";
static const char __pyx_k_term1[] = "term1";
static const char __pyx_k_term2[] = "term2";
static const char __pyx_k_throw[] = "throw";
static const char __pyx_k_types[] = "types";
static const char __pyx_k_unify[] = "unify";
static const char __pyx_k_value[] = "value";
static const char __pyx_k_write[] = "write";
static const char __pyx_k_Stream[] = "Stream";
static const char __pyx_k_WAITIO[] = "WAITIO";
static const char __pyx_k_buffer[] = "buffer";
static const char __pyx_k_encode[] = "encode";
static const char __pyx_k_fileno[] = "fileno";
static const char __pyx_k_format[] = "format";
static const char __pyx_k_import[] = "__import__";
static const char __pyx_k_in_ref[] = "in_ref";
static const char __pyx_k_init_2[] = "init";
static const char __pyx_k_isatty[] = "isatty";
static const char __pyx_k_lenght[] = "lenght";
static const char __pyx_k_module[] = "__module__";
static const char __pyx_k_name_2[] = "__name__";
static const char __pyx_k_option[] = "option";
static const char __pyx_k_reduce[] = "__reduce__";
static const char __pyx_k_result[] = "result";
static const char __pyx_k_resume[] = "resume";
static const char __pyx_k_string[] = "string";
static const char __pyx_k_FLUSHIO[] = "FLUSHIO";
static const char __pyx_k_IOError[] = "IOError";
static const char __pyx_k_SUCCEED[] = "SUCCEED";
static const char __pyx_k_WeakSet[] = "WeakSet";
static const char __pyx_k_cleanup[] = "cleanup";
static const char __pyx_k_compare[] = "compare";
static const char __pyx_k_dealloc[] = "dealloc";
static const char __pyx_k_in_list[] = "in_list";
static const char __pyx_k_in_term[] = "in_term";
static const char __pyx_k_prepare[] = "__prepare__";
static const char __pyx_k_pyclpEx[] = "pyclpEx";
static const char __pyx_k_readall[] = "readall";
static const char __pyx_k_weakref[] = "weakref";
static const char __pyx_k_Compound[] = "Compound";
static const char __pyx_k_c_string[] = "c_string";
static const char __pyx_k_getstate[] = "__getstate__";
static const char __pyx_k_in_pword[] = "in_pword";
static const char __pyx_k_init_arg[] = "init_arg";
static const char __pyx_k_qualname[] = "__qualname__";
static const char __pyx_k_readable[] = "readable";
static const char __pyx_k_readinto[] = "readinto";
static const char __pyx_k_seekable[] = "seekable";
static const char __pyx_k_setstate[] = "__setstate__";
static const char __pyx_k_truncate[] = "truncate";
static const char __pyx_k_OPTION_IO[] = "OPTION_IO";
static const char __pyx_k_RawIOBase[] = "RawIOBase";
static const char __pyx_k_TypeError[] = "TypeError";
static const char __pyx_k_arguments[] = "arguments";
static const char __pyx_k_metaclass[] = "__metaclass__";
static const char __pyx_k_reduce_ex[] = "__reduce_ex__";
static const char __pyx_k_writeable[] = "writeable";
static const char __pyx_k_IndexError[] = "IndexError";
static const char __pyx_k_ValueError[] = "ValueError";
static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
static const char __pyx_k_set_option[] = "set_option";
static const char __pyx_k_stream_num[] = "stream_num";
static const char __pyx_k_term1_term[] = "term1_term";
static const char __pyx_k_term2_term[] = "term2_term";
static const char __pyx_k_OPTION_ARGC[] = "OPTION_ARGC";
static const char __pyx_k_OPTION_ARGV[] = "OPTION_ARGV";
static const char __pyx_k_OPTION_INIT[] = "OPTION_INIT";
static const char __pyx_k_Stream_read[] = "Stream.read";
static const char __pyx_k_getListTail[] = "getListTail";
static const char __pyx_k_pyclp_pyclp[] = "pyclp.pyclp";
static const char __pyx_k_FunctionType[] = "FunctionType";
static const char __pyx_k_OPTION_PANIC[] = "OPTION_PANIC";
static const char __pyx_k_Stream_flush[] = "Stream.flush";
static const char __pyx_k_Stream_write[] = "Stream.write";
static const char __pyx_k_eclipse_name[] = "eclipse_name";
static const char __pyx_k_encoded_name[] = "encoded_name";
static const char __pyx_k_iterHeadTail[] = "iterHeadTail";
static const char __pyx_k_python_error[] = "python_error";
static const char __pyx_k_Stream___init[] = "Stream.__init__";
static const char __pyx_k_Stream_fileno[] = "Stream.fileno";
static const char __pyx_k_Stream_isatty[] = "Stream.isatty";
static const char __pyx_k_formatTermStr[] = "formatTermStr";
static const char __pyx_k_pyclpEx___str[] = "pyclpEx.__str__";
static const char __pyx_k_python_buffer[] = "python_buffer";
static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
static const char __pyx_k_NotImplemented[] = "NotImplemented";
static const char __pyx_k_OPTION_MAPFILE[] = "OPTION_MAPFILE";
static const char __pyx_k_Stream_readall[] = "Stream.readall";
static const char __pyx_k_functor_string[] = "functor_string";
static const char __pyx_k_head_generator[] = "head_generator";
static const char __pyx_k_num_bytes_read[] = "num_bytes_read";
static const char __pyx_k_py_byte_string[] = "py_byte_string";
static const char __pyx_k_pyclpEx___init[] = "pyclpEx.__init__";
static const char __pyx_k_returned_value[] = "returned_value";
static const char __pyx_k_Stream_readable[] = "Stream.readable";
static const char __pyx_k_Stream_readinto[] = "Stream.readinto";
static const char __pyx_k_Stream_seekable[] = "Stream.seekable";
static const char __pyx_k_Stream_truncate[] = "Stream.truncate";
static const char __pyx_k_all_active_refs[] = "all_active_refs";
static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
static const char __pyx_k_OPTION_LOCALSIZE[] = "OPTION_LOCALSIZE";
static const char __pyx_k_Stream_writeable[] = "Stream.writeable";
static const char __pyx_k_python_pred2func[] = "python_pred2func";
static const char __pyx_k_OPTION_ALLOCATION[] = "OPTION_ALLOCATION";
static const char __pyx_k_OPTION_ECLIPSEDIR[] = "OPTION_ECLIPSEDIR";
static const char __pyx_k_OPTION_GLOBALSIZE[] = "OPTION_GLOBALSIZE";
static const char __pyx_k_OPTION_SHAREDSIZE[] = "OPTION_SHAREDSIZE";
static const char __pyx_k_addPythonFunction[] = "addPythonFunction";
static const char __pyx_k_Compound_arguments[] = "Compound.arguments";
static const char __pyx_k_OPTION_DEBUG_LEVEL[] = "OPTION_DEBUG_LEVEL";
static const char __pyx_k_OPTION_PRIVATESIZE[] = "OPTION_PRIVATESIZE";
static const char __pyx_k_Unsupported_option[] = "Unsupported option";
static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
static const char __pyx_k_last_resume_result[] = "last_resume_result";
static const char __pyx_k_head_tail_generator[] = "head_tail_generator";
static const char __pyx_k_src_pyclp_pyclp_pyx[] = "src\\pyclp\\pyclp.pyx";
static const char __pyx_k_PList_head_generator[] = "PList.head_generator";
static const char __pyx_k_value_shall_be_a_int[] = "value shall be a int";
static const char __pyx_k_Failed_initialization[] = "Failed initialization";
static const char __pyx_k_OPTION_DEFAULT_MODULE[] = "OPTION_DEFAULT_MODULE";
static const char __pyx_k_pyPredicatesException[] = "pyPredicatesException";
static const char __pyx_k_OPTION_PARALLEL_WORKER[] = "OPTION_PARALLEL_WORKER";
static const char __pyx_k_value_shall_be_a_string[] = "value shall be a string";
static const char __pyx_k_Failed_cleanup_operation[] = "Failed cleanup operation";
static const char __pyx_k_Index_shall_be_a_integer[] = "Index shall be a integer";
static const char __pyx_k_func_shall_be_a_function[] = "func shall be a function";
static const char __pyx_k_PList_head_tail_generator[] = "PList.head_tail_generator";
static const char __pyx_k_requires_text_input_got_s[] = "requires text input, got %s";
static const char __pyx_k_Argument_index_out_of_range[] = "Argument index out of range";
static const char __pyx_k_Invalid_option_in_set_option[] = "Invalid option in set_option";
static const char __pyx_k_Arity_of_compound_item_shall_be[] = "Arity of compound item shall be >0";
static const char __pyx_k_Class_to_support_streams_to_and[] = "Class to support streams to and from ECLiPSe.\n    This is class is derived from io.RawIOBase.\n    \n    :param name: string containing stream name of a previously opened stream by ECLiPSe program.     See: `Embedded C stream api <http://www.eclipseclp.org/doc/embedding/embroot082.html>`_     and `get_stream/2 <http://www.eclipseclp.org/doc/bips/kernel/iostream/get_stream-2.html>`_\n    \n    .. note:: \n        The following stream are already opened:         'input', 'output', 'error', 'warning_output', 'log_output', 'stdin', 'stdout', 'stderr', 'null'.\n    \n    :raise IOError: if name is not matching a previously open stream by     `open/3 <http://www.eclipseclp.org/doc/bips/kernel/iostream/open-3.html>`_ and     `open/4 <http://www.eclipseclp.org/doc/bips/kernel/iostream/open-4.html>`_\n    \n\n    \n      \n    ";
static const char __pyx_k_Comparison_between_incompatible[] = "Comparison between incompatible types";
static const char __pyx_k_Cut_it_is_possible_only_after_a[] = "Cut it is possible only after a resume that returns SUCCEED.";
static const char __pyx_k_PList_tail_shall_be_a_list_or_a[] = "PList tail shall be a list or a Term";
static const char __pyx_k_Pickling_of_struct_members_such[] = "Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)";
static const char __pyx_k_Pyclp_is_a_Python_library_to_in[] = "\nPyclp is a Python library to interface ECLiPSe Constraint Programmig System.\n\n.. note:: \n    Classes :py:class:`PList`, :py:class:`Atom`, :py:class:`Compound` can be compared each other as\n    in `ec_compare <http://www.eclipseclp.org/doc/embedding/embroot078.html>`_\n \n\n";
static const char __pyx_k_create_module_pyclp_call_python[] = "create_module(pyclp,[call_python_function/2],[eclipse_language]),compile_term([python_error_event_handler(_):- exit_block(python_error),:-  set_event_handler(python_error_event,python_error_event_handler/1) ])@pyclp,use_module(pyclp)";
static const char __pyx_k_init_argument_shall_be_a_string[] = "init argument shall be a string, integer or float";
static const char __pyx_k_Argument_index_out_of_range_0_ar[] = "Argument index out of range {0} arity {1}";
static const char __pyx_k_Atom_constructor_accept_only_str[] = "Atom constructor accept only string";
static const char __pyx_k_Failed_retrieving_of_Atom_dictio[] = "Failed retrieving of Atom dictionary item";
static const char __pyx_k_Failed_retrieving_of_Functor_dic[] = "Failed retrieving of Functor dictionary item";
static const char __pyx_k_Functor_arity_bigger_than_availa[] = "Functor arity bigger than available args";
static const char __pyx_k_PList_constructor_accept_only_li[] = "PList constructor accept only list or tuple";
static const char __pyx_k_PList_tail_shall_be_a_list_tuple[] = "PList tail shall be a list, tuple or  Term";
static const char __pyx_k_Range_error_while_getting_args_p[] = "Range error while getting args probably data corruption";
static const char __pyx_k_This_comparison_operation_is_not[] = "This comparison operation is not supported with None. Only supported comparison == !=";
static const char __pyx_k_Tried_to_cleanup_an_already_shut[] = "Tried to cleanup an already shutdown engine";
static const char __pyx_k_Tried_to_initialize_an_already_i[] = "Tried to initialize an already initialized eclipse engine";
static const char __pyx_k_Unknow_error_during_args_getting[] = "Unknow error during args getting";
static const char __pyx_k_Unknown_type_returned_by_eclipse[] = "Unknown type returned by eclipse";
static const char __pyx_k_Unrecognized_result_from_ec_resu[] = "Unrecognized result from ec_resume";
static const char __pyx_k_eclipse_name_shall_be_a_text_got[] = "eclipse_name shall be a text, got %s";
static const char __pyx_k_init_failed_registering_of_eclip[] = "init() failed registering of eclipse:call_python_func";
static const char __pyx_k_name_shall_be_a_string_or_a_inte[] = "name shall be a string or a integer";
static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
static const char __pyx_k_self_ec_dict_ptr_cannot_be_conve[] = "self.ec_dict_ptr cannot be converted to a Python object for pickling";
static PyObject *__pyx_kp_s_;
static PyObject *__pyx_kp_s_0;
static PyObject *__pyx_kp_s_0_1;
static PyObject *__pyx_kp_s_0_s_1;
static PyObject *__pyx_kp_s_Argument_index_out_of_range;
static PyObject *__pyx_kp_s_Argument_index_out_of_range_0_ar;
static PyObject *__pyx_kp_s_Arity_of_compound_item_shall_be;
static PyObject *__pyx_n_s_Atom;
static PyObject *__pyx_kp_s_Atom_constructor_accept_only_str;
static PyObject *__pyx_kp_s_Class_to_support_streams_to_and;
static PyObject *__pyx_kp_s_Comparison_between_incompatible;
static PyObject *__pyx_n_s_Compound;
static PyObject *__pyx_n_s_Compound_arguments;
static PyObject *__pyx_kp_s_Cut_it_is_possible_only_after_a;
static PyObject *__pyx_n_s_FAIL;
static PyObject *__pyx_n_s_FLUSHIO;
static PyObject *__pyx_kp_s_Failed_cleanup_operation;
static PyObject *__pyx_kp_s_Failed_initialization;
static PyObject *__pyx_kp_s_Failed_retrieving_of_Atom_dictio;
static PyObject *__pyx_kp_s_Failed_retrieving_of_Functor_dic;
static PyObject *__pyx_n_s_FunctionType;
static PyObject *__pyx_kp_s_Functor_arity_bigger_than_availa;
static PyObject *__pyx_n_s_IOError;
static PyObject *__pyx_n_s_IndexError;
static PyObject *__pyx_kp_s_Index_shall_be_a_integer;
static PyObject *__pyx_kp_s_Invalid_option_in_set_option;
static PyObject *__pyx_n_s_NotImplemented;
static PyObject *__pyx_n_s_OPTION_ALLOCATION;
static PyObject *__pyx_n_s_OPTION_ARGC;
static PyObject *__pyx_n_s_OPTION_ARGV;
static PyObject *__pyx_n_s_OPTION_DEBUG_LEVEL;
static PyObject *__pyx_n_s_OPTION_DEFAULT_MODULE;
static PyObject *__pyx_n_s_OPTION_ECLIPSEDIR;
static PyObject *__pyx_n_s_OPTION_GLOBALSIZE;
static PyObject *__pyx_n_s_OPTION_INIT;
static PyObject *__pyx_n_s_OPTION_IO;
static PyObject *__pyx_n_s_OPTION_LOCALSIZE;
static PyObject *__pyx_n_s_OPTION_MAPFILE;
static PyObject *__pyx_n_s_OPTION_PANIC;
static PyObject *__pyx_n_s_OPTION_PARALLEL_WORKER;
static PyObject *__pyx_n_s_OPTION_PRIVATESIZE;
static PyObject *__pyx_n_s_OPTION_SHAREDSIZE;
static PyObject *__pyx_n_s_PList;
static PyObject *__pyx_kp_s_PList_constructor_accept_only_li;
static PyObject *__pyx_n_s_PList_head_generator;
static PyObject *__pyx_n_s_PList_head_tail_generator;
static PyObject *__pyx_kp_s_PList_tail_shall_be_a_list_or_a;
static PyObject *__pyx_kp_s_PList_tail_shall_be_a_list_tuple;
static PyObject *__pyx_kp_s_Pickling_of_struct_members_such;
static PyObject *__pyx_kp_s_Range_error_while_getting_args_p;
static PyObject *__pyx_n_s_RawIOBase;
static PyObject *__pyx_n_s_Ref;
static PyObject *__pyx_n_s_SUCCEED;
static PyObject *__pyx_n_s_Stream;
static PyObject *__pyx_n_s_Stream___init;
static PyObject *__pyx_n_s_Stream_fileno;
static PyObject *__pyx_n_s_Stream_flush;
static PyObject *__pyx_n_s_Stream_isatty;
static PyObject *__pyx_n_s_Stream_read;
static PyObject *__pyx_n_s_Stream_readable;
static PyObject *__pyx_n_s_Stream_readall;
static PyObject *__pyx_n_s_Stream_readinto;
static PyObject *__pyx_n_s_Stream_seekable;
static PyObject *__pyx_n_s_Stream_truncate;
static PyObject *__pyx_n_s_Stream_write;
static PyObject *__pyx_n_s_Stream_writeable;
static PyObject *__pyx_n_s_THROW;
static PyObject *__pyx_n_s_Term;
static PyObject *__pyx_kp_s_This_comparison_operation_is_not;
static PyObject *__pyx_kp_s_Tried_to_cleanup_an_already_shut;
static PyObject *__pyx_kp_s_Tried_to_initialize_an_already_i;
static PyObject *__pyx_n_s_TypeError;
static PyObject *__pyx_kp_s_Unknow_error_during_args_getting;
static PyObject *__pyx_kp_s_Unknown_type_returned_by_eclipse;
static PyObject *__pyx_kp_s_Unrecognized_result_from_ec_resu;
static PyObject *__pyx_kp_s_Unsupported_option;
static PyObject *__pyx_n_s_ValueError;
static PyObject *__pyx_n_s_Var;
static PyObject *__pyx_n_s_WAITIO;
static PyObject *__pyx_n_s_WeakSet;
static PyObject *__pyx_n_s_YIELD;
static PyObject *__pyx_kp_s__2;
static PyObject *__pyx_kp_s__24;
static PyObject *__pyx_n_s__30;
static PyObject *__pyx_n_s_add;
static PyObject *__pyx_n_s_addPythonFunction;
static PyObject *__pyx_n_s_all_active_refs;
static PyObject *__pyx_n_s_arg;
static PyObject *__pyx_n_s_args;
static PyObject *__pyx_n_s_arguments;
static PyObject *__pyx_n_s_arity;
static PyObject *__pyx_n_s_ascii;
static PyObject *__pyx_n_s_b;
static PyObject *__pyx_n_s_buffer;
static PyObject *__pyx_n_s_c_string;
static PyObject *__pyx_n_s_cinit;
static PyObject *__pyx_n_s_cleanup;
static PyObject *__pyx_n_s_cline_in_traceback;
static PyObject *__pyx_n_s_close;
static PyObject *__pyx_n_s_compare;
static PyObject *__pyx_kp_s_create_module_pyclp_call_python;
static PyObject *__pyx_n_s_cut;
static PyObject *__pyx_n_s_dealloc;
static PyObject *__pyx_n_s_doc;
static PyObject *__pyx_n_s_eclipse_name;
static PyObject *__pyx_kp_s_eclipse_name_shall_be_a_text_got;
static PyObject *__pyx_n_s_encode;
static PyObject *__pyx_n_s_encoded_name;
static PyObject *__pyx_n_s_fileno;
static PyObject *__pyx_n_s_flush;
static PyObject *__pyx_n_s_format;
static PyObject *__pyx_n_s_formatTermStr;
static PyObject *__pyx_n_s_func;
static PyObject *__pyx_kp_s_func_shall_be_a_function;
static PyObject *__pyx_n_s_functor_string;
static PyObject *__pyx_n_s_getListTail;
static PyObject *__pyx_n_s_getstate;
static PyObject *__pyx_n_s_head_generator;
static PyObject *__pyx_n_s_head_tail_generator;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_n_s_in_list;
static PyObject *__pyx_n_s_in_pword;
static PyObject *__pyx_n_s_in_ref;
static PyObject *__pyx_n_s_in_term;
static PyObject *__pyx_n_s_init;
static PyObject *__pyx_n_s_init_2;
static PyObject *__pyx_n_s_init_arg;
static PyObject *__pyx_kp_s_init_argument_shall_be_a_string;
static PyObject *__pyx_kp_s_init_failed_registering_of_eclip;
static PyObject *__pyx_n_s_io;
static PyObject *__pyx_n_s_isNil;
static PyObject *__pyx_n_s_isatty;
static PyObject *__pyx_n_s_iterHeadTail;
static PyObject *__pyx_n_s_join;
static PyObject *__pyx_n_s_last_resume_result;
static PyObject *__pyx_n_s_lenght;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_map;
static PyObject *__pyx_n_s_metaclass;
static PyObject *__pyx_n_s_module;
static PyObject *__pyx_n_s_msg;
static PyObject *__pyx_n_s_n;
static PyObject *__pyx_n_s_name;
static PyObject *__pyx_n_s_name_2;
static PyObject *__pyx_kp_s_name_shall_be_a_string_or_a_inte;
static PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
static PyObject *__pyx_n_s_num_bytes_read;
static PyObject *__pyx_n_s_option;
static PyObject *__pyx_n_s_prepare;
static PyObject *__pyx_n_s_pyPredicatesException;
static PyObject *__pyx_n_s_py_byte_string;
static PyObject *__pyx_n_s_pyclpEx;
static PyObject *__pyx_n_s_pyclpEx___init;
static PyObject *__pyx_n_s_pyclpEx___str;
static PyObject *__pyx_n_s_pyclp_pyclp;
static PyObject *__pyx_n_s_python_buffer;
static PyObject *__pyx_n_s_python_error;
static PyObject *__pyx_n_s_python_pred2func;
static PyObject *__pyx_n_s_pyx_vtable;
static PyObject *__pyx_n_s_qualname;
static PyObject *__pyx_n_s_range;
static PyObject *__pyx_n_s_read;
static PyObject *__pyx_n_s_readable;
static PyObject *__pyx_n_s_readall;
static PyObject *__pyx_n_s_readinto;
static PyObject *__pyx_n_s_reduce;
static PyObject *__pyx_n_s_reduce_cython;
static PyObject *__pyx_n_s_reduce_ex;
static PyObject *__pyx_kp_s_requires_text_input_got_s;
static PyObject *__pyx_n_s_result;
static PyObject *__pyx_n_s_resume;
static PyObject *__pyx_n_s_returned_value;
static PyObject *__pyx_n_s_seekable;
static PyObject *__pyx_n_s_self;
static PyObject *__pyx_kp_s_self_ec_dict_ptr_cannot_be_conve;
static PyObject *__pyx_n_s_send;
static PyObject *__pyx_n_s_set_option;
static PyObject *__pyx_n_s_setstate;
static PyObject *__pyx_n_s_setstate_cython;
static PyObject *__pyx_n_s_size;
static PyObject *__pyx_kp_s_src_pyclp_pyclp_pyx;
static PyObject *__pyx_n_s_str;
static PyObject *__pyx_n_s_stream_num;
static PyObject *__pyx_n_s_string;
static PyObject *__pyx_n_s_sys;
static PyObject *__pyx_n_s_tail;
static PyObject *__pyx_n_s_term1;
static PyObject *__pyx_n_s_term1_term;
static PyObject *__pyx_n_s_term2;
static PyObject *__pyx_n_s_term2_term;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_n_s_throw;
static PyObject *__pyx_n_s_truncate;
static PyObject *__pyx_n_s_types;
static PyObject *__pyx_n_s_unify;
static PyObject *__pyx_n_s_value;
static PyObject *__pyx_kp_s_value_shall_be_a_int;
static PyObject *__pyx_kp_s_value_shall_be_a_string;
static PyObject *__pyx_n_s_weakref;
static PyObject *__pyx_n_s_write;
static PyObject *__pyx_n_s_writeable;
static PyObject *__pyx_pf_5pyclp_5pyclp_7pyclpEx___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_arg); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_7pyclpEx_2__str__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_formatTermStr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_element); /* proto */
static int __pyx_pf_5pyclp_5pyclp_3Ref___cinit__(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_3Ref_2cinit(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self); /* proto */
static int __pyx_pf_5pyclp_5pyclp_3Ref_4__init__(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self); /* proto */
static void __pyx_pf_5pyclp_5pyclp_3Ref_6__dealloc__(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_3Ref_8dealloc(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_3Ref_10__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_3Ref_12__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_name); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_2seekable(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_4readable(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_6writeable(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_8fileno(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_10isatty(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_12truncate(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_size); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_14flush(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_16read(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, int __pyx_v_n); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_18write(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_buffer); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_20readall(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_22readinto(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_b); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_2init(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_4cleanup(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_6cut(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_8resume(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_in_term); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_10set_option(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_option, PyObject *__pyx_v_value); /* proto */
static int __pyx_pf_5pyclp_5pyclp_4Term___init__(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self, PyObject *__pyx_v_init_arg); /* proto */
#if PY_MAJOR_VERSION < 3
static int __pyx_pf_5pyclp_5pyclp_4Term_2__cmp__(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self, PyObject *__pyx_v_other); /* proto */
#endif
static PyObject *__pyx_pf_5pyclp_5pyclp_4Term_4__richcmp__(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self, PyObject *__pyx_v_other, PyObject *__pyx_v_op); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_4Term_6post_goal(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_4Term_8__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_4Term_10__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_5pyclp_5pyclp_4Atom___init__(struct __pyx_obj_5pyclp_5pyclp_Atom *__pyx_v_self, PyObject *__pyx_v_string); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_4Atom_2__str__(struct __pyx_obj_5pyclp_5pyclp_Atom *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_4Atom_4__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Atom *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_4Atom_6__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Atom *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_5pyclp_5pyclp_5PList___init__(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self, PyObject *__pyx_v_in_list, PyObject *__pyx_v_tail); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_2head_generator(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_5head_tail_generator(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_8__iter__(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self); /* proto */
static Py_ssize_t __pyx_pf_5pyclp_5pyclp_5PList_10__len__(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_12iterheadtail(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_14iterHeadTail(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_16__getitem__(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self, PyObject *__pyx_v_index); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_18getListTail(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_20isNil(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_22__str__(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_24__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_26__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_5pyclp_5pyclp_8Compound___init__(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self, PyObject *__pyx_v_functor_string, PyObject *__pyx_v_args); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_2arity(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_4functor(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_6arguments(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_9__iter__(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self); /* proto */
static Py_ssize_t __pyx_pf_5pyclp_5pyclp_8Compound_11__len__(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_13__getitem__(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self, PyObject *__pyx_v_index); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_15__str__(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_17__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_19__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_5pyclp_5pyclp_3Var___init__(struct __pyx_obj_5pyclp_5pyclp_Var *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_3Var_2value(struct __pyx_obj_5pyclp_5pyclp_Var *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_3Var_4__str__(struct __pyx_obj_5pyclp_5pyclp_Var *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_3Var_6__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Var *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_3Var_8__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Var *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_12unify(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_term1, PyObject *__pyx_v_term2); /* proto */
static PyObject *__pyx_pf_5pyclp_5pyclp_14addPythonFunction(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_eclipse_name, PyObject *__pyx_v_func); /* proto */
static PyObject *__pyx_tp_new_5pyclp_5pyclp_Ref(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pyclp_5pyclp_Term(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pyclp_5pyclp_Atom(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pyclp_5pyclp_PList(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pyclp_5pyclp_Compound(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pyclp_5pyclp_Var(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pyclp_5pyclp___pyx_scope_struct__head_generator(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pyclp_5pyclp___pyx_scope_struct_2_arguments(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_1;
static PyObject *__pyx_int_2;
static PyObject *__pyx_int_3;
static PyObject *__pyx_int_4;
static PyObject *__pyx_int_5;
static PyObject *__pyx_int_neg_1;
static PyObject *__pyx_k__19;
static PyObject *__pyx_tuple__3;
static PyObject *__pyx_tuple__4;
static PyObject *__pyx_tuple__5;
static PyObject *__pyx_tuple__6;
static PyObject *__pyx_tuple__7;
static PyObject *__pyx_tuple__8;
static PyObject *__pyx_tuple__9;
static PyObject *__pyx_tuple__10;
static PyObject *__pyx_tuple__11;
static PyObject *__pyx_tuple__12;
static PyObject *__pyx_tuple__13;
static PyObject *__pyx_tuple__14;
static PyObject *__pyx_tuple__15;
static PyObject *__pyx_tuple__16;
static PyObject *__pyx_tuple__17;
static PyObject *__pyx_tuple__18;
static PyObject *__pyx_tuple__20;
static PyObject *__pyx_tuple__21;
static PyObject *__pyx_tuple__22;
static PyObject *__pyx_tuple__23;
static PyObject *__pyx_tuple__25;
static PyObject *__pyx_tuple__26;
static PyObject *__pyx_tuple__27;
static PyObject *__pyx_tuple__28;
static PyObject *__pyx_tuple__29;
static PyObject *__pyx_tuple__31;
static PyObject *__pyx_tuple__32;
static PyObject *__pyx_tuple__33;
static PyObject *__pyx_tuple__34;
static PyObject *__pyx_tuple__36;
static PyObject *__pyx_tuple__38;
static PyObject *__pyx_tuple__40;
static PyObject *__pyx_tuple__42;
static PyObject *__pyx_tuple__44;
static PyObject *__pyx_tuple__46;
static PyObject *__pyx_tuple__48;
static PyObject *__pyx_tuple__50;
static PyObject *__pyx_tuple__52;
static PyObject *__pyx_tuple__53;
static PyObject *__pyx_tuple__55;
static PyObject *__pyx_tuple__57;
static PyObject *__pyx_tuple__59;
static PyObject *__pyx_tuple__61;
static PyObject *__pyx_tuple__66;
static PyObject *__pyx_tuple__68;
static PyObject *__pyx_tuple__70;
static PyObject *__pyx_tuple__72;
static PyObject *__pyx_codeobj__35;
static PyObject *__pyx_codeobj__37;
static PyObject *__pyx_codeobj__39;
static PyObject *__pyx_codeobj__41;
static PyObject *__pyx_codeobj__43;
static PyObject *__pyx_codeobj__45;
static PyObject *__pyx_codeobj__47;
static PyObject *__pyx_codeobj__49;
static PyObject *__pyx_codeobj__51;
static PyObject *__pyx_codeobj__54;
static PyObject *__pyx_codeobj__56;
static PyObject *__pyx_codeobj__58;
static PyObject *__pyx_codeobj__60;
static PyObject *__pyx_codeobj__62;
static PyObject *__pyx_codeobj__63;
static PyObject *__pyx_codeobj__64;
static PyObject *__pyx_codeobj__65;
static PyObject *__pyx_codeobj__67;
static PyObject *__pyx_codeobj__69;
static PyObject *__pyx_codeobj__71;
static PyObject *__pyx_codeobj__73;
/* Late includes */

/* "pyclp/pyclp.pyx":76
 * 
 * class pyclpEx(Exception):
 *     def __init__(self,arg):             # <<<<<<<<<<<<<<
 *         self.msg=arg
 *     def __str__(self):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_7pyclpEx_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_7pyclpEx_1__init__ = {"__init__", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyclp_5pyclp_7pyclpEx_1__init__, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_5pyclp_5pyclp_7pyclpEx_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_arg = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_arg,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arg)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); __PYX_ERR(0, 76, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 76, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_arg = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 76, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.pyclpEx.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_7pyclpEx___init__(__pyx_self, __pyx_v_self, __pyx_v_arg);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_7pyclpEx___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_arg) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "pyclp/pyclp.pyx":77
 * class pyclpEx(Exception):
 *     def __init__(self,arg):
 *         self.msg=arg             # <<<<<<<<<<<<<<
 *     def __str__(self):
 *         return self.msg
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_msg, __pyx_v_arg) < 0) __PYX_ERR(0, 77, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":76
 * 
 * class pyclpEx(Exception):
 *     def __init__(self,arg):             # <<<<<<<<<<<<<<
 *         self.msg=arg
 *     def __str__(self):
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyclp.pyclp.pyclpEx.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":78
 *     def __init__(self,arg):
 *         self.msg=arg
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         return self.msg
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_7pyclpEx_3__str__(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_7pyclpEx_3__str__ = {"__str__", (PyCFunction)__pyx_pw_5pyclp_5pyclp_7pyclpEx_3__str__, METH_O, 0};
static PyObject *__pyx_pw_5pyclp_5pyclp_7pyclpEx_3__str__(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__str__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_7pyclpEx_2__str__(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_7pyclpEx_2__str__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__str__", 0);

  /* "pyclp/pyclp.pyx":79
 *         self.msg=arg
 *     def __str__(self):
 *         return self.msg             # <<<<<<<<<<<<<<
 * 
 * cdef object tounicode(char* s):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_msg); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 79, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":78
 *     def __init__(self,arg):
 *         self.msg=arg
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         return self.msg
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.pyclpEx.__str__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":81
 *         return self.msg
 * 
 * cdef object tounicode(char* s):             # <<<<<<<<<<<<<<
 *     cdef bytes py_string_bytes
 *     if (PY_MAJOR_VERSION < 3):
 */

static PyObject *__pyx_f_5pyclp_5pyclp_tounicode(char *__pyx_v_s) {
  PyObject *__pyx_v_py_string_bytes = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("tounicode", 0);

  /* "pyclp/pyclp.pyx":83
 * cdef object tounicode(char* s):
 *     cdef bytes py_string_bytes
 *     if (PY_MAJOR_VERSION < 3):             # <<<<<<<<<<<<<<
 *         py_string_bytes=s
 *         return py_string_bytes
 */
  __pyx_t_1 = ((PY_MAJOR_VERSION < 3) != 0);
  if (__pyx_t_1) {

    /* "pyclp/pyclp.pyx":84
 *     cdef bytes py_string_bytes
 *     if (PY_MAJOR_VERSION < 3):
 *         py_string_bytes=s             # <<<<<<<<<<<<<<
 *         return py_string_bytes
 *     else:
 */
    __pyx_t_2 = __Pyx_PyBytes_FromString(__pyx_v_s); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 84, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_v_py_string_bytes = ((PyObject*)__pyx_t_2);
    __pyx_t_2 = 0;

    /* "pyclp/pyclp.pyx":85
 *     if (PY_MAJOR_VERSION < 3):
 *         py_string_bytes=s
 *         return py_string_bytes             # <<<<<<<<<<<<<<
 *     else:
 *         return s.decode('ascii', 'strict')
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_py_string_bytes);
    __pyx_r = __pyx_v_py_string_bytes;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":83
 * cdef object tounicode(char* s):
 *     cdef bytes py_string_bytes
 *     if (PY_MAJOR_VERSION < 3):             # <<<<<<<<<<<<<<
 *         py_string_bytes=s
 *         return py_string_bytes
 */
  }

  /* "pyclp/pyclp.pyx":87
 *         return py_string_bytes
 *     else:
 *         return s.decode('ascii', 'strict')             # <<<<<<<<<<<<<<
 * 
 * cdef object tounicode_with_length(
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_s, 0, strlen(__pyx_v_s), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 87, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "pyclp/pyclp.pyx":81
 *         return self.msg
 * 
 * cdef object tounicode(char* s):             # <<<<<<<<<<<<<<
 *     cdef bytes py_string_bytes
 *     if (PY_MAJOR_VERSION < 3):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pyclp.pyclp.tounicode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_py_string_bytes);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":89
 *         return s.decode('ascii', 'strict')
 * 
 * cdef object tounicode_with_length(             # <<<<<<<<<<<<<<
 *         char* s, size_t length):
 *     if (PY_MAJOR_VERSION < 3):
 */

static PyObject *__pyx_f_5pyclp_5pyclp_tounicode_with_length(char *__pyx_v_s, size_t __pyx_v_length) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("tounicode_with_length", 0);

  /* "pyclp/pyclp.pyx":91
 * cdef object tounicode_with_length(
 *         char* s, size_t length):
 *     if (PY_MAJOR_VERSION < 3):             # <<<<<<<<<<<<<<
 *         return s[:length]
 *     else:
 */
  __pyx_t_1 = ((PY_MAJOR_VERSION < 3) != 0);
  if (__pyx_t_1) {

    /* "pyclp/pyclp.pyx":92
 *         char* s, size_t length):
 *     if (PY_MAJOR_VERSION < 3):
 *         return s[:length]             # <<<<<<<<<<<<<<
 *     else:
 *         return s[:length].decode('ascii', 'strict')
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_s + 0, __pyx_v_length - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 92, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":91
 * cdef object tounicode_with_length(
 *         char* s, size_t length):
 *     if (PY_MAJOR_VERSION < 3):             # <<<<<<<<<<<<<<
 *         return s[:length]
 *     else:
 */
  }

  /* "pyclp/pyclp.pyx":94
 *         return s[:length]
 *     else:
 *         return s[:length].decode('ascii', 'strict')             # <<<<<<<<<<<<<<
 * 
 * #===============================================================================
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_s, 0, __pyx_v_length, NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 94, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "pyclp/pyclp.pyx":89
 *         return s.decode('ascii', 'strict')
 * 
 * cdef object tounicode_with_length(             # <<<<<<<<<<<<<<
 *         char* s, size_t length):
 *     if (PY_MAJOR_VERSION < 3):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pyclp.pyclp.tounicode_with_length", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":105
 * #===============================================================================
 * 
 * cdef bytes tobytes(object string):             # <<<<<<<<<<<<<<
 *     if isinstance(string,unicode):
 *         return string.encode('ascii')
 */

static PyObject *__pyx_f_5pyclp_5pyclp_tobytes(PyObject *__pyx_v_string) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("tobytes", 0);

  /* "pyclp/pyclp.pyx":106
 * 
 * cdef bytes tobytes(object string):
 *     if isinstance(string,unicode):             # <<<<<<<<<<<<<<
 *         return string.encode('ascii')
 *     elif isinstance(string,str):
 */
  __pyx_t_1 = PyUnicode_Check(__pyx_v_string); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":107
 * cdef bytes tobytes(object string):
 *     if isinstance(string,unicode):
 *         return string.encode('ascii')             # <<<<<<<<<<<<<<
 *     elif isinstance(string,str):
 *         return string
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_string, __pyx_n_s_encode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 107, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_n_s_ascii) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_n_s_ascii);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 107, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (!(likely(PyBytes_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_3)->tp_name), 0))) __PYX_ERR(0, 107, __pyx_L1_error)
    __pyx_r = ((PyObject*)__pyx_t_3);
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":106
 * 
 * cdef bytes tobytes(object string):
 *     if isinstance(string,unicode):             # <<<<<<<<<<<<<<
 *         return string.encode('ascii')
 *     elif isinstance(string,str):
 */
  }

  /* "pyclp/pyclp.pyx":108
 *     if isinstance(string,unicode):
 *         return string.encode('ascii')
 *     elif isinstance(string,str):             # <<<<<<<<<<<<<<
 *         return string
 *     else:
 */
  __pyx_t_2 = PyString_Check(__pyx_v_string); 
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (likely(__pyx_t_1)) {

    /* "pyclp/pyclp.pyx":109
 *         return string.encode('ascii')
 *     elif isinstance(string,str):
 *         return string             # <<<<<<<<<<<<<<
 *     else:
 *         raise ValueError("requires text input, got %s" % type(string))
 */
    __Pyx_XDECREF(__pyx_r);
    if (!(likely(PyBytes_CheckExact(__pyx_v_string))||((__pyx_v_string) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_string)->tp_name), 0))) __PYX_ERR(0, 109, __pyx_L1_error)
    __Pyx_INCREF(__pyx_v_string);
    __pyx_r = ((PyObject*)__pyx_v_string);
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":108
 *     if isinstance(string,unicode):
 *         return string.encode('ascii')
 *     elif isinstance(string,str):             # <<<<<<<<<<<<<<
 *         return string
 *     else:
 */
  }

  /* "pyclp/pyclp.pyx":111
 *         return string
 *     else:
 *         raise ValueError("requires text input, got %s" % type(string))             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_requires_text_input_got_s, ((PyObject *)Py_TYPE(__pyx_v_string))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 111, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 111, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 111, __pyx_L1_error)
  }

  /* "pyclp/pyclp.pyx":105
 * #===============================================================================
 * 
 * cdef bytes tobytes(object string):             # <<<<<<<<<<<<<<
 *     if isinstance(string,unicode):
 *         return string.encode('ascii')
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pyclp.pyclp.tobytes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":116
 * 
 * #Execute a predicate defined in python
 * cdef public int call_python() with gil :             # <<<<<<<<<<<<<<
 *     """
 *     This is called from ECLiPSe
 */

int call_python(void) {
  pword __pyx_v_python_error_pword;
  int __pyx_v_post_event_result;
  PyObject *__pyx_v_predicate = NULL;
  PyObject *__pyx_v_arguments = NULL;
  PyObject *__pyx_v_pred_string = NULL;
  PyObject *__pyx_v_python_function = NULL;
  PyObject *__pyx_v_result = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  #ifdef WITH_THREAD
  PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
  #endif
  __Pyx_RefNannySetupContext("call_python", 0);

  /* "pyclp/pyclp.pyx":125
 *     cdef pyclp.pword  python_error_pword
 *     cdef int post_event_result
 *     pyPredicatesException=None             # <<<<<<<<<<<<<<
 *     try:
 *         predicate=pword2object(ec_arg(1))
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyPredicatesException, Py_None) < 0) __PYX_ERR(0, 125, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":126
 *     cdef int post_event_result
 *     pyPredicatesException=None
 *     try:             # <<<<<<<<<<<<<<
 *         predicate=pword2object(ec_arg(1))
 *         arguments=pword2object(ec_arg(2))
 */
  {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
    __Pyx_XGOTREF(__pyx_t_1);
    __Pyx_XGOTREF(__pyx_t_2);
    __Pyx_XGOTREF(__pyx_t_3);
    /*try:*/ {

      /* "pyclp/pyclp.pyx":127
 *     pyPredicatesException=None
 *     try:
 *         predicate=pword2object(ec_arg(1))             # <<<<<<<<<<<<<<
 *         arguments=pword2object(ec_arg(2))
 *         pred_string=predicate.__str__()
 */
      __pyx_t_4 = __pyx_f_5pyclp_5pyclp_pword2object(ec_arg(1)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 127, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_v_predicate = __pyx_t_4;
      __pyx_t_4 = 0;

      /* "pyclp/pyclp.pyx":128
 *     try:
 *         predicate=pword2object(ec_arg(1))
 *         arguments=pword2object(ec_arg(2))             # <<<<<<<<<<<<<<
 *         pred_string=predicate.__str__()
 *         python_function=python_pred2func[pred_string]
 */
      __pyx_t_4 = __pyx_f_5pyclp_5pyclp_pword2object(ec_arg(2)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 128, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_v_arguments = __pyx_t_4;
      __pyx_t_4 = 0;

      /* "pyclp/pyclp.pyx":129
 *         predicate=pword2object(ec_arg(1))
 *         arguments=pword2object(ec_arg(2))
 *         pred_string=predicate.__str__()             # <<<<<<<<<<<<<<
 *         python_function=python_pred2func[pred_string]
 *         #Execute python function
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_predicate, __pyx_n_s_str); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 129, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_6 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_6)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_6);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 129, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_v_pred_string = __pyx_t_4;
      __pyx_t_4 = 0;

      /* "pyclp/pyclp.pyx":130
 *         arguments=pword2object(ec_arg(2))
 *         pred_string=predicate.__str__()
 *         python_function=python_pred2func[pred_string]             # <<<<<<<<<<<<<<
 *         #Execute python function
 *         result=python_function(arguments)
 */
      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_python_pred2func); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 130, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_t_4, __pyx_v_pred_string); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 130, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_python_function = __pyx_t_5;
      __pyx_t_5 = 0;

      /* "pyclp/pyclp.pyx":132
 *         python_function=python_pred2func[pred_string]
 *         #Execute python function
 *         result=python_function(arguments)             # <<<<<<<<<<<<<<
 *     # Python exception send a specific event 'python_error' that can be
 *     # handled and eventually masked in eclipse. If not catched the event trigger a
 */
      __Pyx_INCREF(__pyx_v_python_function);
      __pyx_t_4 = __pyx_v_python_function; __pyx_t_6 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_6)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_6);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
        }
      }
      __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_6, __pyx_v_arguments) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_arguments);
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 132, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_result = __pyx_t_5;
      __pyx_t_5 = 0;

      /* "pyclp/pyclp.pyx":126
 *     cdef int post_event_result
 *     pyPredicatesException=None
 *     try:             # <<<<<<<<<<<<<<
 *         predicate=pword2object(ec_arg(1))
 *         arguments=pword2object(ec_arg(2))
 */
    }
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L8_try_end;
    __pyx_L3_error:;
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "pyclp/pyclp.pyx":136
 *     # handled and eventually masked in eclipse. If not catched the event trigger a
 *     # raise of same exception (it is stored in global pyPredicatesException)
 *     except Exception as pyPredicatesException:             # <<<<<<<<<<<<<<
 *         python_error_pword=pyclp.ec_atom(pyclp.ec_did("python_error_event",0))
 *         post_event_result=ec_post_event(python_error_pword)
 */
    __pyx_t_7 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
    if (__pyx_t_7) {
      __Pyx_AddTraceback("pyclp.pyclp.call_python", __pyx_clineno, __pyx_lineno, __pyx_filename);
      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_4, &__pyx_t_6) < 0) __PYX_ERR(0, 136, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GOTREF(__pyx_t_6);
      if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyPredicatesException, __pyx_t_4) < 0) __PYX_ERR(0, 136, __pyx_L5_except_error)

      /* "pyclp/pyclp.pyx":137
 *     # raise of same exception (it is stored in global pyPredicatesException)
 *     except Exception as pyPredicatesException:
 *         python_error_pword=pyclp.ec_atom(pyclp.ec_did("python_error_event",0))             # <<<<<<<<<<<<<<
 *         post_event_result=ec_post_event(python_error_pword)
 *         # if posting event is failing I raise regular external error event.
 */
      __pyx_v_python_error_pword = ec_atom(ec_did(((char *)"python_error_event"), 0));

      /* "pyclp/pyclp.pyx":138
 *     except Exception as pyPredicatesException:
 *         python_error_pword=pyclp.ec_atom(pyclp.ec_did("python_error_event",0))
 *         post_event_result=ec_post_event(python_error_pword)             # <<<<<<<<<<<<<<
 *         # if posting event is failing I raise regular external error event.
 *         if post_event_result != pyclp.PSUCCEED:
 */
      __pyx_v_post_event_result = ec_post_event(__pyx_v_python_error_pword);

      /* "pyclp/pyclp.pyx":140
 *         post_event_result=ec_post_event(python_error_pword)
 *         # if posting event is failing I raise regular external error event.
 *         if post_event_result != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             # Error codes are negative numbers in C code.
 *             # Note that in Prolog the positive counterparts are used!
 */
      __pyx_t_8 = ((__pyx_v_post_event_result != PSUCCEED) != 0);
      if (__pyx_t_8) {

        /* "pyclp/pyclp.pyx":144
 *             # Note that in Prolog the positive counterparts are used!
 *             # In -213 "error in external predicate"
 *             return pyclp.EC_EXTERNAL_ERROR             # <<<<<<<<<<<<<<
 *         else:
 *             return FAIL
 */
        __pyx_r = EC_EXTERNAL_ERROR;
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        goto __pyx_L6_except_return;

        /* "pyclp/pyclp.pyx":140
 *         post_event_result=ec_post_event(python_error_pword)
 *         # if posting event is failing I raise regular external error event.
 *         if post_event_result != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             # Error codes are negative numbers in C code.
 *             # Note that in Prolog the positive counterparts are used!
 */
      }

      /* "pyclp/pyclp.pyx":146
 *             return pyclp.EC_EXTERNAL_ERROR
 *         else:
 *             return FAIL             # <<<<<<<<<<<<<<
 *     if result==SUCCEED:
 *         return pyclp.PSUCCEED
 */
      /*else*/ {
        __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_FAIL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 146, __pyx_L5_except_error)
        __Pyx_GOTREF(__pyx_t_9);
        __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_t_9); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 146, __pyx_L5_except_error)
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __pyx_r = __pyx_t_7;
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        goto __pyx_L6_except_return;
      }
    }
    goto __pyx_L5_except_error;
    __pyx_L5_except_error:;

    /* "pyclp/pyclp.pyx":126
 *     cdef int post_event_result
 *     pyPredicatesException=None
 *     try:             # <<<<<<<<<<<<<<
 *         predicate=pword2object(ec_arg(1))
 *         arguments=pword2object(ec_arg(2))
 */
    __Pyx_XGIVEREF(__pyx_t_1);
    __Pyx_XGIVEREF(__pyx_t_2);
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
    goto __pyx_L1_error;
    __pyx_L6_except_return:;
    __Pyx_XGIVEREF(__pyx_t_1);
    __Pyx_XGIVEREF(__pyx_t_2);
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
    goto __pyx_L0;
    __pyx_L8_try_end:;
  }

  /* "pyclp/pyclp.pyx":147
 *         else:
 *             return FAIL
 *     if result==SUCCEED:             # <<<<<<<<<<<<<<
 *         return pyclp.PSUCCEED
 *     else:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_SUCCEED); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 147, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_4 = PyObject_RichCompare(__pyx_v_result, __pyx_t_6, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 147, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 147, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_8) {

    /* "pyclp/pyclp.pyx":148
 *             return FAIL
 *     if result==SUCCEED:
 *         return pyclp.PSUCCEED             # <<<<<<<<<<<<<<
 *     else:
 *         return pyclp.PFAIL
 */
    __pyx_r = PSUCCEED;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":147
 *         else:
 *             return FAIL
 *     if result==SUCCEED:             # <<<<<<<<<<<<<<
 *         return pyclp.PSUCCEED
 *     else:
 */
  }

  /* "pyclp/pyclp.pyx":150
 *         return pyclp.PSUCCEED
 *     else:
 *         return pyclp.PFAIL             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __pyx_r = PFAIL;
    goto __pyx_L0;
  }

  /* "pyclp/pyclp.pyx":116
 * 
 * #Execute a predicate defined in python
 * cdef public int call_python() with gil :             # <<<<<<<<<<<<<<
 *     """
 *     This is called from ECLiPSe
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_WriteUnraisable("pyclp.pyclp.call_python", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_predicate);
  __Pyx_XDECREF(__pyx_v_arguments);
  __Pyx_XDECREF(__pyx_v_pred_string);
  __Pyx_XDECREF(__pyx_v_python_function);
  __Pyx_XDECREF(__pyx_v_result);
  __Pyx_RefNannyFinishContext();
  #ifdef WITH_THREAD
  __Pyx_PyGILState_Release(__pyx_gilstate_save);
  #endif
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":153
 * 
 * 
 * cdef int register_call_python_pred():             # <<<<<<<<<<<<<<
 *     """
 *     Register call_python_function to eclipse engine.
 */

static int __pyx_f_5pyclp_5pyclp_register_call_python_pred(void) {
  dident __pyx_v_module_name_dict;
  int __pyx_v_result;
  PyObject *__pyx_v_event_handler_compile_string = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  char *__pyx_t_2;
  int __pyx_t_3;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("register_call_python_pred", 0);

  /* "pyclp/pyclp.pyx":159
 *     cdef dident module_name_dict
 *     cdef int result
 *     module_name_dict=ec_did('pyclp',0)             # <<<<<<<<<<<<<<
 *     # Register predicate to call external function implemented in python.
 *     #event_handler_compile_string="compile_term([python_error_event_handler(_):- exit_block(python_error)),:-  set_event_handler(python_error,python_error_event_handler) ]"
 */
  __pyx_v_module_name_dict = ec_did(((char *)"pyclp"), 0);

  /* "pyclp/pyclp.pyx":162
 *     # Register predicate to call external function implemented in python.
 *     #event_handler_compile_string="compile_term([python_error_event_handler(_):- exit_block(python_error)),:-  set_event_handler(python_error,python_error_event_handler) ]"
 *     event_handler_compile_string=tobytes("create_module(pyclp,[call_python_function/2],[eclipse_language]),compile_term([python_error_event_handler(_):- exit_block(python_error),:-  set_event_handler(python_error_event,python_error_event_handler/1) ])@pyclp,use_module(pyclp)")             # <<<<<<<<<<<<<<
 *     ec_post_string(event_handler_compile_string)
 *     result=pyclp.ec_resume()
 */
  __pyx_t_1 = __pyx_f_5pyclp_5pyclp_tobytes(__pyx_kp_s_create_module_pyclp_call_python); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 162, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_event_handler_compile_string = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":163
 *     #event_handler_compile_string="compile_term([python_error_event_handler(_):- exit_block(python_error)),:-  set_event_handler(python_error,python_error_event_handler) ]"
 *     event_handler_compile_string=tobytes("create_module(pyclp,[call_python_function/2],[eclipse_language]),compile_term([python_error_event_handler(_):- exit_block(python_error),:-  set_event_handler(python_error_event,python_error_event_handler/1) ])@pyclp,use_module(pyclp)")
 *     ec_post_string(event_handler_compile_string)             # <<<<<<<<<<<<<<
 *     result=pyclp.ec_resume()
 *     if pyclp.PSUCCEED != result:
 */
  if (unlikely(__pyx_v_event_handler_compile_string == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
    __PYX_ERR(0, 163, __pyx_L1_error)
  }
  __pyx_t_2 = __Pyx_PyBytes_AsWritableString(__pyx_v_event_handler_compile_string); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(0, 163, __pyx_L1_error)
  ec_post_string(__pyx_t_2);

  /* "pyclp/pyclp.pyx":164
 *     event_handler_compile_string=tobytes("create_module(pyclp,[call_python_function/2],[eclipse_language]),compile_term([python_error_event_handler(_):- exit_block(python_error),:-  set_event_handler(python_error_event,python_error_event_handler/1) ])@pyclp,use_module(pyclp)")
 *     ec_post_string(event_handler_compile_string)
 *     result=pyclp.ec_resume()             # <<<<<<<<<<<<<<
 *     if pyclp.PSUCCEED != result:
 *         return result
 */
  __pyx_v_result = ec_resume();

  /* "pyclp/pyclp.pyx":165
 *     ec_post_string(event_handler_compile_string)
 *     result=pyclp.ec_resume()
 *     if pyclp.PSUCCEED != result:             # <<<<<<<<<<<<<<
 *         return result
 *     else:
 */
  __pyx_t_3 = ((PSUCCEED != __pyx_v_result) != 0);
  if (__pyx_t_3) {

    /* "pyclp/pyclp.pyx":166
 *     result=pyclp.ec_resume()
 *     if pyclp.PSUCCEED != result:
 *         return result             # <<<<<<<<<<<<<<
 *     else:
 *         return pyclp.ec_external(pyclp.ec_did("call_python_function",2), call_python, module_name_dict)
 */
    __pyx_r = __pyx_v_result;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":165
 *     ec_post_string(event_handler_compile_string)
 *     result=pyclp.ec_resume()
 *     if pyclp.PSUCCEED != result:             # <<<<<<<<<<<<<<
 *         return result
 *     else:
 */
  }

  /* "pyclp/pyclp.pyx":168
 *         return result
 *     else:
 *         return pyclp.ec_external(pyclp.ec_did("call_python_function",2), call_python, module_name_dict)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __pyx_r = ec_external(ec_did(((char *)"call_python_function"), 2), call_python, __pyx_v_module_name_dict);
    goto __pyx_L0;
  }

  /* "pyclp/pyclp.pyx":153
 * 
 * 
 * cdef int register_call_python_pred():             # <<<<<<<<<<<<<<
 *     """
 *     Register call_python_function to eclipse engine.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_WriteUnraisable("pyclp.pyclp.register_call_python_pred", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_event_handler_compile_string);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":172
 * 
 * 
 * cpdef formatTermStr(element):             # <<<<<<<<<<<<<<
 *     """Just used to generate the string if terms.
 *     string terms shall be enclosed in double quotes as in ECLiPSe
 */

static PyObject *__pyx_pw_5pyclp_5pyclp_1formatTermStr(PyObject *__pyx_self, PyObject *__pyx_v_element); /*proto*/
static PyObject *__pyx_f_5pyclp_5pyclp_formatTermStr(PyObject *__pyx_v_element, CYTHON_UNUSED int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("formatTermStr", 0);

  /* "pyclp/pyclp.pyx":176
 *     string terms shall be enclosed in double quotes as in ECLiPSe
 *     """
 *     if isinstance(element,str):             # <<<<<<<<<<<<<<
 *         return "".join(['"',element,'"'])
 *     else:
 */
  __pyx_t_1 = PyString_Check(__pyx_v_element); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":177
 *     """
 *     if isinstance(element,str):
 *         return "".join(['"',element,'"'])             # <<<<<<<<<<<<<<
 *     else:
 *         return element.__str__()
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = PyList_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 177, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_kp_s__2);
    __Pyx_GIVEREF(__pyx_kp_s__2);
    PyList_SET_ITEM(__pyx_t_3, 0, __pyx_kp_s__2);
    __Pyx_INCREF(__pyx_v_element);
    __Pyx_GIVEREF(__pyx_v_element);
    PyList_SET_ITEM(__pyx_t_3, 1, __pyx_v_element);
    __Pyx_INCREF(__pyx_kp_s__2);
    __Pyx_GIVEREF(__pyx_kp_s__2);
    PyList_SET_ITEM(__pyx_t_3, 2, __pyx_kp_s__2);
    __pyx_t_4 = __Pyx_PyString_Join(__pyx_kp_s_, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 177, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":176
 *     string terms shall be enclosed in double quotes as in ECLiPSe
 *     """
 *     if isinstance(element,str):             # <<<<<<<<<<<<<<
 *         return "".join(['"',element,'"'])
 *     else:
 */
  }

  /* "pyclp/pyclp.pyx":179
 *         return "".join(['"',element,'"'])
 *     else:
 *         return element.__str__()             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_element, __pyx_n_s_str); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 179, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 179, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;
  }

  /* "pyclp/pyclp.pyx":172
 * 
 * 
 * cpdef formatTermStr(element):             # <<<<<<<<<<<<<<
 *     """Just used to generate the string if terms.
 *     string terms shall be enclosed in double quotes as in ECLiPSe
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pyclp.pyclp.formatTermStr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_1formatTermStr(PyObject *__pyx_self, PyObject *__pyx_v_element); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_formatTermStr[] = "Just used to generate the string if terms.\n    string terms shall be enclosed in double quotes as in ECLiPSe\n    ";
static PyObject *__pyx_pw_5pyclp_5pyclp_1formatTermStr(PyObject *__pyx_self, PyObject *__pyx_v_element) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("formatTermStr (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_formatTermStr(__pyx_self, ((PyObject *)__pyx_v_element));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_formatTermStr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_element) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("formatTermStr", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_5pyclp_5pyclp_formatTermStr(__pyx_v_element, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 172, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.formatTermStr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":185
 *     cdef pyclp.ec_ref ref
 *     cdef object __weakref__
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self.ref=pyclp.ec_ref_create_newvar()
 *     def cinit(self):
 */

/* Python wrapper */
static int __pyx_pw_5pyclp_5pyclp_3Ref_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pyclp_5pyclp_3Ref_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_3Ref___cinit__(((struct __pyx_obj_5pyclp_5pyclp_Ref *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pyclp_5pyclp_3Ref___cinit__(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "pyclp/pyclp.pyx":186
 *     cdef object __weakref__
 *     def __cinit__(self):
 *         self.ref=pyclp.ec_ref_create_newvar()             # <<<<<<<<<<<<<<
 *     def cinit(self):
 *         self.ref=pyclp.ec_ref_create_newvar()
 */
  __pyx_v_self->ref = ec_ref_create_newvar();

  /* "pyclp/pyclp.pyx":185
 *     cdef pyclp.ec_ref ref
 *     cdef object __weakref__
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self.ref=pyclp.ec_ref_create_newvar()
 *     def cinit(self):
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":187
 *     def __cinit__(self):
 *         self.ref=pyclp.ec_ref_create_newvar()
 *     def cinit(self):             # <<<<<<<<<<<<<<
 *         self.ref=pyclp.ec_ref_create_newvar()
 *     def __init__(self):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_3Ref_3cinit(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_3Ref_3cinit(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cinit (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_3Ref_2cinit(((struct __pyx_obj_5pyclp_5pyclp_Ref *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_3Ref_2cinit(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cinit", 0);

  /* "pyclp/pyclp.pyx":188
 *         self.ref=pyclp.ec_ref_create_newvar()
 *     def cinit(self):
 *         self.ref=pyclp.ec_ref_create_newvar()             # <<<<<<<<<<<<<<
 *     def __init__(self):
 *         all_active_refs.add(self)
 */
  __pyx_v_self->ref = ec_ref_create_newvar();

  /* "pyclp/pyclp.pyx":187
 *     def __cinit__(self):
 *         self.ref=pyclp.ec_ref_create_newvar()
 *     def cinit(self):             # <<<<<<<<<<<<<<
 *         self.ref=pyclp.ec_ref_create_newvar()
 *     def __init__(self):
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":189
 *     def cinit(self):
 *         self.ref=pyclp.ec_ref_create_newvar()
 *     def __init__(self):             # <<<<<<<<<<<<<<
 *         all_active_refs.add(self)
 *     def __dealloc__(self):
 */

/* Python wrapper */
static int __pyx_pw_5pyclp_5pyclp_3Ref_5__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pyclp_5pyclp_3Ref_5__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__init__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__init__", 0))) return -1;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_3Ref_4__init__(((struct __pyx_obj_5pyclp_5pyclp_Ref *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pyclp_5pyclp_3Ref_4__init__(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "pyclp/pyclp.pyx":190
 *         self.ref=pyclp.ec_ref_create_newvar()
 *     def __init__(self):
 *         all_active_refs.add(self)             # <<<<<<<<<<<<<<
 *     def __dealloc__(self):
 *         if self.ref != NULL:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_all_active_refs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_add); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, ((PyObject *)__pyx_v_self)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_self));
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":189
 *     def cinit(self):
 *         self.ref=pyclp.ec_ref_create_newvar()
 *     def __init__(self):             # <<<<<<<<<<<<<<
 *         all_active_refs.add(self)
 *     def __dealloc__(self):
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pyclp.pyclp.Ref.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":191
 *     def __init__(self):
 *         all_active_refs.add(self)
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self.ref != NULL:
 *             pyclp.ec_ref_destroy(self.ref)
 */

/* Python wrapper */
static void __pyx_pw_5pyclp_5pyclp_3Ref_7__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_5pyclp_5pyclp_3Ref_7__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_5pyclp_5pyclp_3Ref_6__dealloc__(((struct __pyx_obj_5pyclp_5pyclp_Ref *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_5pyclp_5pyclp_3Ref_6__dealloc__(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "pyclp/pyclp.pyx":192
 *         all_active_refs.add(self)
 *     def __dealloc__(self):
 *         if self.ref != NULL:             # <<<<<<<<<<<<<<
 *             pyclp.ec_ref_destroy(self.ref)
 *             self.ref=NULL
 */
  __pyx_t_1 = ((__pyx_v_self->ref != NULL) != 0);
  if (__pyx_t_1) {

    /* "pyclp/pyclp.pyx":193
 *     def __dealloc__(self):
 *         if self.ref != NULL:
 *             pyclp.ec_ref_destroy(self.ref)             # <<<<<<<<<<<<<<
 *             self.ref=NULL
 *     def dealloc(self):
 */
    ec_ref_destroy(__pyx_v_self->ref);

    /* "pyclp/pyclp.pyx":194
 *         if self.ref != NULL:
 *             pyclp.ec_ref_destroy(self.ref)
 *             self.ref=NULL             # <<<<<<<<<<<<<<
 *     def dealloc(self):
 *         if self.ref != NULL:
 */
    __pyx_v_self->ref = NULL;

    /* "pyclp/pyclp.pyx":192
 *         all_active_refs.add(self)
 *     def __dealloc__(self):
 *         if self.ref != NULL:             # <<<<<<<<<<<<<<
 *             pyclp.ec_ref_destroy(self.ref)
 *             self.ref=NULL
 */
  }

  /* "pyclp/pyclp.pyx":191
 *     def __init__(self):
 *         all_active_refs.add(self)
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self.ref != NULL:
 *             pyclp.ec_ref_destroy(self.ref)
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "pyclp/pyclp.pyx":195
 *             pyclp.ec_ref_destroy(self.ref)
 *             self.ref=NULL
 *     def dealloc(self):             # <<<<<<<<<<<<<<
 *         if self.ref != NULL:
 *             pyclp.ec_ref_destroy(self.ref)
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_3Ref_9dealloc(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_3Ref_9dealloc(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("dealloc (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_3Ref_8dealloc(((struct __pyx_obj_5pyclp_5pyclp_Ref *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_3Ref_8dealloc(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("dealloc", 0);

  /* "pyclp/pyclp.pyx":196
 *             self.ref=NULL
 *     def dealloc(self):
 *         if self.ref != NULL:             # <<<<<<<<<<<<<<
 *             pyclp.ec_ref_destroy(self.ref)
 *             self.ref=NULL
 */
  __pyx_t_1 = ((__pyx_v_self->ref != NULL) != 0);
  if (__pyx_t_1) {

    /* "pyclp/pyclp.pyx":197
 *     def dealloc(self):
 *         if self.ref != NULL:
 *             pyclp.ec_ref_destroy(self.ref)             # <<<<<<<<<<<<<<
 *             self.ref=NULL
 *     cdef pyclp.pword get(self):
 */
    ec_ref_destroy(__pyx_v_self->ref);

    /* "pyclp/pyclp.pyx":198
 *         if self.ref != NULL:
 *             pyclp.ec_ref_destroy(self.ref)
 *             self.ref=NULL             # <<<<<<<<<<<<<<
 *     cdef pyclp.pword get(self):
 *         return pyclp.ec_ref_get(self.ref)
 */
    __pyx_v_self->ref = NULL;

    /* "pyclp/pyclp.pyx":196
 *             self.ref=NULL
 *     def dealloc(self):
 *         if self.ref != NULL:             # <<<<<<<<<<<<<<
 *             pyclp.ec_ref_destroy(self.ref)
 *             self.ref=NULL
 */
  }

  /* "pyclp/pyclp.pyx":195
 *             pyclp.ec_ref_destroy(self.ref)
 *             self.ref=NULL
 *     def dealloc(self):             # <<<<<<<<<<<<<<
 *         if self.ref != NULL:
 *             pyclp.ec_ref_destroy(self.ref)
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":199
 *             pyclp.ec_ref_destroy(self.ref)
 *             self.ref=NULL
 *     cdef pyclp.pword get(self):             # <<<<<<<<<<<<<<
 *         return pyclp.ec_ref_get(self.ref)
 *     cdef void set(self,pyclp.pword pr_word):
 */

static pword __pyx_f_5pyclp_5pyclp_3Ref_get(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self) {
  pword __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get", 0);

  /* "pyclp/pyclp.pyx":200
 *             self.ref=NULL
 *     cdef pyclp.pword get(self):
 *         return pyclp.ec_ref_get(self.ref)             # <<<<<<<<<<<<<<
 *     cdef void set(self,pyclp.pword pr_word):
 *         pyclp.ec_ref_set(self.ref,pr_word)
 */
  __pyx_r = ec_ref_get(__pyx_v_self->ref);
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":199
 *             pyclp.ec_ref_destroy(self.ref)
 *             self.ref=NULL
 *     cdef pyclp.pword get(self):             # <<<<<<<<<<<<<<
 *         return pyclp.ec_ref_get(self.ref)
 *     cdef void set(self,pyclp.pword pr_word):
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":201
 *     cdef pyclp.pword get(self):
 *         return pyclp.ec_ref_get(self.ref)
 *     cdef void set(self,pyclp.pword pr_word):             # <<<<<<<<<<<<<<
 *         pyclp.ec_ref_set(self.ref,pr_word)
 * 
 */

static void __pyx_f_5pyclp_5pyclp_3Ref_set(struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self, pword __pyx_v_pr_word) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set", 0);

  /* "pyclp/pyclp.pyx":202
 *         return pyclp.ec_ref_get(self.ref)
 *     cdef void set(self,pyclp.pword pr_word):
 *         pyclp.ec_ref_set(self.ref,pr_word)             # <<<<<<<<<<<<<<
 * 
 * class Stream(io.RawIOBase):
 */
  ec_ref_set(__pyx_v_self->ref, __pyx_v_pr_word);

  /* "pyclp/pyclp.pyx":201
 *     cdef pyclp.pword get(self):
 *         return pyclp.ec_ref_get(self.ref)
 *     cdef void set(self,pyclp.pword pr_word):             # <<<<<<<<<<<<<<
 *         pyclp.ec_ref_set(self.ref,pr_word)
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_3Ref_11__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_3Ref_11__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_3Ref_10__reduce_cython__(((struct __pyx_obj_5pyclp_5pyclp_Ref *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_3Ref_10__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Ref.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_3Ref_13__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_3Ref_13__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_3Ref_12__setstate_cython__(((struct __pyx_obj_5pyclp_5pyclp_Ref *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_3Ref_12__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Ref *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Ref.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":224
 * 
 *     """
 *     def __init__(self,name):             # <<<<<<<<<<<<<<
 *         if isinstance(name,str):
 *             self.name=name
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_6Stream_1__init__ = {"__init__", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyclp_5pyclp_6Stream_1__init__, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_name = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_name,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); __PYX_ERR(0, 224, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 224, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_name = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 224, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.Stream.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_6Stream___init__(__pyx_self, __pyx_v_self, __pyx_v_name);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_name) {
  PyObject *__pyx_v_encoded_name = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  char *__pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "pyclp/pyclp.pyx":225
 *     """
 *     def __init__(self,name):
 *         if isinstance(name,str):             # <<<<<<<<<<<<<<
 *             self.name=name
 *             encoded_name=tobytes(name)
 */
  __pyx_t_1 = PyString_Check(__pyx_v_name); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":226
 *     def __init__(self,name):
 *         if isinstance(name,str):
 *             self.name=name             # <<<<<<<<<<<<<<
 *             encoded_name=tobytes(name)
 *             self.stream_num=(pyclp.ec_stream_nr (<char *>encoded_name))
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_name, __pyx_v_name) < 0) __PYX_ERR(0, 226, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":227
 *         if isinstance(name,str):
 *             self.name=name
 *             encoded_name=tobytes(name)             # <<<<<<<<<<<<<<
 *             self.stream_num=(pyclp.ec_stream_nr (<char *>encoded_name))
 *             if self.stream_num < 0:
 */
    __pyx_t_3 = __pyx_f_5pyclp_5pyclp_tobytes(__pyx_v_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 227, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_encoded_name = ((PyObject*)__pyx_t_3);
    __pyx_t_3 = 0;

    /* "pyclp/pyclp.pyx":228
 *             self.name=name
 *             encoded_name=tobytes(name)
 *             self.stream_num=(pyclp.ec_stream_nr (<char *>encoded_name))             # <<<<<<<<<<<<<<
 *             if self.stream_num < 0:
 *                 raise IOError
 */
    if (unlikely(__pyx_v_encoded_name == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
      __PYX_ERR(0, 228, __pyx_L1_error)
    }
    __pyx_t_4 = __Pyx_PyBytes_AsWritableString(__pyx_v_encoded_name); if (unlikely((!__pyx_t_4) && PyErr_Occurred())) __PYX_ERR(0, 228, __pyx_L1_error)
    __pyx_t_3 = __Pyx_PyInt_From_int(ec_stream_nr(((char *)__pyx_t_4))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 228, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_stream_num, __pyx_t_3) < 0) __PYX_ERR(0, 228, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "pyclp/pyclp.pyx":229
 *             encoded_name=tobytes(name)
 *             self.stream_num=(pyclp.ec_stream_nr (<char *>encoded_name))
 *             if self.stream_num < 0:             # <<<<<<<<<<<<<<
 *                 raise IOError
 *         elif isinstance(name,int):
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_stream_num); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 229, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = PyObject_RichCompare(__pyx_t_3, __pyx_int_0, Py_LT); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 229, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 229, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(__pyx_t_2)) {

      /* "pyclp/pyclp.pyx":230
 *             self.stream_num=(pyclp.ec_stream_nr (<char *>encoded_name))
 *             if self.stream_num < 0:
 *                 raise IOError             # <<<<<<<<<<<<<<
 *         elif isinstance(name,int):
 *             self.stream_num=name
 */
      __Pyx_Raise(__pyx_builtin_IOError, 0, 0, 0);
      __PYX_ERR(0, 230, __pyx_L1_error)

      /* "pyclp/pyclp.pyx":229
 *             encoded_name=tobytes(name)
 *             self.stream_num=(pyclp.ec_stream_nr (<char *>encoded_name))
 *             if self.stream_num < 0:             # <<<<<<<<<<<<<<
 *                 raise IOError
 *         elif isinstance(name,int):
 */
    }

    /* "pyclp/pyclp.pyx":225
 *     """
 *     def __init__(self,name):
 *         if isinstance(name,str):             # <<<<<<<<<<<<<<
 *             self.name=name
 *             encoded_name=tobytes(name)
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":231
 *             if self.stream_num < 0:
 *                 raise IOError
 *         elif isinstance(name,int):             # <<<<<<<<<<<<<<
 *             self.stream_num=name
 *         else:
 */
  __pyx_t_2 = PyInt_Check(__pyx_v_name); 
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (likely(__pyx_t_1)) {

    /* "pyclp/pyclp.pyx":232
 *                 raise IOError
 *         elif isinstance(name,int):
 *             self.stream_num=name             # <<<<<<<<<<<<<<
 *         else:
 *             raise TypeError("name shall be a string or a integer")
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_stream_num, __pyx_v_name) < 0) __PYX_ERR(0, 232, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":231
 *             if self.stream_num < 0:
 *                 raise IOError
 *         elif isinstance(name,int):             # <<<<<<<<<<<<<<
 *             self.stream_num=name
 *         else:
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":234
 *             self.stream_num=name
 *         else:
 *             raise TypeError("name shall be a string or a integer")             # <<<<<<<<<<<<<<
 *     def seekable(self):
 *         return False
 */
  /*else*/ {
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 234, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 234, __pyx_L1_error)
  }
  __pyx_L3:;

  /* "pyclp/pyclp.pyx":224
 * 
 *     """
 *     def __init__(self,name):             # <<<<<<<<<<<<<<
 *         if isinstance(name,str):
 *             self.name=name
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pyclp.pyclp.Stream.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_encoded_name);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":235
 *         else:
 *             raise TypeError("name shall be a string or a integer")
 *     def seekable(self):             # <<<<<<<<<<<<<<
 *         return False
 *     def readable(self):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_3seekable(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_6Stream_3seekable = {"seekable", (PyCFunction)__pyx_pw_5pyclp_5pyclp_6Stream_3seekable, METH_O, 0};
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_3seekable(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("seekable (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_6Stream_2seekable(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_2seekable(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("seekable", 0);

  /* "pyclp/pyclp.pyx":236
 *             raise TypeError("name shall be a string or a integer")
 *     def seekable(self):
 *         return False             # <<<<<<<<<<<<<<
 *     def readable(self):
 *         return True
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_False);
  __pyx_r = Py_False;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":235
 *         else:
 *             raise TypeError("name shall be a string or a integer")
 *     def seekable(self):             # <<<<<<<<<<<<<<
 *         return False
 *     def readable(self):
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":237
 *     def seekable(self):
 *         return False
 *     def readable(self):             # <<<<<<<<<<<<<<
 *         return True
 *     def writeable(self):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_5readable(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_6Stream_5readable = {"readable", (PyCFunction)__pyx_pw_5pyclp_5pyclp_6Stream_5readable, METH_O, 0};
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_5readable(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("readable (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_6Stream_4readable(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_4readable(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("readable", 0);

  /* "pyclp/pyclp.pyx":238
 *         return False
 *     def readable(self):
 *         return True             # <<<<<<<<<<<<<<
 *     def writeable(self):
 *         return True
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_True);
  __pyx_r = Py_True;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":237
 *     def seekable(self):
 *         return False
 *     def readable(self):             # <<<<<<<<<<<<<<
 *         return True
 *     def writeable(self):
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":239
 *     def readable(self):
 *         return True
 *     def writeable(self):             # <<<<<<<<<<<<<<
 *         return True
 *     def fileno(self):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_7writeable(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_6Stream_7writeable = {"writeable", (PyCFunction)__pyx_pw_5pyclp_5pyclp_6Stream_7writeable, METH_O, 0};
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_7writeable(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("writeable (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_6Stream_6writeable(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_6writeable(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("writeable", 0);

  /* "pyclp/pyclp.pyx":240
 *         return True
 *     def writeable(self):
 *         return True             # <<<<<<<<<<<<<<
 *     def fileno(self):
 *         return self.stream_num
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_True);
  __pyx_r = Py_True;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":239
 *     def readable(self):
 *         return True
 *     def writeable(self):             # <<<<<<<<<<<<<<
 *         return True
 *     def fileno(self):
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":241
 *     def writeable(self):
 *         return True
 *     def fileno(self):             # <<<<<<<<<<<<<<
 *         return self.stream_num
 *     def isatty(self):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_9fileno(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_6Stream_9fileno = {"fileno", (PyCFunction)__pyx_pw_5pyclp_5pyclp_6Stream_9fileno, METH_O, 0};
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_9fileno(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fileno (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_6Stream_8fileno(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_8fileno(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("fileno", 0);

  /* "pyclp/pyclp.pyx":242
 *         return True
 *     def fileno(self):
 *         return self.stream_num             # <<<<<<<<<<<<<<
 *     def isatty(self):
 *         return False
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_stream_num); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 242, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":241
 *     def writeable(self):
 *         return True
 *     def fileno(self):             # <<<<<<<<<<<<<<
 *         return self.stream_num
 *     def isatty(self):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Stream.fileno", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":243
 *     def fileno(self):
 *         return self.stream_num
 *     def isatty(self):             # <<<<<<<<<<<<<<
 *         return False
 *     def truncate(self,size=None):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_11isatty(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_6Stream_11isatty = {"isatty", (PyCFunction)__pyx_pw_5pyclp_5pyclp_6Stream_11isatty, METH_O, 0};
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_11isatty(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isatty (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_6Stream_10isatty(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_10isatty(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isatty", 0);

  /* "pyclp/pyclp.pyx":244
 *         return self.stream_num
 *     def isatty(self):
 *         return False             # <<<<<<<<<<<<<<
 *     def truncate(self,size=None):
 *         raise IOError
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_False);
  __pyx_r = Py_False;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":243
 *     def fileno(self):
 *         return self.stream_num
 *     def isatty(self):             # <<<<<<<<<<<<<<
 *         return False
 *     def truncate(self,size=None):
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":245
 *     def isatty(self):
 *         return False
 *     def truncate(self,size=None):             # <<<<<<<<<<<<<<
 *         raise IOError
 *     def flush(self):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_13truncate(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_6Stream_13truncate = {"truncate", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyclp_5pyclp_6Stream_13truncate, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_13truncate(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_self = 0;
  CYTHON_UNUSED PyObject *__pyx_v_size = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("truncate (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_size,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)((PyObject *)Py_None));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_size);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "truncate") < 0)) __PYX_ERR(0, 245, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_size = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("truncate", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 245, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.Stream.truncate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_6Stream_12truncate(__pyx_self, __pyx_v_self, __pyx_v_size);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_12truncate(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_size) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("truncate", 0);

  /* "pyclp/pyclp.pyx":246
 *         return False
 *     def truncate(self,size=None):
 *         raise IOError             # <<<<<<<<<<<<<<
 *     def flush(self):
 *         """The semantic is different from usual Stream.
 */
  __Pyx_Raise(__pyx_builtin_IOError, 0, 0, 0);
  __PYX_ERR(0, 246, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":245
 *     def isatty(self):
 *         return False
 *     def truncate(self,size=None):             # <<<<<<<<<<<<<<
 *         raise IOError
 *     def flush(self):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyclp.pyclp.Stream.truncate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":247
 *     def truncate(self,size=None):
 *         raise IOError
 *     def flush(self):             # <<<<<<<<<<<<<<
 *         """The semantic is different from usual Stream.
 *         In this case it does nothing
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_15flush(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_6Stream_14flush[] = "The semantic is different from usual Stream.\n        In this case it does nothing\n        ";
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_6Stream_15flush = {"flush", (PyCFunction)__pyx_pw_5pyclp_5pyclp_6Stream_15flush, METH_O, __pyx_doc_5pyclp_5pyclp_6Stream_14flush};
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_15flush(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("flush (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_6Stream_14flush(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_14flush(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("flush", 0);

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":252
 *         """
 *         pass
 *     def read(self,int n=-1):             # <<<<<<<<<<<<<<
 *         """
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_17read(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_6Stream_16read[] = "\n        \n        Read all bytes from stream\n        \n        :param n: Number of bytes to be read if omitted or equal to -1 it will return all avaiable bytes.\n        :returns: bytes object\n        ";
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_6Stream_17read = {"read", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyclp_5pyclp_6Stream_17read, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyclp_5pyclp_6Stream_16read};
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_17read(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  int __pyx_v_n;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("read (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_n,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "read") < 0)) __PYX_ERR(0, 252, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    if (values[1]) {
      __pyx_v_n = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_n == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 252, __pyx_L3_error)
    } else {
      __pyx_v_n = ((int)((int)-1));
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("read", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 252, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.Stream.read", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_6Stream_16read(__pyx_self, __pyx_v_self, __pyx_v_n);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_16read(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, int __pyx_v_n) {
  char *__pyx_v_buffer;
  int __pyx_v_lenght;
  int __pyx_v_num_bytes_read;
  PyObject *__pyx_v_python_buffer = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("read", 0);

  /* "pyclp/pyclp.pyx":264
 *         cdef int num_bytes_read
 *         cdef bytes python_buffer
 *         lenght=ec_queue_avail(<int>self.stream_num)             # <<<<<<<<<<<<<<
 *         if n==0:
 *             return bytes(0)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_stream_num); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 264, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 264, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_lenght = ec_queue_avail(((int)__pyx_t_2));

  /* "pyclp/pyclp.pyx":265
 *         cdef bytes python_buffer
 *         lenght=ec_queue_avail(<int>self.stream_num)
 *         if n==0:             # <<<<<<<<<<<<<<
 *             return bytes(0)
 *         elif n > 0:
 */
  __pyx_t_3 = ((__pyx_v_n == 0) != 0);
  if (__pyx_t_3) {

    /* "pyclp/pyclp.pyx":266
 *         lenght=ec_queue_avail(<int>self.stream_num)
 *         if n==0:
 *             return bytes(0)             # <<<<<<<<<<<<<<
 *         elif n > 0:
 *             # Don't read more buffer than available.
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)(&PyBytes_Type)), __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 266, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":265
 *         cdef bytes python_buffer
 *         lenght=ec_queue_avail(<int>self.stream_num)
 *         if n==0:             # <<<<<<<<<<<<<<
 *             return bytes(0)
 *         elif n > 0:
 */
  }

  /* "pyclp/pyclp.pyx":267
 *         if n==0:
 *             return bytes(0)
 *         elif n > 0:             # <<<<<<<<<<<<<<
 *             # Don't read more buffer than available.
 *             if lenght > n:
 */
  __pyx_t_3 = ((__pyx_v_n > 0) != 0);
  if (__pyx_t_3) {

    /* "pyclp/pyclp.pyx":269
 *         elif n > 0:
 *             # Don't read more buffer than available.
 *             if lenght > n:             # <<<<<<<<<<<<<<
 *                 lenght=n
 *         buffer=<char*>libc.stdlib.calloc(lenght,1)
 */
    __pyx_t_3 = ((__pyx_v_lenght > __pyx_v_n) != 0);
    if (__pyx_t_3) {

      /* "pyclp/pyclp.pyx":270
 *             # Don't read more buffer than available.
 *             if lenght > n:
 *                 lenght=n             # <<<<<<<<<<<<<<
 *         buffer=<char*>libc.stdlib.calloc(lenght,1)
 *         num_bytes_read=pyclp.ec_queue_read(<int> self.stream_num,buffer,lenght)
 */
      __pyx_v_lenght = __pyx_v_n;

      /* "pyclp/pyclp.pyx":269
 *         elif n > 0:
 *             # Don't read more buffer than available.
 *             if lenght > n:             # <<<<<<<<<<<<<<
 *                 lenght=n
 *         buffer=<char*>libc.stdlib.calloc(lenght,1)
 */
    }

    /* "pyclp/pyclp.pyx":267
 *         if n==0:
 *             return bytes(0)
 *         elif n > 0:             # <<<<<<<<<<<<<<
 *             # Don't read more buffer than available.
 *             if lenght > n:
 */
  }

  /* "pyclp/pyclp.pyx":271
 *             if lenght > n:
 *                 lenght=n
 *         buffer=<char*>libc.stdlib.calloc(lenght,1)             # <<<<<<<<<<<<<<
 *         num_bytes_read=pyclp.ec_queue_read(<int> self.stream_num,buffer,lenght)
 *         if num_bytes_read < 0 :
 */
  __pyx_v_buffer = ((char *)calloc(__pyx_v_lenght, 1));

  /* "pyclp/pyclp.pyx":272
 *                 lenght=n
 *         buffer=<char*>libc.stdlib.calloc(lenght,1)
 *         num_bytes_read=pyclp.ec_queue_read(<int> self.stream_num,buffer,lenght)             # <<<<<<<<<<<<<<
 *         if num_bytes_read < 0 :
 *             raise IOError(n)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_stream_num); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 272, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 272, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_num_bytes_read = ec_queue_read(((int)__pyx_t_2), __pyx_v_buffer, __pyx_v_lenght);

  /* "pyclp/pyclp.pyx":273
 *         buffer=<char*>libc.stdlib.calloc(lenght,1)
 *         num_bytes_read=pyclp.ec_queue_read(<int> self.stream_num,buffer,lenght)
 *         if num_bytes_read < 0 :             # <<<<<<<<<<<<<<
 *             raise IOError(n)
 * 
 */
  __pyx_t_3 = ((__pyx_v_num_bytes_read < 0) != 0);
  if (unlikely(__pyx_t_3)) {

    /* "pyclp/pyclp.pyx":274
 *         num_bytes_read=pyclp.ec_queue_read(<int> self.stream_num,buffer,lenght)
 *         if num_bytes_read < 0 :
 *             raise IOError(n)             # <<<<<<<<<<<<<<
 * 
 *         python_buffer=buffer[0:lenght]
 */
    __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_n); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 274, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IOError, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 274, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 274, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":273
 *         buffer=<char*>libc.stdlib.calloc(lenght,1)
 *         num_bytes_read=pyclp.ec_queue_read(<int> self.stream_num,buffer,lenght)
 *         if num_bytes_read < 0 :             # <<<<<<<<<<<<<<
 *             raise IOError(n)
 * 
 */
  }

  /* "pyclp/pyclp.pyx":276
 *             raise IOError(n)
 * 
 *         python_buffer=buffer[0:lenght]             # <<<<<<<<<<<<<<
 *         libc.stdlib.free(buffer)
 *         return python_buffer
 */
  __pyx_t_4 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_buffer + 0, __pyx_v_lenght - 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 276, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_v_python_buffer = ((PyObject*)__pyx_t_4);
  __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":277
 * 
 *         python_buffer=buffer[0:lenght]
 *         libc.stdlib.free(buffer)             # <<<<<<<<<<<<<<
 *         return python_buffer
 *     def write(self,buffer):
 */
  free(__pyx_v_buffer);

  /* "pyclp/pyclp.pyx":278
 *         python_buffer=buffer[0:lenght]
 *         libc.stdlib.free(buffer)
 *         return python_buffer             # <<<<<<<<<<<<<<
 *     def write(self,buffer):
 *         """
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_python_buffer);
  __pyx_r = __pyx_v_python_buffer;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":252
 *         """
 *         pass
 *     def read(self,int n=-1):             # <<<<<<<<<<<<<<
 *         """
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pyclp.pyclp.Stream.read", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_python_buffer);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":279
 *         libc.stdlib.free(buffer)
 *         return python_buffer
 *     def write(self,buffer):             # <<<<<<<<<<<<<<
 *         """
 *         Write a bytes object to stream.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_19write(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_6Stream_18write[] = "\n        Write a bytes object to stream.\n        :type buffer: bytes object.\n        :return: number of bytes written \n        ";
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_6Stream_19write = {"write", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyclp_5pyclp_6Stream_19write, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyclp_5pyclp_6Stream_18write};
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_19write(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_buffer = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("write (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_buffer,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_buffer)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("write", 1, 2, 2, 1); __PYX_ERR(0, 279, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "write") < 0)) __PYX_ERR(0, 279, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_buffer = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("write", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 279, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.Stream.write", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_6Stream_18write(__pyx_self, __pyx_v_self, __pyx_v_buffer);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_18write(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_buffer) {
  int __pyx_v_lenght;
  int __pyx_v_returned_value;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  Py_ssize_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  char *__pyx_t_4;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("write", 0);

  /* "pyclp/pyclp.pyx":289
 *         cdef int returned_value
 *         cdef int num_bytes_read
 *         lenght=len(buffer)             # <<<<<<<<<<<<<<
 *         returned_value=pyclp.ec_queue_write(<int> self.stream_num,<char*>buffer,lenght)
 *         if returned_value < 0:
 */
  __pyx_t_1 = PyObject_Length(__pyx_v_buffer); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 289, __pyx_L1_error)
  __pyx_v_lenght = __pyx_t_1;

  /* "pyclp/pyclp.pyx":290
 *         cdef int num_bytes_read
 *         lenght=len(buffer)
 *         returned_value=pyclp.ec_queue_write(<int> self.stream_num,<char*>buffer,lenght)             # <<<<<<<<<<<<<<
 *         if returned_value < 0:
 *             raise IOError(returned_value)
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_stream_num); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 290, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 290, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_AsWritableString(__pyx_v_buffer); if (unlikely((!__pyx_t_4) && PyErr_Occurred())) __PYX_ERR(0, 290, __pyx_L1_error)
  __pyx_v_returned_value = ec_queue_write(((int)__pyx_t_3), ((char *)__pyx_t_4), __pyx_v_lenght);

  /* "pyclp/pyclp.pyx":291
 *         lenght=len(buffer)
 *         returned_value=pyclp.ec_queue_write(<int> self.stream_num,<char*>buffer,lenght)
 *         if returned_value < 0:             # <<<<<<<<<<<<<<
 *             raise IOError(returned_value)
 *         else:
 */
  __pyx_t_5 = ((__pyx_v_returned_value < 0) != 0);
  if (unlikely(__pyx_t_5)) {

    /* "pyclp/pyclp.pyx":292
 *         returned_value=pyclp.ec_queue_write(<int> self.stream_num,<char*>buffer,lenght)
 *         if returned_value < 0:
 *             raise IOError(returned_value)             # <<<<<<<<<<<<<<
 *         else:
 *             return returned_value
 */
    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_returned_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 292, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IOError, __pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 292, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_6, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __PYX_ERR(0, 292, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":291
 *         lenght=len(buffer)
 *         returned_value=pyclp.ec_queue_write(<int> self.stream_num,<char*>buffer,lenght)
 *         if returned_value < 0:             # <<<<<<<<<<<<<<
 *             raise IOError(returned_value)
 *         else:
 */
  }

  /* "pyclp/pyclp.pyx":294
 *             raise IOError(returned_value)
 *         else:
 *             return returned_value             # <<<<<<<<<<<<<<
 *     def readall(self):
 *         """
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_6 = __Pyx_PyInt_From_int(__pyx_v_returned_value); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 294, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_r = __pyx_t_6;
    __pyx_t_6 = 0;
    goto __pyx_L0;
  }

  /* "pyclp/pyclp.pyx":279
 *         libc.stdlib.free(buffer)
 *         return python_buffer
 *     def write(self,buffer):             # <<<<<<<<<<<<<<
 *         """
 *         Write a bytes object to stream.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("pyclp.pyclp.Stream.write", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":295
 *         else:
 *             return returned_value
 *     def readall(self):             # <<<<<<<<<<<<<<
 *         """
 *         Read all available bytes equivalent to :py:func:`pyclp.read`
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_21readall(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_6Stream_20readall[] = "\n        Read all available bytes equivalent to :py:func:`pyclp.read`\n        \n        ";
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_6Stream_21readall = {"readall", (PyCFunction)__pyx_pw_5pyclp_5pyclp_6Stream_21readall, METH_O, __pyx_doc_5pyclp_5pyclp_6Stream_20readall};
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_21readall(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("readall (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_6Stream_20readall(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_20readall(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("readall", 0);

  /* "pyclp/pyclp.pyx":300
 * 
 *         """
 *         return self.read(-1)             # <<<<<<<<<<<<<<
 *     def readinto(self,b):
 *         raise NotImplemented()
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_read); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 300, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_int_neg_1) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_int_neg_1);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 300, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":295
 *         else:
 *             return returned_value
 *     def readall(self):             # <<<<<<<<<<<<<<
 *         """
 *         Read all available bytes equivalent to :py:func:`pyclp.read`
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pyclp.pyclp.Stream.readall", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":301
 *         """
 *         return self.read(-1)
 *     def readinto(self,b):             # <<<<<<<<<<<<<<
 *         raise NotImplemented()
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_23readinto(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_6Stream_23readinto = {"readinto", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyclp_5pyclp_6Stream_23readinto, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_5pyclp_5pyclp_6Stream_23readinto(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_self = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("readinto (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_b,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("readinto", 1, 2, 2, 1); __PYX_ERR(0, 301, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "readinto") < 0)) __PYX_ERR(0, 301, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_b = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("readinto", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 301, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.Stream.readinto", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_6Stream_22readinto(__pyx_self, __pyx_v_self, __pyx_v_b);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_6Stream_22readinto(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_b) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("readinto", 0);

  /* "pyclp/pyclp.pyx":302
 *         return self.read(-1)
 *     def readinto(self,b):
 *         raise NotImplemented()             # <<<<<<<<<<<<<<
 * 
 * cdef destroy_all_refs():
 */
  __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_builtin_NotImplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 302, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(0, 302, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":301
 *         """
 *         return self.read(-1)
 *     def readinto(self,b):             # <<<<<<<<<<<<<<
 *         raise NotImplemented()
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Stream.readinto", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":304
 *         raise NotImplemented()
 * 
 * cdef destroy_all_refs():             # <<<<<<<<<<<<<<
 *     for prolog_ref in all_active_refs:
 *         if prolog_ref is not None:
 */

static PyObject *__pyx_f_5pyclp_5pyclp_destroy_all_refs(void) {
  PyObject *__pyx_v_prolog_ref = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *(*__pyx_t_4)(PyObject *);
  int __pyx_t_5;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("destroy_all_refs", 0);

  /* "pyclp/pyclp.pyx":305
 * 
 * cdef destroy_all_refs():
 *     for prolog_ref in all_active_refs:             # <<<<<<<<<<<<<<
 *         if prolog_ref is not None:
 *             (<Ref?>prolog_ref).dealloc()
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_all_active_refs); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 305, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
    __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
    __pyx_t_4 = NULL;
  } else {
    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 305, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 305, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  for (;;) {
    if (likely(!__pyx_t_4)) {
      if (likely(PyList_CheckExact(__pyx_t_2))) {
        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 305, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 305, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      } else {
        if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 305, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 305, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      }
    } else {
      __pyx_t_1 = __pyx_t_4(__pyx_t_2);
      if (unlikely(!__pyx_t_1)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 305, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_1);
    }
    __Pyx_XDECREF_SET(__pyx_v_prolog_ref, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "pyclp/pyclp.pyx":306
 * cdef destroy_all_refs():
 *     for prolog_ref in all_active_refs:
 *         if prolog_ref is not None:             # <<<<<<<<<<<<<<
 *             (<Ref?>prolog_ref).dealloc()
 * 
 */
    __pyx_t_5 = (__pyx_v_prolog_ref != Py_None);
    __pyx_t_6 = (__pyx_t_5 != 0);
    if (__pyx_t_6) {

      /* "pyclp/pyclp.pyx":307
 *     for prolog_ref in all_active_refs:
 *         if prolog_ref is not None:
 *             (<Ref?>prolog_ref).dealloc()             # <<<<<<<<<<<<<<
 * 
 * cdef recreate_all_refs():
 */
      if (!(likely(__Pyx_TypeTest(__pyx_v_prolog_ref, __pyx_ptype_5pyclp_5pyclp_Ref)))) __PYX_ERR(0, 307, __pyx_L1_error)
      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_prolog_ref, __pyx_n_s_dealloc); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 307, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_8 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_7, function);
        }
      }
      __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_8) : __Pyx_PyObject_CallNoArg(__pyx_t_7);
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 307, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "pyclp/pyclp.pyx":306
 * cdef destroy_all_refs():
 *     for prolog_ref in all_active_refs:
 *         if prolog_ref is not None:             # <<<<<<<<<<<<<<
 *             (<Ref?>prolog_ref).dealloc()
 * 
 */
    }

    /* "pyclp/pyclp.pyx":305
 * 
 * cdef destroy_all_refs():
 *     for prolog_ref in all_active_refs:             # <<<<<<<<<<<<<<
 *         if prolog_ref is not None:
 *             (<Ref?>prolog_ref).dealloc()
 */
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pyclp/pyclp.pyx":304
 *         raise NotImplemented()
 * 
 * cdef destroy_all_refs():             # <<<<<<<<<<<<<<
 *     for prolog_ref in all_active_refs:
 *         if prolog_ref is not None:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("pyclp.pyclp.destroy_all_refs", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_prolog_ref);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":309
 *             (<Ref?>prolog_ref).dealloc()
 * 
 * cdef recreate_all_refs():             # <<<<<<<<<<<<<<
 *     """Recreate all eclipse refs.
 *     """
 */

static PyObject *__pyx_f_5pyclp_5pyclp_recreate_all_refs(void) {
  PyObject *__pyx_v_prolog_ref = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *(*__pyx_t_4)(PyObject *);
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("recreate_all_refs", 0);

  /* "pyclp/pyclp.pyx":312
 *     """Recreate all eclipse refs.
 *     """
 *     for prolog_ref in all_active_refs:             # <<<<<<<<<<<<<<
 *         if prolog_ref is not None and (<Ref?>prolog_ref).ref==NULL:
 *             prolog_ref.cinit()
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_all_active_refs); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 312, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
    __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
    __pyx_t_4 = NULL;
  } else {
    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 312, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 312, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  for (;;) {
    if (likely(!__pyx_t_4)) {
      if (likely(PyList_CheckExact(__pyx_t_2))) {
        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 312, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 312, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      } else {
        if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 312, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 312, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      }
    } else {
      __pyx_t_1 = __pyx_t_4(__pyx_t_2);
      if (unlikely(!__pyx_t_1)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 312, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_1);
    }
    __Pyx_XDECREF_SET(__pyx_v_prolog_ref, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "pyclp/pyclp.pyx":313
 *     """
 *     for prolog_ref in all_active_refs:
 *         if prolog_ref is not None and (<Ref?>prolog_ref).ref==NULL:             # <<<<<<<<<<<<<<
 *             prolog_ref.cinit()
 * def init():
 */
    __pyx_t_6 = (__pyx_v_prolog_ref != Py_None);
    __pyx_t_7 = (__pyx_t_6 != 0);
    if (__pyx_t_7) {
    } else {
      __pyx_t_5 = __pyx_t_7;
      goto __pyx_L6_bool_binop_done;
    }
    if (!(likely(__Pyx_TypeTest(__pyx_v_prolog_ref, __pyx_ptype_5pyclp_5pyclp_Ref)))) __PYX_ERR(0, 313, __pyx_L1_error)
    __pyx_t_7 = ((((struct __pyx_obj_5pyclp_5pyclp_Ref *)__pyx_v_prolog_ref)->ref == NULL) != 0);
    __pyx_t_5 = __pyx_t_7;
    __pyx_L6_bool_binop_done:;
    if (__pyx_t_5) {

      /* "pyclp/pyclp.pyx":314
 *     for prolog_ref in all_active_refs:
 *         if prolog_ref is not None and (<Ref?>prolog_ref).ref==NULL:
 *             prolog_ref.cinit()             # <<<<<<<<<<<<<<
 * def init():
 *     """This shall be called before calling any other function.
 */
      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_prolog_ref, __pyx_n_s_cinit); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 314, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_9 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {
        __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_8);
        if (likely(__pyx_t_9)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
          __Pyx_INCREF(__pyx_t_9);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_8, function);
        }
      }
      __pyx_t_1 = (__pyx_t_9) ? __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_9) : __Pyx_PyObject_CallNoArg(__pyx_t_8);
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 314, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "pyclp/pyclp.pyx":313
 *     """
 *     for prolog_ref in all_active_refs:
 *         if prolog_ref is not None and (<Ref?>prolog_ref).ref==NULL:             # <<<<<<<<<<<<<<
 *             prolog_ref.cinit()
 * def init():
 */
    }

    /* "pyclp/pyclp.pyx":312
 *     """Recreate all eclipse refs.
 *     """
 *     for prolog_ref in all_active_refs:             # <<<<<<<<<<<<<<
 *         if prolog_ref is not None and (<Ref?>prolog_ref).ref==NULL:
 *             prolog_ref.cinit()
 */
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pyclp/pyclp.pyx":309
 *             (<Ref?>prolog_ref).dealloc()
 * 
 * cdef recreate_all_refs():             # <<<<<<<<<<<<<<
 *     """Recreate all eclipse refs.
 *     """
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("pyclp.pyclp.recreate_all_refs", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_prolog_ref);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":315
 *         if prolog_ref is not None and (<Ref?>prolog_ref).ref==NULL:
 *             prolog_ref.cinit()
 * def init():             # <<<<<<<<<<<<<<
 *     """This shall be called before calling any other function.
 *     This initialize Eclipse engine.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_3init(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_2init[] = "This shall be called before calling any other function.\n    This initialize Eclipse engine.\n    \n    :raise:\n        pyclpEx in case of failure or if eclipse engine is already initialized\n\n    ";
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_3init = {"init", (PyCFunction)__pyx_pw_5pyclp_5pyclp_3init, METH_NOARGS, __pyx_doc_5pyclp_5pyclp_2init};
static PyObject *__pyx_pw_5pyclp_5pyclp_3init(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("init (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_2init(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_2init(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("init", 0);

  /* "pyclp/pyclp.pyx":325
 *     global toPython,last_resume_result,python_pred2func
 *     global eclipse_initialized,pyPredicatesException
 *     pyPredicatesException=None             # <<<<<<<<<<<<<<
 *     python_pred2func={} #It shall be a empty dictionary at init. Defensive programming
 *     if eclipse_initialized != 0:
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyPredicatesException, Py_None) < 0) __PYX_ERR(0, 325, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":326
 *     global eclipse_initialized,pyPredicatesException
 *     pyPredicatesException=None
 *     python_pred2func={} #It shall be a empty dictionary at init. Defensive programming             # <<<<<<<<<<<<<<
 *     if eclipse_initialized != 0:
 *         raise pyclpEx("Tried to initialize an already initialized eclipse engine")
 */
  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 326, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_python_pred2func, __pyx_t_1) < 0) __PYX_ERR(0, 326, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":327
 *     pyPredicatesException=None
 *     python_pred2func={} #It shall be a empty dictionary at init. Defensive programming
 *     if eclipse_initialized != 0:             # <<<<<<<<<<<<<<
 *         raise pyclpEx("Tried to initialize an already initialized eclipse engine")
 *     last_resume_result=None #It shall be None at init. Defensive programming
 */
  __pyx_t_2 = ((__pyx_v_5pyclp_5pyclp_eclipse_initialized != 0) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "pyclp/pyclp.pyx":328
 *     python_pred2func={} #It shall be a empty dictionary at init. Defensive programming
 *     if eclipse_initialized != 0:
 *         raise pyclpEx("Tried to initialize an already initialized eclipse engine")             # <<<<<<<<<<<<<<
 *     last_resume_result=None #It shall be None at init. Defensive programming
 *     pyclp.ec_set_option_long(pyclp.EC_OPTION_IO, pyclp.MEMORY_IO)
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 328, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_s_Tried_to_initialize_an_already_i) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_Tried_to_initialize_an_already_i);
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 328, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 328, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":327
 *     pyPredicatesException=None
 *     python_pred2func={} #It shall be a empty dictionary at init. Defensive programming
 *     if eclipse_initialized != 0:             # <<<<<<<<<<<<<<
 *         raise pyclpEx("Tried to initialize an already initialized eclipse engine")
 *     last_resume_result=None #It shall be None at init. Defensive programming
 */
  }

  /* "pyclp/pyclp.pyx":329
 *     if eclipse_initialized != 0:
 *         raise pyclpEx("Tried to initialize an already initialized eclipse engine")
 *     last_resume_result=None #It shall be None at init. Defensive programming             # <<<<<<<<<<<<<<
 *     pyclp.ec_set_option_long(pyclp.EC_OPTION_IO, pyclp.MEMORY_IO)
 *     if (pyclp.ec_init()):
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_last_resume_result, Py_None) < 0) __PYX_ERR(0, 329, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":330
 *         raise pyclpEx("Tried to initialize an already initialized eclipse engine")
 *     last_resume_result=None #It shall be None at init. Defensive programming
 *     pyclp.ec_set_option_long(pyclp.EC_OPTION_IO, pyclp.MEMORY_IO)             # <<<<<<<<<<<<<<
 *     if (pyclp.ec_init()):
 *         raise pyclpEx("Failed initialization")
 */
  (void)(ec_set_option_long(EC_OPTION_IO, MEMORY_IO));

  /* "pyclp/pyclp.pyx":331
 *     last_resume_result=None #It shall be None at init. Defensive programming
 *     pyclp.ec_set_option_long(pyclp.EC_OPTION_IO, pyclp.MEMORY_IO)
 *     if (pyclp.ec_init()):             # <<<<<<<<<<<<<<
 *         raise pyclpEx("Failed initialization")
 *     else:
 */
  __pyx_t_2 = (ec_init() != 0);
  if (unlikely(__pyx_t_2)) {

    /* "pyclp/pyclp.pyx":332
 *     pyclp.ec_set_option_long(pyclp.EC_OPTION_IO, pyclp.MEMORY_IO)
 *     if (pyclp.ec_init()):
 *         raise pyclpEx("Failed initialization")             # <<<<<<<<<<<<<<
 *     else:
 *         #If the registering of call_python_func fails raise an exception
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 332, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_s_Failed_initialization) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_Failed_initialization);
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 332, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 332, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":331
 *     last_resume_result=None #It shall be None at init. Defensive programming
 *     pyclp.ec_set_option_long(pyclp.EC_OPTION_IO, pyclp.MEMORY_IO)
 *     if (pyclp.ec_init()):             # <<<<<<<<<<<<<<
 *         raise pyclpEx("Failed initialization")
 *     else:
 */
  }

  /* "pyclp/pyclp.pyx":335
 *     else:
 *         #If the registering of call_python_func fails raise an exception
 *         if register_call_python_pred() != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             cleanup()
 *             raise pyclpEx("init() failed registering of eclipse:call_python_func")
 */
  /*else*/ {
    __pyx_t_2 = ((__pyx_f_5pyclp_5pyclp_register_call_python_pred() != PSUCCEED) != 0);
    if (unlikely(__pyx_t_2)) {

      /* "pyclp/pyclp.pyx":336
 *         #If the registering of call_python_func fails raise an exception
 *         if register_call_python_pred() != pyclp.PSUCCEED:
 *             cleanup()             # <<<<<<<<<<<<<<
 *             raise pyclpEx("init() failed registering of eclipse:call_python_func")
 *         eclipse_initialized=1
 */
      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_cleanup); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 336, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 336, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "pyclp/pyclp.pyx":337
 *         if register_call_python_pred() != pyclp.PSUCCEED:
 *             cleanup()
 *             raise pyclpEx("init() failed registering of eclipse:call_python_func")             # <<<<<<<<<<<<<<
 *         eclipse_initialized=1
 *         recreate_all_refs()
 */
      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 337, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_s_init_failed_registering_of_eclip) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_init_failed_registering_of_eclip);
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 337, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 337, __pyx_L1_error)

      /* "pyclp/pyclp.pyx":335
 *     else:
 *         #If the registering of call_python_func fails raise an exception
 *         if register_call_python_pred() != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             cleanup()
 *             raise pyclpEx("init() failed registering of eclipse:call_python_func")
 */
    }

    /* "pyclp/pyclp.pyx":338
 *             cleanup()
 *             raise pyclpEx("init() failed registering of eclipse:call_python_func")
 *         eclipse_initialized=1             # <<<<<<<<<<<<<<
 *         recreate_all_refs()
 *         if toPython is None:
 */
    __pyx_v_5pyclp_5pyclp_eclipse_initialized = 1;

    /* "pyclp/pyclp.pyx":339
 *             raise pyclpEx("init() failed registering of eclipse:call_python_func")
 *         eclipse_initialized=1
 *         recreate_all_refs()             # <<<<<<<<<<<<<<
 *         if toPython is None:
 *             toPython=Var()
 */
    __pyx_t_1 = __pyx_f_5pyclp_5pyclp_recreate_all_refs(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 339, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "pyclp/pyclp.pyx":340
 *         eclipse_initialized=1
 *         recreate_all_refs()
 *         if toPython is None:             # <<<<<<<<<<<<<<
 *             toPython=Var()
 * 
 */
    __pyx_t_2 = (((PyObject *)__pyx_v_5pyclp_5pyclp_toPython) == Py_None);
    __pyx_t_5 = (__pyx_t_2 != 0);
    if (__pyx_t_5) {

      /* "pyclp/pyclp.pyx":341
 *         recreate_all_refs()
 *         if toPython is None:
 *             toPython=Var()             # <<<<<<<<<<<<<<
 * 
 * 
 */
      __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Var)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 341, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_XGOTREF(((PyObject *)__pyx_v_5pyclp_5pyclp_toPython));
      __Pyx_DECREF_SET(__pyx_v_5pyclp_5pyclp_toPython, ((struct __pyx_obj_5pyclp_5pyclp_Var *)__pyx_t_1));
      __Pyx_GIVEREF(__pyx_t_1);
      __pyx_t_1 = 0;

      /* "pyclp/pyclp.pyx":340
 *         eclipse_initialized=1
 *         recreate_all_refs()
 *         if toPython is None:             # <<<<<<<<<<<<<<
 *             toPython=Var()
 * 
 */
    }
  }

  /* "pyclp/pyclp.pyx":315
 *         if prolog_ref is not None and (<Ref?>prolog_ref).ref==NULL:
 *             prolog_ref.cinit()
 * def init():             # <<<<<<<<<<<<<<
 *     """This shall be called before calling any other function.
 *     This initialize Eclipse engine.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pyclp.pyclp.init", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":344
 * 
 * 
 * def cleanup():             # <<<<<<<<<<<<<<
 *     """This shutdown the Eclipse engine.
 *     After calling this function any operation on pyclp object or class could crash the program.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_5cleanup(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_4cleanup[] = "This shutdown the Eclipse engine.\n    After calling this function any operation on pyclp object or class could crash the program.\n    \n    :raise:\n        pyclpEx in case of failure or if eclipse engine is already shutdown\n        \n    .. warning::\n    \n        If after a cleanup it is called again :py:func:`pyclp.init` all terms created before the cleanup are not valid and they need \n        to be rebuilt.\n    ";
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_5cleanup = {"cleanup", (PyCFunction)__pyx_pw_5pyclp_5pyclp_5cleanup, METH_NOARGS, __pyx_doc_5pyclp_5pyclp_4cleanup};
static PyObject *__pyx_pw_5pyclp_5pyclp_5cleanup(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cleanup (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_4cleanup(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_4cleanup(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("cleanup", 0);

  /* "pyclp/pyclp.pyx":358
 *     global last_resume_result,python_pred2func
 *     global eclipse_initialized,pyPredicatesException
 *     pyPredicatesException=None             # <<<<<<<<<<<<<<
 *     if eclipse_initialized == 0:
 *         raise pyclpEx("Tried to cleanup an already shutdown engine")
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyPredicatesException, Py_None) < 0) __PYX_ERR(0, 358, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":359
 *     global eclipse_initialized,pyPredicatesException
 *     pyPredicatesException=None
 *     if eclipse_initialized == 0:             # <<<<<<<<<<<<<<
 *         raise pyclpEx("Tried to cleanup an already shutdown engine")
 *     destroy_all_refs()
 */
  __pyx_t_1 = ((__pyx_v_5pyclp_5pyclp_eclipse_initialized == 0) != 0);
  if (unlikely(__pyx_t_1)) {

    /* "pyclp/pyclp.pyx":360
 *     pyPredicatesException=None
 *     if eclipse_initialized == 0:
 *         raise pyclpEx("Tried to cleanup an already shutdown engine")             # <<<<<<<<<<<<<<
 *     destroy_all_refs()
 *     python_pred2func={}
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 360, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_s_Tried_to_cleanup_an_already_shut) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_Tried_to_cleanup_an_already_shut);
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 360, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 360, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":359
 *     global eclipse_initialized,pyPredicatesException
 *     pyPredicatesException=None
 *     if eclipse_initialized == 0:             # <<<<<<<<<<<<<<
 *         raise pyclpEx("Tried to cleanup an already shutdown engine")
 *     destroy_all_refs()
 */
  }

  /* "pyclp/pyclp.pyx":361
 *     if eclipse_initialized == 0:
 *         raise pyclpEx("Tried to cleanup an already shutdown engine")
 *     destroy_all_refs()             # <<<<<<<<<<<<<<
 *     python_pred2func={}
 *     eclipse_initialized=0
 */
  __pyx_t_2 = __pyx_f_5pyclp_5pyclp_destroy_all_refs(); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 361, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pyclp/pyclp.pyx":362
 *         raise pyclpEx("Tried to cleanup an already shutdown engine")
 *     destroy_all_refs()
 *     python_pred2func={}             # <<<<<<<<<<<<<<
 *     eclipse_initialized=0
 *     last_resume_result=None
 */
  __pyx_t_2 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 362, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_python_pred2func, __pyx_t_2) < 0) __PYX_ERR(0, 362, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pyclp/pyclp.pyx":363
 *     destroy_all_refs()
 *     python_pred2func={}
 *     eclipse_initialized=0             # <<<<<<<<<<<<<<
 *     last_resume_result=None
 *     if (pyclp.ec_cleanup()):
 */
  __pyx_v_5pyclp_5pyclp_eclipse_initialized = 0;

  /* "pyclp/pyclp.pyx":364
 *     python_pred2func={}
 *     eclipse_initialized=0
 *     last_resume_result=None             # <<<<<<<<<<<<<<
 *     if (pyclp.ec_cleanup()):
 *         raise pyclpEx("Failed cleanup operation")
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_last_resume_result, Py_None) < 0) __PYX_ERR(0, 364, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":365
 *     eclipse_initialized=0
 *     last_resume_result=None
 *     if (pyclp.ec_cleanup()):             # <<<<<<<<<<<<<<
 *         raise pyclpEx("Failed cleanup operation")
 * 
 */
  __pyx_t_1 = (ec_cleanup() != 0);
  if (unlikely(__pyx_t_1)) {

    /* "pyclp/pyclp.pyx":366
 *     last_resume_result=None
 *     if (pyclp.ec_cleanup()):
 *         raise pyclpEx("Failed cleanup operation")             # <<<<<<<<<<<<<<
 * 
 * 
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 366, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_s_Failed_cleanup_operation) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_Failed_cleanup_operation);
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 366, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 366, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":365
 *     eclipse_initialized=0
 *     last_resume_result=None
 *     if (pyclp.ec_cleanup()):             # <<<<<<<<<<<<<<
 *         raise pyclpEx("Failed cleanup operation")
 * 
 */
  }

  /* "pyclp/pyclp.pyx":344
 * 
 * 
 * def cleanup():             # <<<<<<<<<<<<<<
 *     """This shutdown the Eclipse engine.
 *     After calling this function any operation on pyclp object or class could crash the program.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pyclp.pyclp.cleanup", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":369
 * 
 * 
 * def cut():             # <<<<<<<<<<<<<<
 *     """
 *     Cut all choice point of succeeded goal.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_7cut(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_6cut[] = "\n    Cut all choice point of succeeded goal.\n    Equivalent to void `ec_cut_to_chp(ec_ref) <http://www.eclipseclp.org/doc/embedding/embroot081.html>`_\n    It can be called only if previous resume call SUCCEED.\n    \n    .. seealso::\n    \n        `ec_cut_to_chp <http://www.eclipseclp.org/doc/embedding/embroot081.html>`_\n            cut function in ECLiPSe in C interface library\n            \n    For an example see :ref:`Cut Example <cut-example>` \n    \n    ";
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_7cut = {"cut", (PyCFunction)__pyx_pw_5pyclp_5pyclp_7cut, METH_NOARGS, __pyx_doc_5pyclp_5pyclp_6cut};
static PyObject *__pyx_pw_5pyclp_5pyclp_7cut(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cut (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_6cut(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_6cut(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("cut", 0);

  /* "pyclp/pyclp.pyx":383
 * 
 *     """
 *     if last_resume_result==pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         pyclp.ec_cut_to_chp(toPython.ref.ref)
 *     else:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_last_resume_result); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 383, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_From_int(PSUCCEED); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 383, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyObject_RichCompare(__pyx_t_1, __pyx_t_2, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 383, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 383, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (likely(__pyx_t_4)) {

    /* "pyclp/pyclp.pyx":384
 *     """
 *     if last_resume_result==pyclp.PSUCCEED:
 *         pyclp.ec_cut_to_chp(toPython.ref.ref)             # <<<<<<<<<<<<<<
 *     else:
 *         raise pyclpEx("Cut it is possible only after a resume that returns SUCCEED.")
 */
    ec_cut_to_chp(__pyx_v_5pyclp_5pyclp_toPython->__pyx_base.ref->ref);

    /* "pyclp/pyclp.pyx":383
 * 
 *     """
 *     if last_resume_result==pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         pyclp.ec_cut_to_chp(toPython.ref.ref)
 *     else:
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":386
 *         pyclp.ec_cut_to_chp(toPython.ref.ref)
 *     else:
 *         raise pyclpEx("Cut it is possible only after a resume that returns SUCCEED.")             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 386, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_3 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_1, __pyx_kp_s_Cut_it_is_possible_only_after_a) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_Cut_it_is_possible_only_after_a);
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 386, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 386, __pyx_L1_error)
  }
  __pyx_L3:;

  /* "pyclp/pyclp.pyx":369
 * 
 * 
 * def cut():             # <<<<<<<<<<<<<<
 *     """
 *     Cut all choice point of succeeded goal.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pyclp.pyclp.cut", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":389
 * 
 * 
 * def resume(in_term=None):             # <<<<<<<<<<<<<<
 *     """
 *     Resume Eclipse engine.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_9resume(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_8resume[] = "\n    Resume Eclipse engine.\n    Implements the functionality of \n    `ec_resume,ec_resume1,ec_resume2 <http://www.eclipseclp.org/doc/embedding/embroot081.html>`_.  \n    It accepts optional argument *in_term*. Used to return a value to the prolog predicate \n    `yield/2 <http://www.eclipseclp.org/doc/bips/kernel/externals/yield-2.html>`_\n    \n    :param in_term: Optional argument *in_term*. Used to return a value to the prolog predicate     `yield/2 <http://www.eclipseclp.org/doc/bips/kernel/externals/yield-2.html>`_\n    :type in_term: :py:class:`PList`, :py:class:`Atom`, :py:class:`Compound`\n    \n    :rtype: tuple\n    :returns: \n        (pyclp.SUCCEED,None) if execution succeed (equivalent to True).         In this case it is possible to call pyclp.cut()\n        \n        (pyclp.FAIL,None) if the goal fails.\n        \n        (pyclp.FLUSHIO,\\ *stream_number*\\ ) if some data is present in stream identified by *stream_number*\n        \n        (pyclp.WAITIO,\\ *stream_number*\\ )  if eclipse engine try to read data         from stream identified by *stream_number*\n        \n        (pyclp.YIELD, *yield_returned_value*) in case of predicate call         `yield/2 <http://www.eclipseclp.org/doc/bips/kernel/externals/yield-2.html>`_.\n\n        (pyclp.THROW, *Term TagExit*) an event have been thrown and no one have catched it         `exit_block/1 <http://www.eclipseclp.org/doc/bips/kernel/control/exit_block-1.html>`_.\n        \n            \n      \n    .. warning::\n    \n        After receiving FLUSHIO or WAITIO a new resume shall be issued \n        before creating variable or calling post_goal to complete the \n        goal execution and avoid unpredictable behavior.\n    \n    .. note::\n    \n        PyCLP have a different behavior compared to C/C++/Java default libraries provided by ECLiPsE.\n        Standard resume execution destroys all the terms built before the execution of resume function while PyCLP is \n        preserving them creating a ""reference and storing the created term in this.\n    \n    .. seealso::\n    \n        `ec_resume,ec_resume1,ec_resume2 <http://www.eclipseclp.org/doc/embedding/embroot081.html>`_\n            Resume functions in ECLiPSe in C interface library.\n        \n    \n    ";
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_9resume = {"resume", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyclp_5pyclp_9resume, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyclp_5pyclp_8resume};
static PyObject *__pyx_pw_5pyclp_5pyclp_9resume(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_in_term = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("resume (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_in_term,0};
    PyObject* values[1] = {0};
    values[0] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_in_term);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "resume") < 0)) __PYX_ERR(0, 389, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_in_term = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("resume", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 389, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.resume", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_8resume(__pyx_self, __pyx_v_in_term);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_8resume(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_in_term) {
  int __pyx_v_result;
  ec_ref __pyx_v_in_ref;
  PyObject *__pyx_v_returned_value = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  ec_ref __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("resume", 0);

  /* "pyclp/pyclp.pyx":445
 *     global last_resume_result
 * 
 *     in_ref=toPython.ref.ref             # <<<<<<<<<<<<<<
 *     # Eclipse resume can be executed with GIL released
 *     if in_term is None:
 */
  __pyx_t_1 = __pyx_v_5pyclp_5pyclp_toPython->__pyx_base.ref->ref;
  __pyx_v_in_ref = __pyx_t_1;

  /* "pyclp/pyclp.pyx":447
 *     in_ref=toPython.ref.ref
 *     # Eclipse resume can be executed with GIL released
 *     if in_term is None:             # <<<<<<<<<<<<<<
 *         result=pyclp.ec_resume1(in_ref)
 *     else:
 */
  __pyx_t_2 = (__pyx_v_in_term == Py_None);
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "pyclp/pyclp.pyx":448
 *     # Eclipse resume can be executed with GIL released
 *     if in_term is None:
 *         result=pyclp.ec_resume1(in_ref)             # <<<<<<<<<<<<<<
 *     else:
 *         result=pyclp.ec_resume2( (<Term?>in_term).get_pword(),in_ref)
 */
    __pyx_v_result = ec_resume1(__pyx_v_in_ref);

    /* "pyclp/pyclp.pyx":447
 *     in_ref=toPython.ref.ref
 *     # Eclipse resume can be executed with GIL released
 *     if in_term is None:             # <<<<<<<<<<<<<<
 *         result=pyclp.ec_resume1(in_ref)
 *     else:
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":450
 *         result=pyclp.ec_resume1(in_ref)
 *     else:
 *         result=pyclp.ec_resume2( (<Term?>in_term).get_pword(),in_ref)             # <<<<<<<<<<<<<<
 *     last_resume_result=result # Save last result in a global to be used in cut and init.
 *     if pyclp.PSUCCEED == result:
 */
  /*else*/ {
    if (!(likely(__Pyx_TypeTest(__pyx_v_in_term, __pyx_ptype_5pyclp_5pyclp_Term)))) __PYX_ERR(0, 450, __pyx_L1_error)
    __pyx_v_result = ec_resume2(((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_in_term)->__pyx_vtab)->get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_in_term)), __pyx_v_in_ref);
  }
  __pyx_L3:;

  /* "pyclp/pyclp.pyx":451
 *     else:
 *         result=pyclp.ec_resume2( (<Term?>in_term).get_pword(),in_ref)
 *     last_resume_result=result # Save last result in a global to be used in cut and init.             # <<<<<<<<<<<<<<
 *     if pyclp.PSUCCEED == result:
 *         return (SUCCEED, None)
 */
  __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_result); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 451, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_last_resume_result, __pyx_t_4) < 0) __PYX_ERR(0, 451, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":452
 *         result=pyclp.ec_resume2( (<Term?>in_term).get_pword(),in_ref)
 *     last_resume_result=result # Save last result in a global to be used in cut and init.
 *     if pyclp.PSUCCEED == result:             # <<<<<<<<<<<<<<
 *         return (SUCCEED, None)
 *     elif pyclp.PFAIL == result:
 */
  __pyx_t_3 = ((PSUCCEED == __pyx_v_result) != 0);
  if (__pyx_t_3) {

    /* "pyclp/pyclp.pyx":453
 *     last_resume_result=result # Save last result in a global to be used in cut and init.
 *     if pyclp.PSUCCEED == result:
 *         return (SUCCEED, None)             # <<<<<<<<<<<<<<
 *     elif pyclp.PFAIL == result:
 *         return (FAIL,None)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_SUCCEED); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 453, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 453, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
    __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(Py_None);
    PyTuple_SET_ITEM(__pyx_t_5, 1, Py_None);
    __pyx_t_4 = 0;
    __pyx_r = __pyx_t_5;
    __pyx_t_5 = 0;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":452
 *         result=pyclp.ec_resume2( (<Term?>in_term).get_pword(),in_ref)
 *     last_resume_result=result # Save last result in a global to be used in cut and init.
 *     if pyclp.PSUCCEED == result:             # <<<<<<<<<<<<<<
 *         return (SUCCEED, None)
 *     elif pyclp.PFAIL == result:
 */
  }

  /* "pyclp/pyclp.pyx":454
 *     if pyclp.PSUCCEED == result:
 *         return (SUCCEED, None)
 *     elif pyclp.PFAIL == result:             # <<<<<<<<<<<<<<
 *         return (FAIL,None)
 *     elif pyclp.PFLUSHIO== result:
 */
  __pyx_t_3 = ((PFAIL == __pyx_v_result) != 0);
  if (__pyx_t_3) {

    /* "pyclp/pyclp.pyx":455
 *         return (SUCCEED, None)
 *     elif pyclp.PFAIL == result:
 *         return (FAIL,None)             # <<<<<<<<<<<<<<
 *     elif pyclp.PFLUSHIO== result:
 *         return (FLUSHIO,toPython.value())
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_FAIL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 455, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 455, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5);
    __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(Py_None);
    PyTuple_SET_ITEM(__pyx_t_4, 1, Py_None);
    __pyx_t_5 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":454
 *     if pyclp.PSUCCEED == result:
 *         return (SUCCEED, None)
 *     elif pyclp.PFAIL == result:             # <<<<<<<<<<<<<<
 *         return (FAIL,None)
 *     elif pyclp.PFLUSHIO== result:
 */
  }

  /* "pyclp/pyclp.pyx":456
 *     elif pyclp.PFAIL == result:
 *         return (FAIL,None)
 *     elif pyclp.PFLUSHIO== result:             # <<<<<<<<<<<<<<
 *         return (FLUSHIO,toPython.value())
 *     elif pyclp.PWAITIO ==result:
 */
  __pyx_t_3 = ((PFLUSHIO == __pyx_v_result) != 0);
  if (__pyx_t_3) {

    /* "pyclp/pyclp.pyx":457
 *         return (FAIL,None)
 *     elif pyclp.PFLUSHIO== result:
 *         return (FLUSHIO,toPython.value())             # <<<<<<<<<<<<<<
 *     elif pyclp.PWAITIO ==result:
 *         return (WAITIO,toPython.value())
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_FLUSHIO); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 457, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Var *)__pyx_v_5pyclp_5pyclp_toPython->__pyx_base.__pyx_vtab)->value(__pyx_v_5pyclp_5pyclp_toPython, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 457, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 457, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_5);
    __pyx_t_4 = 0;
    __pyx_t_5 = 0;
    __pyx_r = __pyx_t_6;
    __pyx_t_6 = 0;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":456
 *     elif pyclp.PFAIL == result:
 *         return (FAIL,None)
 *     elif pyclp.PFLUSHIO== result:             # <<<<<<<<<<<<<<
 *         return (FLUSHIO,toPython.value())
 *     elif pyclp.PWAITIO ==result:
 */
  }

  /* "pyclp/pyclp.pyx":458
 *     elif pyclp.PFLUSHIO== result:
 *         return (FLUSHIO,toPython.value())
 *     elif pyclp.PWAITIO ==result:             # <<<<<<<<<<<<<<
 *         return (WAITIO,toPython.value())
 *     elif pyclp.PYIELD ==result:
 */
  __pyx_t_3 = ((PWAITIO == __pyx_v_result) != 0);
  if (__pyx_t_3) {

    /* "pyclp/pyclp.pyx":459
 *         return (FLUSHIO,toPython.value())
 *     elif pyclp.PWAITIO ==result:
 *         return (WAITIO,toPython.value())             # <<<<<<<<<<<<<<
 *     elif pyclp.PYIELD ==result:
 *         return (YIELD,toPython.value())
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_WAITIO); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 459, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_5 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Var *)__pyx_v_5pyclp_5pyclp_toPython->__pyx_base.__pyx_vtab)->value(__pyx_v_5pyclp_5pyclp_toPython, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 459, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 459, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_5);
    __pyx_t_6 = 0;
    __pyx_t_5 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":458
 *     elif pyclp.PFLUSHIO== result:
 *         return (FLUSHIO,toPython.value())
 *     elif pyclp.PWAITIO ==result:             # <<<<<<<<<<<<<<
 *         return (WAITIO,toPython.value())
 *     elif pyclp.PYIELD ==result:
 */
  }

  /* "pyclp/pyclp.pyx":460
 *     elif pyclp.PWAITIO ==result:
 *         return (WAITIO,toPython.value())
 *     elif pyclp.PYIELD ==result:             # <<<<<<<<<<<<<<
 *         return (YIELD,toPython.value())
 *     elif pyclp.PTHROW == result:
 */
  __pyx_t_3 = ((PYIELD == __pyx_v_result) != 0);
  if (__pyx_t_3) {

    /* "pyclp/pyclp.pyx":461
 *         return (WAITIO,toPython.value())
 *     elif pyclp.PYIELD ==result:
 *         return (YIELD,toPython.value())             # <<<<<<<<<<<<<<
 *     elif pyclp.PTHROW == result:
 *         returned_value=toPython.value()
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_YIELD); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 461, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Var *)__pyx_v_5pyclp_5pyclp_toPython->__pyx_base.__pyx_vtab)->value(__pyx_v_5pyclp_5pyclp_toPython, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 461, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 461, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_5);
    __pyx_t_4 = 0;
    __pyx_t_5 = 0;
    __pyx_r = __pyx_t_6;
    __pyx_t_6 = 0;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":460
 *     elif pyclp.PWAITIO ==result:
 *         return (WAITIO,toPython.value())
 *     elif pyclp.PYIELD ==result:             # <<<<<<<<<<<<<<
 *         return (YIELD,toPython.value())
 *     elif pyclp.PTHROW == result:
 */
  }

  /* "pyclp/pyclp.pyx":462
 *     elif pyclp.PYIELD ==result:
 *         return (YIELD,toPython.value())
 *     elif pyclp.PTHROW == result:             # <<<<<<<<<<<<<<
 *         returned_value=toPython.value()
 *         # if exception was raised in external predicate
 */
  __pyx_t_3 = ((PTHROW == __pyx_v_result) != 0);
  if (__pyx_t_3) {

    /* "pyclp/pyclp.pyx":463
 *         return (YIELD,toPython.value())
 *     elif pyclp.PTHROW == result:
 *         returned_value=toPython.value()             # <<<<<<<<<<<<<<
 *         # if exception was raised in external predicate
 *         # re-raise the exception otherwise return value
 */
    __pyx_t_6 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Var *)__pyx_v_5pyclp_5pyclp_toPython->__pyx_base.__pyx_vtab)->value(__pyx_v_5pyclp_5pyclp_toPython, 0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 463, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_v_returned_value = __pyx_t_6;
    __pyx_t_6 = 0;

    /* "pyclp/pyclp.pyx":466
 *         # if exception was raised in external predicate
 *         # re-raise the exception otherwise return value
 *         if returned_value == Atom("python_error"):             # <<<<<<<<<<<<<<
 *             raise pyPredicatesException
 *         else:
 */
    __pyx_t_6 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Atom), __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 466, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_5 = PyObject_RichCompare(__pyx_v_returned_value, __pyx_t_6, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 466, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 466, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(__pyx_t_3)) {

      /* "pyclp/pyclp.pyx":467
 *         # re-raise the exception otherwise return value
 *         if returned_value == Atom("python_error"):
 *             raise pyPredicatesException             # <<<<<<<<<<<<<<
 *         else:
 *             return (THROW,returned_value)
 */
      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_pyPredicatesException); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 467, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __PYX_ERR(0, 467, __pyx_L1_error)

      /* "pyclp/pyclp.pyx":466
 *         # if exception was raised in external predicate
 *         # re-raise the exception otherwise return value
 *         if returned_value == Atom("python_error"):             # <<<<<<<<<<<<<<
 *             raise pyPredicatesException
 *         else:
 */
    }

    /* "pyclp/pyclp.pyx":469
 *             raise pyPredicatesException
 *         else:
 *             return (THROW,returned_value)             # <<<<<<<<<<<<<<
 *     else:
 *         assert False,"Unrecognized result from ec_resume"
 */
    /*else*/ {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_THROW); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 469, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 469, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_GIVEREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5);
      __Pyx_INCREF(__pyx_v_returned_value);
      __Pyx_GIVEREF(__pyx_v_returned_value);
      PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_v_returned_value);
      __pyx_t_5 = 0;
      __pyx_r = __pyx_t_6;
      __pyx_t_6 = 0;
      goto __pyx_L0;
    }

    /* "pyclp/pyclp.pyx":462
 *     elif pyclp.PYIELD ==result:
 *         return (YIELD,toPython.value())
 *     elif pyclp.PTHROW == result:             # <<<<<<<<<<<<<<
 *         returned_value=toPython.value()
 *         # if exception was raised in external predicate
 */
  }

  /* "pyclp/pyclp.pyx":471
 *             return (THROW,returned_value)
 *     else:
 *         assert False,"Unrecognized result from ec_resume"             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    #ifndef CYTHON_WITHOUT_ASSERTIONS
    if (unlikely(!Py_OptimizeFlag)) {
      if (unlikely(!0)) {
        PyErr_SetObject(PyExc_AssertionError, __pyx_kp_s_Unrecognized_result_from_ec_resu);
        __PYX_ERR(0, 471, __pyx_L1_error)
      }
    }
    #endif
  }

  /* "pyclp/pyclp.pyx":389
 * 
 * 
 * def resume(in_term=None):             # <<<<<<<<<<<<<<
 *     """
 *     Resume Eclipse engine.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("pyclp.pyclp.resume", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_returned_value);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":474
 * 
 * 
 * def set_option(option,value):             # <<<<<<<<<<<<<<
 *     """
 *     Set options of eclipse engine. Equivalent to
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_11set_option(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_10set_option[] = "\n    Set options of eclipse engine. Equivalent to \n    `ec_set_option_long(int, long) <http://www.eclipseclp.org/doc/embedding/embroot079.html>`_\n    and `int ec_set_option_ptr(int, char *) <http://www.eclipseclp.org/doc/embedding/embroot079.html>`_.\n    \n    This function must be used before initializing the ECLiPSe engine using :py:func:`pyclp.init`\n    \n    :param option: option supported:\n        pyclp.OPTION_LOCALSIZE (value shall be int)\n        pyclp.OPTION_GLOBALSIZE (value shall be int)\n        pyclp.EC_OPTION_ECLIPSEDIR (value shall be a string)\n        \n    :param value: int or string depends on which option used.\n    \n    ";
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_11set_option = {"set_option", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyclp_5pyclp_11set_option, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyclp_5pyclp_10set_option};
static PyObject *__pyx_pw_5pyclp_5pyclp_11set_option(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_option = 0;
  PyObject *__pyx_v_value = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_option (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_option,&__pyx_n_s_value,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_option)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("set_option", 1, 2, 2, 1); __PYX_ERR(0, 474, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "set_option") < 0)) __PYX_ERR(0, 474, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_option = values[0];
    __pyx_v_value = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("set_option", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 474, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.set_option", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_10set_option(__pyx_self, __pyx_v_option, __pyx_v_value);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_10set_option(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_option, PyObject *__pyx_v_value) {
  PyObject *__pyx_v_py_byte_string = NULL;
  PyObject *__pyx_v_c_string = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  char *__pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  long __pyx_t_8;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("set_option", 0);

  /* "pyclp/pyclp.pyx":490
 * 
 *     """
 *     if option == pyclp.EC_OPTION_ECLIPSEDIR:             # <<<<<<<<<<<<<<
 *         if isinstance(value,str):
 *             py_byte_string = tobytes(value)
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_ECLIPSEDIR); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 490, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyObject_RichCompare(__pyx_v_option, __pyx_t_1, Py_EQ); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 490, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 490, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__pyx_t_3) {

    /* "pyclp/pyclp.pyx":491
 *     """
 *     if option == pyclp.EC_OPTION_ECLIPSEDIR:
 *         if isinstance(value,str):             # <<<<<<<<<<<<<<
 *             py_byte_string = tobytes(value)
 *             c_string = py_byte_string
 */
    __pyx_t_3 = PyString_Check(__pyx_v_value); 
    __pyx_t_4 = (__pyx_t_3 != 0);
    if (likely(__pyx_t_4)) {

      /* "pyclp/pyclp.pyx":492
 *     if option == pyclp.EC_OPTION_ECLIPSEDIR:
 *         if isinstance(value,str):
 *             py_byte_string = tobytes(value)             # <<<<<<<<<<<<<<
 *             c_string = py_byte_string
 *             if pyclp.ec_set_option_ptr(option,c_string) != pyclp.PSUCCEED:
 */
      __pyx_t_2 = __pyx_f_5pyclp_5pyclp_tobytes(__pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 492, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_v_py_byte_string = ((PyObject*)__pyx_t_2);
      __pyx_t_2 = 0;

      /* "pyclp/pyclp.pyx":493
 *         if isinstance(value,str):
 *             py_byte_string = tobytes(value)
 *             c_string = py_byte_string             # <<<<<<<<<<<<<<
 *             if pyclp.ec_set_option_ptr(option,c_string) != pyclp.PSUCCEED:
 *                 raise pyclpEx("Invalid option in set_option")
 */
      __Pyx_INCREF(__pyx_v_py_byte_string);
      __pyx_v_c_string = __pyx_v_py_byte_string;

      /* "pyclp/pyclp.pyx":494
 *             py_byte_string = tobytes(value)
 *             c_string = py_byte_string
 *             if pyclp.ec_set_option_ptr(option,c_string) != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *                 raise pyclpEx("Invalid option in set_option")
 *         else:
 */
      __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_v_option); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 494, __pyx_L1_error)
      if (unlikely(__pyx_v_c_string == Py_None)) {
        PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
        __PYX_ERR(0, 494, __pyx_L1_error)
      }
      __pyx_t_6 = __Pyx_PyBytes_AsWritableString(__pyx_v_c_string); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 494, __pyx_L1_error)
      __pyx_t_4 = ((ec_set_option_ptr(__pyx_t_5, __pyx_t_6) != PSUCCEED) != 0);
      if (unlikely(__pyx_t_4)) {

        /* "pyclp/pyclp.pyx":495
 *             c_string = py_byte_string
 *             if pyclp.ec_set_option_ptr(option,c_string) != pyclp.PSUCCEED:
 *                 raise pyclpEx("Invalid option in set_option")             # <<<<<<<<<<<<<<
 *         else:
 *             raise TypeError("value shall be a string")
 */
        __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 495, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_7 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
          __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_1);
          if (likely(__pyx_t_7)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
            __Pyx_INCREF(__pyx_t_7);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_1, function);
          }
        }
        __pyx_t_2 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_7, __pyx_kp_s_Invalid_option_in_set_option) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_kp_s_Invalid_option_in_set_option);
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 495, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_Raise(__pyx_t_2, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __PYX_ERR(0, 495, __pyx_L1_error)

        /* "pyclp/pyclp.pyx":494
 *             py_byte_string = tobytes(value)
 *             c_string = py_byte_string
 *             if pyclp.ec_set_option_ptr(option,c_string) != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *                 raise pyclpEx("Invalid option in set_option")
 *         else:
 */
      }

      /* "pyclp/pyclp.pyx":491
 *     """
 *     if option == pyclp.EC_OPTION_ECLIPSEDIR:
 *         if isinstance(value,str):             # <<<<<<<<<<<<<<
 *             py_byte_string = tobytes(value)
 *             c_string = py_byte_string
 */
      goto __pyx_L4;
    }

    /* "pyclp/pyclp.pyx":497
 *                 raise pyclpEx("Invalid option in set_option")
 *         else:
 *             raise TypeError("value shall be a string")             # <<<<<<<<<<<<<<
 *     elif option == pyclp.EC_OPTION_LOCALSIZE or option == pyclp.EC_OPTION_GLOBALSIZE:
 *         if isinstance(value,int):
 */
    /*else*/ {
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 497, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __PYX_ERR(0, 497, __pyx_L1_error)
    }
    __pyx_L4:;

    /* "pyclp/pyclp.pyx":490
 * 
 *     """
 *     if option == pyclp.EC_OPTION_ECLIPSEDIR:             # <<<<<<<<<<<<<<
 *         if isinstance(value,str):
 *             py_byte_string = tobytes(value)
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":498
 *         else:
 *             raise TypeError("value shall be a string")
 *     elif option == pyclp.EC_OPTION_LOCALSIZE or option == pyclp.EC_OPTION_GLOBALSIZE:             # <<<<<<<<<<<<<<
 *         if isinstance(value,int):
 *             ec_set_option_long(option,value)
 */
  __pyx_t_2 = __Pyx_PyInt_From_int(EC_OPTION_LOCALSIZE); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 498, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = PyObject_RichCompare(__pyx_v_option, __pyx_t_2, Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 498, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 498, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (!__pyx_t_3) {
  } else {
    __pyx_t_4 = __pyx_t_3;
    goto __pyx_L6_bool_binop_done;
  }
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_GLOBALSIZE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 498, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyObject_RichCompare(__pyx_v_option, __pyx_t_1, Py_EQ); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 498, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 498, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __pyx_t_3;
  __pyx_L6_bool_binop_done:;
  if (likely(__pyx_t_4)) {

    /* "pyclp/pyclp.pyx":499
 *             raise TypeError("value shall be a string")
 *     elif option == pyclp.EC_OPTION_LOCALSIZE or option == pyclp.EC_OPTION_GLOBALSIZE:
 *         if isinstance(value,int):             # <<<<<<<<<<<<<<
 *             ec_set_option_long(option,value)
 *         else:
 */
    __pyx_t_4 = PyInt_Check(__pyx_v_value); 
    __pyx_t_3 = (__pyx_t_4 != 0);
    if (likely(__pyx_t_3)) {

      /* "pyclp/pyclp.pyx":500
 *     elif option == pyclp.EC_OPTION_LOCALSIZE or option == pyclp.EC_OPTION_GLOBALSIZE:
 *         if isinstance(value,int):
 *             ec_set_option_long(option,value)             # <<<<<<<<<<<<<<
 *         else:
 *             raise TypeError("value shall be a int")
 */
      __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_v_option); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 500, __pyx_L1_error)
      __pyx_t_8 = __Pyx_PyInt_As_long(__pyx_v_value); if (unlikely((__pyx_t_8 == (long)-1) && PyErr_Occurred())) __PYX_ERR(0, 500, __pyx_L1_error)
      (void)(ec_set_option_long(__pyx_t_5, __pyx_t_8));

      /* "pyclp/pyclp.pyx":499
 *             raise TypeError("value shall be a string")
 *     elif option == pyclp.EC_OPTION_LOCALSIZE or option == pyclp.EC_OPTION_GLOBALSIZE:
 *         if isinstance(value,int):             # <<<<<<<<<<<<<<
 *             ec_set_option_long(option,value)
 *         else:
 */
      goto __pyx_L8;
    }

    /* "pyclp/pyclp.pyx":502
 *             ec_set_option_long(option,value)
 *         else:
 *             raise TypeError("value shall be a int")             # <<<<<<<<<<<<<<
 *     else:
 *         raise pyclpEx("Unsupported option")
 */
    /*else*/ {
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 502, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __PYX_ERR(0, 502, __pyx_L1_error)
    }
    __pyx_L8:;

    /* "pyclp/pyclp.pyx":498
 *         else:
 *             raise TypeError("value shall be a string")
 *     elif option == pyclp.EC_OPTION_LOCALSIZE or option == pyclp.EC_OPTION_GLOBALSIZE:             # <<<<<<<<<<<<<<
 *         if isinstance(value,int):
 *             ec_set_option_long(option,value)
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":504
 *             raise TypeError("value shall be a int")
 *     else:
 *         raise pyclpEx("Unsupported option")             # <<<<<<<<<<<<<<
 * 
 * cdef class Term:
 */
  /*else*/ {
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 504, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_2 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_7, __pyx_kp_s_Unsupported_option) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_kp_s_Unsupported_option);
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 504, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 504, __pyx_L1_error)
  }
  __pyx_L3:;

  /* "pyclp/pyclp.pyx":474
 * 
 * 
 * def set_option(option,value):             # <<<<<<<<<<<<<<
 *     """
 *     Set options of eclipse engine. Equivalent to
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("pyclp.pyclp.set_option", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_py_byte_string);
  __Pyx_XDECREF(__pyx_v_c_string);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":513
 *     cdef Ref ref
 *     cdef pyclp.pword cached_pword
 *     def __init__(self,init_arg):             # <<<<<<<<<<<<<<
 *         cdef char* c_string
 *         cdef int index
 */

/* Python wrapper */
static int __pyx_pw_5pyclp_5pyclp_4Term_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pyclp_5pyclp_4Term_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_init_arg = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_init_arg,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_init_arg)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 513, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_init_arg = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 513, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.Term.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_4Term___init__(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self), __pyx_v_init_arg);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pyclp_5pyclp_4Term___init__(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self, PyObject *__pyx_v_init_arg) {
  char *__pyx_v_c_string;
  pword __pyx_v_temp;
  PyObject *__pyx_v_py_byte_string = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  char *__pyx_t_4;
  int __pyx_t_5;
  double __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "pyclp/pyclp.pyx":518
 *         cdef pyclp.pword* array_pword
 *         cdef pyclp.pword temp
 *         self.ref=Ref()             # <<<<<<<<<<<<<<
 *         if init_arg!=None:
 *             #String
 */
  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Ref)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 518, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_self->ref);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->ref));
  __pyx_v_self->ref = ((struct __pyx_obj_5pyclp_5pyclp_Ref *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":519
 *         cdef pyclp.pword temp
 *         self.ref=Ref()
 *         if init_arg!=None:             # <<<<<<<<<<<<<<
 *             #String
 *             if isinstance(init_arg,str):
 */
  __pyx_t_1 = PyObject_RichCompare(__pyx_v_init_arg, Py_None, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 519, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 519, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":521
 *         if init_arg!=None:
 *             #String
 *             if isinstance(init_arg,str):             # <<<<<<<<<<<<<<
 *                 py_byte_string = tobytes(init_arg)
 *                 c_string = py_byte_string
 */
    __pyx_t_2 = PyString_Check(__pyx_v_init_arg); 
    __pyx_t_3 = (__pyx_t_2 != 0);
    if (__pyx_t_3) {

      /* "pyclp/pyclp.pyx":522
 *             #String
 *             if isinstance(init_arg,str):
 *                 py_byte_string = tobytes(init_arg)             # <<<<<<<<<<<<<<
 *                 c_string = py_byte_string
 *                 self.ref.set(pyclp.ec_string(c_string))
 */
      __pyx_t_1 = __pyx_f_5pyclp_5pyclp_tobytes(__pyx_v_init_arg); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 522, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_v_py_byte_string = ((PyObject*)__pyx_t_1);
      __pyx_t_1 = 0;

      /* "pyclp/pyclp.pyx":523
 *             if isinstance(init_arg,str):
 *                 py_byte_string = tobytes(init_arg)
 *                 c_string = py_byte_string             # <<<<<<<<<<<<<<
 *                 self.ref.set(pyclp.ec_string(c_string))
 *             #ints
 */
      if (unlikely(__pyx_v_py_byte_string == Py_None)) {
        PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
        __PYX_ERR(0, 523, __pyx_L1_error)
      }
      __pyx_t_4 = __Pyx_PyBytes_AsWritableString(__pyx_v_py_byte_string); if (unlikely((!__pyx_t_4) && PyErr_Occurred())) __PYX_ERR(0, 523, __pyx_L1_error)
      __pyx_v_c_string = __pyx_t_4;

      /* "pyclp/pyclp.pyx":524
 *                 py_byte_string = tobytes(init_arg)
 *                 c_string = py_byte_string
 *                 self.ref.set(pyclp.ec_string(c_string))             # <<<<<<<<<<<<<<
 *             #ints
 *             elif isinstance(init_arg,int):
 */
      ((struct __pyx_vtabstruct_5pyclp_5pyclp_Ref *)__pyx_v_self->ref->__pyx_vtab)->set(__pyx_v_self->ref, ec_string(__pyx_v_c_string));

      /* "pyclp/pyclp.pyx":521
 *         if init_arg!=None:
 *             #String
 *             if isinstance(init_arg,str):             # <<<<<<<<<<<<<<
 *                 py_byte_string = tobytes(init_arg)
 *                 c_string = py_byte_string
 */
      goto __pyx_L4;
    }

    /* "pyclp/pyclp.pyx":526
 *                 self.ref.set(pyclp.ec_string(c_string))
 *             #ints
 *             elif isinstance(init_arg,int):             # <<<<<<<<<<<<<<
 *                 temp=pyclp.ec_long(init_arg)
 *                 self.ref.set(temp)
 */
    __pyx_t_3 = PyInt_Check(__pyx_v_init_arg); 
    __pyx_t_2 = (__pyx_t_3 != 0);
    if (__pyx_t_2) {

      /* "pyclp/pyclp.pyx":527
 *             #ints
 *             elif isinstance(init_arg,int):
 *                 temp=pyclp.ec_long(init_arg)             # <<<<<<<<<<<<<<
 *                 self.ref.set(temp)
 *             #Float
 */
      __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_v_init_arg); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 527, __pyx_L1_error)
      __pyx_v_temp = ec_long(__pyx_t_5);

      /* "pyclp/pyclp.pyx":528
 *             elif isinstance(init_arg,int):
 *                 temp=pyclp.ec_long(init_arg)
 *                 self.ref.set(temp)             # <<<<<<<<<<<<<<
 *             #Float
 *             elif isinstance(init_arg,float):
 */
      ((struct __pyx_vtabstruct_5pyclp_5pyclp_Ref *)__pyx_v_self->ref->__pyx_vtab)->set(__pyx_v_self->ref, __pyx_v_temp);

      /* "pyclp/pyclp.pyx":526
 *                 self.ref.set(pyclp.ec_string(c_string))
 *             #ints
 *             elif isinstance(init_arg,int):             # <<<<<<<<<<<<<<
 *                 temp=pyclp.ec_long(init_arg)
 *                 self.ref.set(temp)
 */
      goto __pyx_L4;
    }

    /* "pyclp/pyclp.pyx":530
 *                 self.ref.set(temp)
 *             #Float
 *             elif isinstance(init_arg,float):             # <<<<<<<<<<<<<<
 *                 self.ref.set(pyclp.ec_double(init_arg))
 *             else:
 */
    __pyx_t_2 = PyFloat_Check(__pyx_v_init_arg); 
    __pyx_t_3 = (__pyx_t_2 != 0);
    if (likely(__pyx_t_3)) {

      /* "pyclp/pyclp.pyx":531
 *             #Float
 *             elif isinstance(init_arg,float):
 *                 self.ref.set(pyclp.ec_double(init_arg))             # <<<<<<<<<<<<<<
 *             else:
 *                 raise TypeError("init argument shall be a string, integer or float")
 */
      __pyx_t_6 = __pyx_PyFloat_AsDouble(__pyx_v_init_arg); if (unlikely((__pyx_t_6 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 531, __pyx_L1_error)
      ((struct __pyx_vtabstruct_5pyclp_5pyclp_Ref *)__pyx_v_self->ref->__pyx_vtab)->set(__pyx_v_self->ref, ec_double(__pyx_t_6));

      /* "pyclp/pyclp.pyx":530
 *                 self.ref.set(temp)
 *             #Float
 *             elif isinstance(init_arg,float):             # <<<<<<<<<<<<<<
 *                 self.ref.set(pyclp.ec_double(init_arg))
 *             else:
 */
      goto __pyx_L4;
    }

    /* "pyclp/pyclp.pyx":533
 *                 self.ref.set(pyclp.ec_double(init_arg))
 *             else:
 *                 raise TypeError("init argument shall be a string, integer or float")             # <<<<<<<<<<<<<<
 *     cdef pyclp.pword get_pword(self):
 *         return self.ref.get()
 */
    /*else*/ {
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 533, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 533, __pyx_L1_error)
    }
    __pyx_L4:;

    /* "pyclp/pyclp.pyx":519
 *         cdef pyclp.pword temp
 *         self.ref=Ref()
 *         if init_arg!=None:             # <<<<<<<<<<<<<<
 *             #String
 *             if isinstance(init_arg,str):
 */
  }

  /* "pyclp/pyclp.pyx":513
 *     cdef Ref ref
 *     cdef pyclp.pword cached_pword
 *     def __init__(self,init_arg):             # <<<<<<<<<<<<<<
 *         cdef char* c_string
 *         cdef int index
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Term.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_py_byte_string);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":534
 *             else:
 *                 raise TypeError("init argument shall be a string, integer or float")
 *     cdef pyclp.pword get_pword(self):             # <<<<<<<<<<<<<<
 *         return self.ref.get()
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:
 */

static pword __pyx_f_5pyclp_5pyclp_4Term_get_pword(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self) {
  pword __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_pword", 0);

  /* "pyclp/pyclp.pyx":535
 *                 raise TypeError("init argument shall be a string, integer or float")
 *     cdef pyclp.pword get_pword(self):
 *         return self.ref.get()             # <<<<<<<<<<<<<<
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:
 *         self.ref.set(in_pword)
 */
  __pyx_r = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Ref *)__pyx_v_self->ref->__pyx_vtab)->get(__pyx_v_self->ref);
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":534
 *             else:
 *                 raise TypeError("init argument shall be a string, integer or float")
 *     cdef pyclp.pword get_pword(self):             # <<<<<<<<<<<<<<
 *         return self.ref.get()
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":536
 *     cdef pyclp.pword get_pword(self):
 *         return self.ref.get()
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:             # <<<<<<<<<<<<<<
 *         self.ref.set(in_pword)
 * 
 */

static int __pyx_f_5pyclp_5pyclp_4Term_set_pword(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self, pword __pyx_v_in_pword) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_pword", 0);

  /* "pyclp/pyclp.pyx":537
 *         return self.ref.get()
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:
 *         self.ref.set(in_pword)             # <<<<<<<<<<<<<<
 * 
 *     cdef int compare_pword(self,other) except? -12345 :
 */
  ((struct __pyx_vtabstruct_5pyclp_5pyclp_Ref *)__pyx_v_self->ref->__pyx_vtab)->set(__pyx_v_self->ref, __pyx_v_in_pword);

  /* "pyclp/pyclp.pyx":536
 *     cdef pyclp.pword get_pword(self):
 *         return self.ref.get()
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:             # <<<<<<<<<<<<<<
 *         self.ref.set(in_pword)
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":539
 *         self.ref.set(in_pword)
 * 
 *     cdef int compare_pword(self,other) except? -12345 :             # <<<<<<<<<<<<<<
 *         if  isinstance(self,Term) and isinstance(other,Term):
 *             return pyclp.ec_compare((<Term>self).get_pword(),(<Term>other).get_pword())
 */

static int __pyx_f_5pyclp_5pyclp_4Term_compare_pword(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self, PyObject *__pyx_v_other) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("compare_pword", 0);

  /* "pyclp/pyclp.pyx":540
 * 
 *     cdef int compare_pword(self,other) except? -12345 :
 *         if  isinstance(self,Term) and isinstance(other,Term):             # <<<<<<<<<<<<<<
 *             return pyclp.ec_compare((<Term>self).get_pword(),(<Term>other).get_pword())
 *         else:
 */
  __pyx_t_2 = __Pyx_TypeCheck(((PyObject *)__pyx_v_self), __pyx_ptype_5pyclp_5pyclp_Term); 
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {
  } else {
    __pyx_t_1 = __pyx_t_3;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_3 = __Pyx_TypeCheck(__pyx_v_other, __pyx_ptype_5pyclp_5pyclp_Term); 
  __pyx_t_2 = (__pyx_t_3 != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (likely(__pyx_t_1)) {

    /* "pyclp/pyclp.pyx":541
 *     cdef int compare_pword(self,other) except? -12345 :
 *         if  isinstance(self,Term) and isinstance(other,Term):
 *             return pyclp.ec_compare((<Term>self).get_pword(),(<Term>other).get_pword())             # <<<<<<<<<<<<<<
 *         else:
 *             raise TypeError("Comparison between incompatible types")
 */
    __pyx_r = ec_compare(((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self)->__pyx_vtab)->get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self)), ((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_other)->__pyx_vtab)->get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_other)));
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":540
 * 
 *     cdef int compare_pword(self,other) except? -12345 :
 *         if  isinstance(self,Term) and isinstance(other,Term):             # <<<<<<<<<<<<<<
 *             return pyclp.ec_compare((<Term>self).get_pword(),(<Term>other).get_pword())
 *         else:
 */
  }

  /* "pyclp/pyclp.pyx":543
 *             return pyclp.ec_compare((<Term>self).get_pword(),(<Term>other).get_pword())
 *         else:
 *             raise TypeError("Comparison between incompatible types")             # <<<<<<<<<<<<<<
 * 
 *     def __cmp__(self,other):
 */
  /*else*/ {
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 543, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 543, __pyx_L1_error)
  }

  /* "pyclp/pyclp.pyx":539
 *         self.ref.set(in_pword)
 * 
 *     cdef int compare_pword(self,other) except? -12345 :             # <<<<<<<<<<<<<<
 *         if  isinstance(self,Term) and isinstance(other,Term):
 *             return pyclp.ec_compare((<Term>self).get_pword(),(<Term>other).get_pword())
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pyclp.pyclp.Term.compare_pword", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -12345;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":545
 *             raise TypeError("Comparison between incompatible types")
 * 
 *     def __cmp__(self,other):             # <<<<<<<<<<<<<<
 *         cdef Term self_casted
 *         if other is None:
 */

/* Python wrapper */
#if PY_MAJOR_VERSION < 3
static int __pyx_pw_5pyclp_5pyclp_4Term_3__cmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_other); /*proto*/
static int __pyx_pw_5pyclp_5pyclp_4Term_3__cmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_other) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cmp__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_4Term_2__cmp__(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self), ((PyObject *)__pyx_v_other));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
#endif /*!(#if PY_MAJOR_VERSION < 3)*/

#if PY_MAJOR_VERSION < 3
static int __pyx_pf_5pyclp_5pyclp_4Term_2__cmp__(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self, PyObject *__pyx_v_other) {
  struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self_casted = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__cmp__", 0);

  /* "pyclp/pyclp.pyx":547
 *     def __cmp__(self,other):
 *         cdef Term self_casted
 *         if other is None:             # <<<<<<<<<<<<<<
 *             return 1
 *         else:
 */
  __pyx_t_1 = (__pyx_v_other == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":548
 *         cdef Term self_casted
 *         if other is None:
 *             return 1             # <<<<<<<<<<<<<<
 *         else:
 *             self_casted=<Term?>self
 */
    __pyx_r = 1;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":547
 *     def __cmp__(self,other):
 *         cdef Term self_casted
 *         if other is None:             # <<<<<<<<<<<<<<
 *             return 1
 *         else:
 */
  }

  /* "pyclp/pyclp.pyx":550
 *             return 1
 *         else:
 *             self_casted=<Term?>self             # <<<<<<<<<<<<<<
 *             return self_casted.compare(other)
 * 
 */
  /*else*/ {
    if (!(likely(__Pyx_TypeTest(((PyObject *)__pyx_v_self), __pyx_ptype_5pyclp_5pyclp_Term)))) __PYX_ERR(0, 550, __pyx_L1_error)
    __pyx_t_3 = ((PyObject *)__pyx_v_self);
    __Pyx_INCREF(__pyx_t_3);
    __pyx_v_self_casted = ((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_t_3);
    __pyx_t_3 = 0;

    /* "pyclp/pyclp.pyx":551
 *         else:
 *             self_casted=<Term?>self
 *             return self_casted.compare(other)             # <<<<<<<<<<<<<<
 * 
 *     def __richcmp__(self,other,op):
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self_casted), __pyx_n_s_compare); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 551, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_other) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_other);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 551, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 551, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_r = __pyx_t_6;
    goto __pyx_L0;
  }

  /* "pyclp/pyclp.pyx":545
 *             raise TypeError("Comparison between incompatible types")
 * 
 *     def __cmp__(self,other):             # <<<<<<<<<<<<<<
 *         cdef Term self_casted
 *         if other is None:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pyclp.pyclp.Term.__cmp__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_self_casted);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
#endif /*!(#if PY_MAJOR_VERSION < 3)*/

/* "pyclp/pyclp.pyx":553
 *             return self_casted.compare(other)
 * 
 *     def __richcmp__(self,other,op):             # <<<<<<<<<<<<<<
 *         """Rich comparison special function.
 *         If the other object is not a Term or derived from Term a TypeError will be raised.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_4Term_5__richcmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_other, int __pyx_arg_op); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_4Term_5__richcmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_other, int __pyx_arg_op) {
  PyObject *__pyx_v_op = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__richcmp__ (wrapper)", 0);
  __pyx_v_op = __Pyx_PyInt_From_int(__pyx_arg_op); if (unlikely(!__pyx_v_op)) __PYX_ERR(0, 553, __pyx_L3_error)
  __Pyx_GOTREF(__pyx_v_op);
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.Term.__richcmp__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_4Term_4__richcmp__(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self), ((PyObject *)__pyx_v_other), ((PyObject *)__pyx_v_op));

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_op);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_4Term_4__richcmp__(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self, PyObject *__pyx_v_other, PyObject *__pyx_v_op) {
  struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self_casted = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__richcmp__", 0);

  /* "pyclp/pyclp.pyx":558
 *         """
 *         cdef Term self_casted
 *         if other is None:             # <<<<<<<<<<<<<<
 *             if op==2:
 *                 return False
 */
  __pyx_t_1 = (__pyx_v_other == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":559
 *         cdef Term self_casted
 *         if other is None:
 *             if op==2:             # <<<<<<<<<<<<<<
 *                 return False
 *             elif op==3:
 */
    __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_v_op, __pyx_int_2, 2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 559, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 559, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (__pyx_t_2) {

      /* "pyclp/pyclp.pyx":560
 *         if other is None:
 *             if op==2:
 *                 return False             # <<<<<<<<<<<<<<
 *             elif op==3:
 *                 return True
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      goto __pyx_L0;

      /* "pyclp/pyclp.pyx":559
 *         cdef Term self_casted
 *         if other is None:
 *             if op==2:             # <<<<<<<<<<<<<<
 *                 return False
 *             elif op==3:
 */
    }

    /* "pyclp/pyclp.pyx":561
 *             if op==2:
 *                 return False
 *             elif op==3:             # <<<<<<<<<<<<<<
 *                 return True
 *             else:
 */
    __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_v_op, __pyx_int_3, 3, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 561, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 561, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (likely(__pyx_t_2)) {

      /* "pyclp/pyclp.pyx":562
 *                 return False
 *             elif op==3:
 *                 return True             # <<<<<<<<<<<<<<
 *             else:
 *                 raise TypeError("This comparison operation is not supported with None. Only supported comparison == !=")
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_True);
      __pyx_r = Py_True;
      goto __pyx_L0;

      /* "pyclp/pyclp.pyx":561
 *             if op==2:
 *                 return False
 *             elif op==3:             # <<<<<<<<<<<<<<
 *                 return True
 *             else:
 */
    }

    /* "pyclp/pyclp.pyx":564
 *                 return True
 *             else:
 *                 raise TypeError("This comparison operation is not supported with None. Only supported comparison == !=")             # <<<<<<<<<<<<<<
 * 
 *         self_casted=<Term?>self
 */
    /*else*/ {
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 564, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __PYX_ERR(0, 564, __pyx_L1_error)
    }

    /* "pyclp/pyclp.pyx":558
 *         """
 *         cdef Term self_casted
 *         if other is None:             # <<<<<<<<<<<<<<
 *             if op==2:
 *                 return False
 */
  }

  /* "pyclp/pyclp.pyx":566
 *                 raise TypeError("This comparison operation is not supported with None. Only supported comparison == !=")
 * 
 *         self_casted=<Term?>self             # <<<<<<<<<<<<<<
 *         if op==2: # ==
 *             if self_casted.compare_pword(other)==0:
 */
  if (!(likely(__Pyx_TypeTest(((PyObject *)__pyx_v_self), __pyx_ptype_5pyclp_5pyclp_Term)))) __PYX_ERR(0, 566, __pyx_L1_error)
  __pyx_t_3 = ((PyObject *)__pyx_v_self);
  __Pyx_INCREF(__pyx_t_3);
  __pyx_v_self_casted = ((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "pyclp/pyclp.pyx":567
 * 
 *         self_casted=<Term?>self
 *         if op==2: # ==             # <<<<<<<<<<<<<<
 *             if self_casted.compare_pword(other)==0:
 *                 return True
 */
  __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_v_op, __pyx_int_2, 2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 567, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 567, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":568
 *         self_casted=<Term?>self
 *         if op==2: # ==
 *             if self_casted.compare_pword(other)==0:             # <<<<<<<<<<<<<<
 *                 return True
 *             else:
 */
    __pyx_t_4 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)__pyx_v_self_casted->__pyx_vtab)->compare_pword(__pyx_v_self_casted, __pyx_v_other); if (unlikely(__pyx_t_4 == ((int)-12345) && PyErr_Occurred())) __PYX_ERR(0, 568, __pyx_L1_error)
    __pyx_t_2 = ((__pyx_t_4 == 0) != 0);
    if (__pyx_t_2) {

      /* "pyclp/pyclp.pyx":569
 *         if op==2: # ==
 *             if self_casted.compare_pword(other)==0:
 *                 return True             # <<<<<<<<<<<<<<
 *             else:
 *                 return False
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_True);
      __pyx_r = Py_True;
      goto __pyx_L0;

      /* "pyclp/pyclp.pyx":568
 *         self_casted=<Term?>self
 *         if op==2: # ==
 *             if self_casted.compare_pword(other)==0:             # <<<<<<<<<<<<<<
 *                 return True
 *             else:
 */
    }

    /* "pyclp/pyclp.pyx":571
 *                 return True
 *             else:
 *                 return False             # <<<<<<<<<<<<<<
 *         elif op==3: # !=
 *             if self_casted.compare_pword(other)==0:
 */
    /*else*/ {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      goto __pyx_L0;
    }

    /* "pyclp/pyclp.pyx":567
 * 
 *         self_casted=<Term?>self
 *         if op==2: # ==             # <<<<<<<<<<<<<<
 *             if self_casted.compare_pword(other)==0:
 *                 return True
 */
  }

  /* "pyclp/pyclp.pyx":572
 *             else:
 *                 return False
 *         elif op==3: # !=             # <<<<<<<<<<<<<<
 *             if self_casted.compare_pword(other)==0:
 *                 return False
 */
  __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_v_op, __pyx_int_3, 3, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 572, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 572, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":573
 *                 return False
 *         elif op==3: # !=
 *             if self_casted.compare_pword(other)==0:             # <<<<<<<<<<<<<<
 *                 return False
 *             else:
 */
    __pyx_t_4 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)__pyx_v_self_casted->__pyx_vtab)->compare_pword(__pyx_v_self_casted, __pyx_v_other); if (unlikely(__pyx_t_4 == ((int)-12345) && PyErr_Occurred())) __PYX_ERR(0, 573, __pyx_L1_error)
    __pyx_t_2 = ((__pyx_t_4 == 0) != 0);
    if (__pyx_t_2) {

      /* "pyclp/pyclp.pyx":574
 *         elif op==3: # !=
 *             if self_casted.compare_pword(other)==0:
 *                 return False             # <<<<<<<<<<<<<<
 *             else:
 *                 return True
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      goto __pyx_L0;

      /* "pyclp/pyclp.pyx":573
 *                 return False
 *         elif op==3: # !=
 *             if self_casted.compare_pword(other)==0:             # <<<<<<<<<<<<<<
 *                 return False
 *             else:
 */
    }

    /* "pyclp/pyclp.pyx":576
 *                 return False
 *             else:
 *                 return True             # <<<<<<<<<<<<<<
 *         elif op==0: # <
 *             if self_casted.compare_pword(other) < 0:
 */
    /*else*/ {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_True);
      __pyx_r = Py_True;
      goto __pyx_L0;
    }

    /* "pyclp/pyclp.pyx":572
 *             else:
 *                 return False
 *         elif op==3: # !=             # <<<<<<<<<<<<<<
 *             if self_casted.compare_pword(other)==0:
 *                 return False
 */
  }

  /* "pyclp/pyclp.pyx":577
 *             else:
 *                 return True
 *         elif op==0: # <             # <<<<<<<<<<<<<<
 *             if self_casted.compare_pword(other) < 0:
 *                 return True
 */
  __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_v_op, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 577, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 577, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":578
 *                 return True
 *         elif op==0: # <
 *             if self_casted.compare_pword(other) < 0:             # <<<<<<<<<<<<<<
 *                 return True
 *             else:
 */
    __pyx_t_4 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)__pyx_v_self_casted->__pyx_vtab)->compare_pword(__pyx_v_self_casted, __pyx_v_other); if (unlikely(__pyx_t_4 == ((int)-12345) && PyErr_Occurred())) __PYX_ERR(0, 578, __pyx_L1_error)
    __pyx_t_2 = ((__pyx_t_4 < 0) != 0);
    if (__pyx_t_2) {

      /* "pyclp/pyclp.pyx":579
 *         elif op==0: # <
 *             if self_casted.compare_pword(other) < 0:
 *                 return True             # <<<<<<<<<<<<<<
 *             else:
 *                 return False
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_True);
      __pyx_r = Py_True;
      goto __pyx_L0;

      /* "pyclp/pyclp.pyx":578
 *                 return True
 *         elif op==0: # <
 *             if self_casted.compare_pword(other) < 0:             # <<<<<<<<<<<<<<
 *                 return True
 *             else:
 */
    }

    /* "pyclp/pyclp.pyx":581
 *                 return True
 *             else:
 *                 return False             # <<<<<<<<<<<<<<
 *         elif op==4: # >
 *             if self_casted.compare_pword(other) < 0:
 */
    /*else*/ {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      goto __pyx_L0;
    }

    /* "pyclp/pyclp.pyx":577
 *             else:
 *                 return True
 *         elif op==0: # <             # <<<<<<<<<<<<<<
 *             if self_casted.compare_pword(other) < 0:
 *                 return True
 */
  }

  /* "pyclp/pyclp.pyx":582
 *             else:
 *                 return False
 *         elif op==4: # >             # <<<<<<<<<<<<<<
 *             if self_casted.compare_pword(other) < 0:
 *                 return False
 */
  __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_v_op, __pyx_int_4, 4, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 582, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 582, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":583
 *                 return False
 *         elif op==4: # >
 *             if self_casted.compare_pword(other) < 0:             # <<<<<<<<<<<<<<
 *                 return False
 *             else:
 */
    __pyx_t_4 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)__pyx_v_self_casted->__pyx_vtab)->compare_pword(__pyx_v_self_casted, __pyx_v_other); if (unlikely(__pyx_t_4 == ((int)-12345) && PyErr_Occurred())) __PYX_ERR(0, 583, __pyx_L1_error)
    __pyx_t_2 = ((__pyx_t_4 < 0) != 0);
    if (__pyx_t_2) {

      /* "pyclp/pyclp.pyx":584
 *         elif op==4: # >
 *             if self_casted.compare_pword(other) < 0:
 *                 return False             # <<<<<<<<<<<<<<
 *             else:
 *                 return True
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      goto __pyx_L0;

      /* "pyclp/pyclp.pyx":583
 *                 return False
 *         elif op==4: # >
 *             if self_casted.compare_pword(other) < 0:             # <<<<<<<<<<<<<<
 *                 return False
 *             else:
 */
    }

    /* "pyclp/pyclp.pyx":586
 *                 return False
 *             else:
 *                 return True             # <<<<<<<<<<<<<<
 *         elif op==1: # <=
 *             if self_casted.compare_pword(other) <= 0:
 */
    /*else*/ {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_True);
      __pyx_r = Py_True;
      goto __pyx_L0;
    }

    /* "pyclp/pyclp.pyx":582
 *             else:
 *                 return False
 *         elif op==4: # >             # <<<<<<<<<<<<<<
 *             if self_casted.compare_pword(other) < 0:
 *                 return False
 */
  }

  /* "pyclp/pyclp.pyx":587
 *             else:
 *                 return True
 *         elif op==1: # <=             # <<<<<<<<<<<<<<
 *             if self_casted.compare_pword(other) <= 0:
 *                 return True
 */
  __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_v_op, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 587, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 587, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":588
 *                 return True
 *         elif op==1: # <=
 *             if self_casted.compare_pword(other) <= 0:             # <<<<<<<<<<<<<<
 *                 return True
 *             else:
 */
    __pyx_t_4 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)__pyx_v_self_casted->__pyx_vtab)->compare_pword(__pyx_v_self_casted, __pyx_v_other); if (unlikely(__pyx_t_4 == ((int)-12345) && PyErr_Occurred())) __PYX_ERR(0, 588, __pyx_L1_error)
    __pyx_t_2 = ((__pyx_t_4 <= 0) != 0);
    if (__pyx_t_2) {

      /* "pyclp/pyclp.pyx":589
 *         elif op==1: # <=
 *             if self_casted.compare_pword(other) <= 0:
 *                 return True             # <<<<<<<<<<<<<<
 *             else:
 *                 return False
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_True);
      __pyx_r = Py_True;
      goto __pyx_L0;

      /* "pyclp/pyclp.pyx":588
 *                 return True
 *         elif op==1: # <=
 *             if self_casted.compare_pword(other) <= 0:             # <<<<<<<<<<<<<<
 *                 return True
 *             else:
 */
    }

    /* "pyclp/pyclp.pyx":591
 *                 return True
 *             else:
 *                 return False             # <<<<<<<<<<<<<<
 *         elif op==5: # >=
 *             if self_casted.compare_pword(other) >= 0:
 */
    /*else*/ {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      goto __pyx_L0;
    }

    /* "pyclp/pyclp.pyx":587
 *             else:
 *                 return True
 *         elif op==1: # <=             # <<<<<<<<<<<<<<
 *             if self_casted.compare_pword(other) <= 0:
 *                 return True
 */
  }

  /* "pyclp/pyclp.pyx":592
 *             else:
 *                 return False
 *         elif op==5: # >=             # <<<<<<<<<<<<<<
 *             if self_casted.compare_pword(other) >= 0:
 *                 return True
 */
  __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_v_op, __pyx_int_5, 5, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 592, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 592, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":593
 *                 return False
 *         elif op==5: # >=
 *             if self_casted.compare_pword(other) >= 0:             # <<<<<<<<<<<<<<
 *                 return True
 *             else:
 */
    __pyx_t_4 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)__pyx_v_self_casted->__pyx_vtab)->compare_pword(__pyx_v_self_casted, __pyx_v_other); if (unlikely(__pyx_t_4 == ((int)-12345) && PyErr_Occurred())) __PYX_ERR(0, 593, __pyx_L1_error)
    __pyx_t_2 = ((__pyx_t_4 >= 0) != 0);
    if (__pyx_t_2) {

      /* "pyclp/pyclp.pyx":594
 *         elif op==5: # >=
 *             if self_casted.compare_pword(other) >= 0:
 *                 return True             # <<<<<<<<<<<<<<
 *             else:
 *                 return False
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_True);
      __pyx_r = Py_True;
      goto __pyx_L0;

      /* "pyclp/pyclp.pyx":593
 *                 return False
 *         elif op==5: # >=
 *             if self_casted.compare_pword(other) >= 0:             # <<<<<<<<<<<<<<
 *                 return True
 *             else:
 */
    }

    /* "pyclp/pyclp.pyx":596
 *                 return True
 *             else:
 *                 return False             # <<<<<<<<<<<<<<
 * 
 *     def post_goal(self):
 */
    /*else*/ {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      goto __pyx_L0;
    }

    /* "pyclp/pyclp.pyx":592
 *             else:
 *                 return False
 *         elif op==5: # >=             # <<<<<<<<<<<<<<
 *             if self_casted.compare_pword(other) >= 0:
 *                 return True
 */
  }

  /* "pyclp/pyclp.pyx":553
 *             return self_casted.compare(other)
 * 
 *     def __richcmp__(self,other,op):             # <<<<<<<<<<<<<<
 *         """Rich comparison special function.
 *         If the other object is not a Term or derived from Term a TypeError will be raised.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pyclp.pyclp.Term.__richcmp__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_self_casted);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":598
 *                 return False
 * 
 *     def post_goal(self):             # <<<<<<<<<<<<<<
 *         """Post goal
 *         """
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_4Term_7post_goal(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_4Term_6post_goal[] = "Post goal\n        ";
static PyObject *__pyx_pw_5pyclp_5pyclp_4Term_7post_goal(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("post_goal (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_4Term_6post_goal(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_4Term_6post_goal(struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("post_goal", 0);

  /* "pyclp/pyclp.pyx":601
 *         """Post goal
 *         """
 *         pyclp.ec_post_goal(self.ref.get())             # <<<<<<<<<<<<<<
 * 
 * 
 */
  ec_post_goal(((struct __pyx_vtabstruct_5pyclp_5pyclp_Ref *)__pyx_v_self->ref->__pyx_vtab)->get(__pyx_v_self->ref));

  /* "pyclp/pyclp.pyx":598
 *                 return False
 * 
 *     def post_goal(self):             # <<<<<<<<<<<<<<
 *         """Post goal
 *         """
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_4Term_9__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_4Term_9__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_4Term_8__reduce_cython__(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_4Term_8__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Term.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_4Term_11__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_4Term_11__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_4Term_10__setstate_cython__(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_4Term_10__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Term.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":604
 * 
 * 
 * cdef object pword2object(pyclp.pword in_pword):             # <<<<<<<<<<<<<<
 *     cdef pyclp.dident dummy_dident
 *     cdef char* c_string = NULL
 */

static PyObject *__pyx_f_5pyclp_5pyclp_pword2object(pword __pyx_v_in_pword) {
  dident __pyx_v_dummy_dident;
  char *__pyx_v_c_string;
  long __pyx_v_length;
  long __pyx_v_c_int;
  double __pyx_v_c_double;
  pword __pyx_v_tail;
  pword __pyx_v_head;
  PyObject *__pyx_v_result = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("pword2object", 0);

  /* "pyclp/pyclp.pyx":606
 * cdef object pword2object(pyclp.pword in_pword):
 *     cdef pyclp.dident dummy_dident
 *     cdef char* c_string = NULL             # <<<<<<<<<<<<<<
 *     cdef long int length = 0
 *     cdef long int c_int
 */
  __pyx_v_c_string = NULL;

  /* "pyclp/pyclp.pyx":607
 *     cdef pyclp.dident dummy_dident
 *     cdef char* c_string = NULL
 *     cdef long int length = 0             # <<<<<<<<<<<<<<
 *     cdef long int c_int
 *     cdef double c_double
 */
  __pyx_v_length = 0;

  /* "pyclp/pyclp.pyx":614
 *     #Check if it is a list.
 *     # List is before because a list is also a Compound term.
 *     if pyclp.ec_get_list(in_pword,&head,&tail)== pyclp.PSUCCEED or pyclp.ec_get_nil(in_pword) == pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=PList(None)
 *         (<PList>result).set_pword(in_pword)
 */
  __pyx_t_2 = ((ec_get_list(__pyx_v_in_pword, (&__pyx_v_head), (&__pyx_v_tail)) == PSUCCEED) != 0);
  if (!__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_2 = ((ec_get_nil(__pyx_v_in_pword) == PSUCCEED) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_1) {

    /* "pyclp/pyclp.pyx":615
 *     # List is before because a list is also a Compound term.
 *     if pyclp.ec_get_list(in_pword,&head,&tail)== pyclp.PSUCCEED or pyclp.ec_get_nil(in_pword) == pyclp.PSUCCEED:
 *         result=PList(None)             # <<<<<<<<<<<<<<
 *         (<PList>result).set_pword(in_pword)
 *     elif pyclp.ec_get_functor(in_pword,&dummy_dident)== pyclp.PSUCCEED:
 */
    __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pyclp_5pyclp_PList), __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 615, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_result = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "pyclp/pyclp.pyx":616
 *     if pyclp.ec_get_list(in_pword,&head,&tail)== pyclp.PSUCCEED or pyclp.ec_get_nil(in_pword) == pyclp.PSUCCEED:
 *         result=PList(None)
 *         (<PList>result).set_pword(in_pword)             # <<<<<<<<<<<<<<
 *     elif pyclp.ec_get_functor(in_pword,&dummy_dident)== pyclp.PSUCCEED:
 *         result=Compound(None)
 */
    __pyx_t_4 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_PList *)((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_result)->__pyx_base.__pyx_vtab)->__pyx_base.set_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_result)), __pyx_v_in_pword); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 616, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":614
 *     #Check if it is a list.
 *     # List is before because a list is also a Compound term.
 *     if pyclp.ec_get_list(in_pword,&head,&tail)== pyclp.PSUCCEED or pyclp.ec_get_nil(in_pword) == pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=PList(None)
 *         (<PList>result).set_pword(in_pword)
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":617
 *         result=PList(None)
 *         (<PList>result).set_pword(in_pword)
 *     elif pyclp.ec_get_functor(in_pword,&dummy_dident)== pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=Compound(None)
 *         (<Compound>result).set_pword(in_pword)
 */
  __pyx_t_1 = ((ec_get_functor(__pyx_v_in_pword, (&__pyx_v_dummy_dident)) == PSUCCEED) != 0);
  if (__pyx_t_1) {

    /* "pyclp/pyclp.pyx":618
 *         (<PList>result).set_pword(in_pword)
 *     elif pyclp.ec_get_functor(in_pword,&dummy_dident)== pyclp.PSUCCEED:
 *         result=Compound(None)             # <<<<<<<<<<<<<<
 *         (<Compound>result).set_pword(in_pword)
 *     elif pyclp.ec_get_long(in_pword,&c_int)== pyclp.PSUCCEED:
 */
    __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Compound), __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 618, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_result = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "pyclp/pyclp.pyx":619
 *     elif pyclp.ec_get_functor(in_pword,&dummy_dident)== pyclp.PSUCCEED:
 *         result=Compound(None)
 *         (<Compound>result).set_pword(in_pword)             # <<<<<<<<<<<<<<
 *     elif pyclp.ec_get_long(in_pword,&c_int)== pyclp.PSUCCEED:
 *         result=c_int
 */
    __pyx_t_4 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Compound *)((struct __pyx_obj_5pyclp_5pyclp_Compound *)__pyx_v_result)->__pyx_base.__pyx_vtab)->__pyx_base.set_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)((struct __pyx_obj_5pyclp_5pyclp_Compound *)__pyx_v_result)), __pyx_v_in_pword); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 619, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":617
 *         result=PList(None)
 *         (<PList>result).set_pword(in_pword)
 *     elif pyclp.ec_get_functor(in_pword,&dummy_dident)== pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=Compound(None)
 *         (<Compound>result).set_pword(in_pword)
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":620
 *         result=Compound(None)
 *         (<Compound>result).set_pword(in_pword)
 *     elif pyclp.ec_get_long(in_pword,&c_int)== pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=c_int
 *     # Check for Atom
 */
  __pyx_t_1 = ((ec_get_long(__pyx_v_in_pword, (&__pyx_v_c_int)) == PSUCCEED) != 0);
  if (__pyx_t_1) {

    /* "pyclp/pyclp.pyx":621
 *         (<Compound>result).set_pword(in_pword)
 *     elif pyclp.ec_get_long(in_pword,&c_int)== pyclp.PSUCCEED:
 *         result=c_int             # <<<<<<<<<<<<<<
 *     # Check for Atom
 *     elif pyclp.ec_get_atom(in_pword,&dummy_dident)== pyclp.PSUCCEED:
 */
    __pyx_t_3 = __Pyx_PyInt_From_long(__pyx_v_c_int); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 621, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_result = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "pyclp/pyclp.pyx":620
 *         result=Compound(None)
 *         (<Compound>result).set_pword(in_pword)
 *     elif pyclp.ec_get_long(in_pword,&c_int)== pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=c_int
 *     # Check for Atom
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":623
 *         result=c_int
 *     # Check for Atom
 *     elif pyclp.ec_get_atom(in_pword,&dummy_dident)== pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=Atom(None)
 *         (<Atom>result).set_pword(in_pword)
 */
  __pyx_t_1 = ((ec_get_atom(__pyx_v_in_pword, (&__pyx_v_dummy_dident)) == PSUCCEED) != 0);
  if (__pyx_t_1) {

    /* "pyclp/pyclp.pyx":624
 *     # Check for Atom
 *     elif pyclp.ec_get_atom(in_pword,&dummy_dident)== pyclp.PSUCCEED:
 *         result=Atom(None)             # <<<<<<<<<<<<<<
 *         (<Atom>result).set_pword(in_pword)
 *     elif ec_get_string_length(in_pword,&c_string,&length)==pyclp.PSUCCEED:
 */
    __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Atom), __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 624, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_result = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "pyclp/pyclp.pyx":625
 *     elif pyclp.ec_get_atom(in_pword,&dummy_dident)== pyclp.PSUCCEED:
 *         result=Atom(None)
 *         (<Atom>result).set_pword(in_pword)             # <<<<<<<<<<<<<<
 *     elif ec_get_string_length(in_pword,&c_string,&length)==pyclp.PSUCCEED:
 *         result=tounicode_with_length(c_string,length)
 */
    __pyx_t_4 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Atom *)((struct __pyx_obj_5pyclp_5pyclp_Atom *)__pyx_v_result)->__pyx_base.__pyx_vtab)->__pyx_base.set_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)((struct __pyx_obj_5pyclp_5pyclp_Atom *)__pyx_v_result)), __pyx_v_in_pword); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 625, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":623
 *         result=c_int
 *     # Check for Atom
 *     elif pyclp.ec_get_atom(in_pword,&dummy_dident)== pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=Atom(None)
 *         (<Atom>result).set_pword(in_pword)
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":626
 *         result=Atom(None)
 *         (<Atom>result).set_pword(in_pword)
 *     elif ec_get_string_length(in_pword,&c_string,&length)==pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=tounicode_with_length(c_string,length)
 *     elif pyclp.ec_get_double(in_pword,&c_double)== pyclp.PSUCCEED:
 */
  __pyx_t_1 = ((ec_get_string_length(__pyx_v_in_pword, (&__pyx_v_c_string), (&__pyx_v_length)) == PSUCCEED) != 0);
  if (__pyx_t_1) {

    /* "pyclp/pyclp.pyx":627
 *         (<Atom>result).set_pword(in_pword)
 *     elif ec_get_string_length(in_pword,&c_string,&length)==pyclp.PSUCCEED:
 *         result=tounicode_with_length(c_string,length)             # <<<<<<<<<<<<<<
 *     elif pyclp.ec_get_double(in_pword,&c_double)== pyclp.PSUCCEED:
 *         result=c_double
 */
    __pyx_t_3 = __pyx_f_5pyclp_5pyclp_tounicode_with_length(__pyx_v_c_string, __pyx_v_length); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 627, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_result = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "pyclp/pyclp.pyx":626
 *         result=Atom(None)
 *         (<Atom>result).set_pword(in_pword)
 *     elif ec_get_string_length(in_pword,&c_string,&length)==pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=tounicode_with_length(c_string,length)
 *     elif pyclp.ec_get_double(in_pword,&c_double)== pyclp.PSUCCEED:
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":628
 *     elif ec_get_string_length(in_pword,&c_string,&length)==pyclp.PSUCCEED:
 *         result=tounicode_with_length(c_string,length)
 *     elif pyclp.ec_get_double(in_pword,&c_double)== pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=c_double
 *     elif pyclp.ec_is_var(in_pword)== pyclp.PSUCCEED:
 */
  __pyx_t_1 = ((ec_get_double(__pyx_v_in_pword, (&__pyx_v_c_double)) == PSUCCEED) != 0);
  if (__pyx_t_1) {

    /* "pyclp/pyclp.pyx":629
 *         result=tounicode_with_length(c_string,length)
 *     elif pyclp.ec_get_double(in_pword,&c_double)== pyclp.PSUCCEED:
 *         result=c_double             # <<<<<<<<<<<<<<
 *     elif pyclp.ec_is_var(in_pword)== pyclp.PSUCCEED:
 *         result=Var()
 */
    __pyx_t_3 = PyFloat_FromDouble(__pyx_v_c_double); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 629, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_result = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "pyclp/pyclp.pyx":628
 *     elif ec_get_string_length(in_pword,&c_string,&length)==pyclp.PSUCCEED:
 *         result=tounicode_with_length(c_string,length)
 *     elif pyclp.ec_get_double(in_pword,&c_double)== pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=c_double
 *     elif pyclp.ec_is_var(in_pword)== pyclp.PSUCCEED:
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":630
 *     elif pyclp.ec_get_double(in_pword,&c_double)== pyclp.PSUCCEED:
 *         result=c_double
 *     elif pyclp.ec_is_var(in_pword)== pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=Var()
 *         (<Var>result).set_pword(in_pword)
 */
  __pyx_t_1 = ((ec_is_var(__pyx_v_in_pword) == PSUCCEED) != 0);
  if (likely(__pyx_t_1)) {

    /* "pyclp/pyclp.pyx":631
 *         result=c_double
 *     elif pyclp.ec_is_var(in_pword)== pyclp.PSUCCEED:
 *         result=Var()             # <<<<<<<<<<<<<<
 *         (<Var>result).set_pword(in_pword)
 *     else:
 */
    __pyx_t_3 = __Pyx_PyObject_CallNoArg(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Var)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 631, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_result = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "pyclp/pyclp.pyx":632
 *     elif pyclp.ec_is_var(in_pword)== pyclp.PSUCCEED:
 *         result=Var()
 *         (<Var>result).set_pword(in_pword)             # <<<<<<<<<<<<<<
 *     else:
 *         raise pyclpEx("Unknown type returned by eclipse")
 */
    __pyx_t_4 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Var *)((struct __pyx_obj_5pyclp_5pyclp_Var *)__pyx_v_result)->__pyx_base.__pyx_vtab)->__pyx_base.set_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)((struct __pyx_obj_5pyclp_5pyclp_Var *)__pyx_v_result)), __pyx_v_in_pword); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 632, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":630
 *     elif pyclp.ec_get_double(in_pword,&c_double)== pyclp.PSUCCEED:
 *         result=c_double
 *     elif pyclp.ec_is_var(in_pword)== pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *         result=Var()
 *         (<Var>result).set_pword(in_pword)
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":634
 *         (<Var>result).set_pword(in_pword)
 *     else:
 *         raise pyclpEx("Unknown type returned by eclipse")             # <<<<<<<<<<<<<<
 *     return result
 * 
 */
  /*else*/ {
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 634, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_3 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_kp_s_Unknown_type_returned_by_eclipse) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_Unknown_type_returned_by_eclipse);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 634, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 634, __pyx_L1_error)
  }
  __pyx_L3:;

  /* "pyclp/pyclp.pyx":635
 *     else:
 *         raise pyclpEx("Unknown type returned by eclipse")
 *     return result             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_result);
  __pyx_r = __pyx_v_result;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":604
 * 
 * 
 * cdef object pword2object(pyclp.pword in_pword):             # <<<<<<<<<<<<<<
 *     cdef pyclp.dident dummy_dident
 *     cdef char* c_string = NULL
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("pyclp.pyclp.pword2object", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_result);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":647
 *     """
 *     cdef pyclp.dident ec_dict_ptr
 *     def __init__(self,string):             # <<<<<<<<<<<<<<
 *         cdef char* c_string
 *         Term.__init__(self,None)
 */

/* Python wrapper */
static int __pyx_pw_5pyclp_5pyclp_4Atom_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pyclp_5pyclp_4Atom_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_string = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_string,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_string)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 647, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_string = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 647, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.Atom.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_4Atom___init__(((struct __pyx_obj_5pyclp_5pyclp_Atom *)__pyx_v_self), __pyx_v_string);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pyclp_5pyclp_4Atom___init__(struct __pyx_obj_5pyclp_5pyclp_Atom *__pyx_v_self, PyObject *__pyx_v_string) {
  char *__pyx_v_c_string;
  PyObject *__pyx_v_py_byte_string = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  char *__pyx_t_8;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "pyclp/pyclp.pyx":649
 *     def __init__(self,string):
 *         cdef char* c_string
 *         Term.__init__(self,None)             # <<<<<<<<<<<<<<
 *         if string is not None:
 *             if not isinstance(string,str):
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Term), __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 649, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  __pyx_t_4 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_4 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, ((PyObject *)__pyx_v_self), Py_None};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 649, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, ((PyObject *)__pyx_v_self), Py_None};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 649, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 649, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (__pyx_t_3) {
      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
    }
    __Pyx_INCREF(((PyObject *)__pyx_v_self));
    __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, ((PyObject *)__pyx_v_self));
    __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(Py_None);
    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, Py_None);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 649, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":650
 *         cdef char* c_string
 *         Term.__init__(self,None)
 *         if string is not None:             # <<<<<<<<<<<<<<
 *             if not isinstance(string,str):
 *                 raise TypeError("Atom constructor accept only string")
 */
  __pyx_t_6 = (__pyx_v_string != Py_None);
  __pyx_t_7 = (__pyx_t_6 != 0);
  if (__pyx_t_7) {

    /* "pyclp/pyclp.pyx":651
 *         Term.__init__(self,None)
 *         if string is not None:
 *             if not isinstance(string,str):             # <<<<<<<<<<<<<<
 *                 raise TypeError("Atom constructor accept only string")
 *             #Convert to byte array
 */
    __pyx_t_7 = PyString_Check(__pyx_v_string); 
    __pyx_t_6 = ((!(__pyx_t_7 != 0)) != 0);
    if (unlikely(__pyx_t_6)) {

      /* "pyclp/pyclp.pyx":652
 *         if string is not None:
 *             if not isinstance(string,str):
 *                 raise TypeError("Atom constructor accept only string")             # <<<<<<<<<<<<<<
 *             #Convert to byte array
 *             py_byte_string = tobytes(string)
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 652, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 652, __pyx_L1_error)

      /* "pyclp/pyclp.pyx":651
 *         Term.__init__(self,None)
 *         if string is not None:
 *             if not isinstance(string,str):             # <<<<<<<<<<<<<<
 *                 raise TypeError("Atom constructor accept only string")
 *             #Convert to byte array
 */
    }

    /* "pyclp/pyclp.pyx":654
 *                 raise TypeError("Atom constructor accept only string")
 *             #Convert to byte array
 *             py_byte_string = tobytes(string)             # <<<<<<<<<<<<<<
 *             c_string = py_byte_string
 *             # Create dictionary entry
 */
    __pyx_t_1 = __pyx_f_5pyclp_5pyclp_tobytes(__pyx_v_string); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 654, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_v_py_byte_string = ((PyObject*)__pyx_t_1);
    __pyx_t_1 = 0;

    /* "pyclp/pyclp.pyx":655
 *             #Convert to byte array
 *             py_byte_string = tobytes(string)
 *             c_string = py_byte_string             # <<<<<<<<<<<<<<
 *             # Create dictionary entry
 *             self.ec_dict_ptr=pyclp.ec_did(c_string,0)
 */
    if (unlikely(__pyx_v_py_byte_string == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
      __PYX_ERR(0, 655, __pyx_L1_error)
    }
    __pyx_t_8 = __Pyx_PyBytes_AsWritableString(__pyx_v_py_byte_string); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) __PYX_ERR(0, 655, __pyx_L1_error)
    __pyx_v_c_string = __pyx_t_8;

    /* "pyclp/pyclp.pyx":657
 *             c_string = py_byte_string
 *             # Create dictionary entry
 *             self.ec_dict_ptr=pyclp.ec_did(c_string,0)             # <<<<<<<<<<<<<<
 *             # Convert to atom pword and store in Term
 *             self.set_pword(pyclp.ec_atom(self.ec_dict_ptr))
 */
    __pyx_v_self->ec_dict_ptr = ec_did(__pyx_v_c_string, 0);

    /* "pyclp/pyclp.pyx":659
 *             self.ec_dict_ptr=pyclp.ec_did(c_string,0)
 *             # Convert to atom pword and store in Term
 *             self.set_pword(pyclp.ec_atom(self.ec_dict_ptr))             # <<<<<<<<<<<<<<
 * 
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:
 */
    __pyx_t_4 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Atom *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.set_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self), ec_atom(__pyx_v_self->ec_dict_ptr)); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 659, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":650
 *         cdef char* c_string
 *         Term.__init__(self,None)
 *         if string is not None:             # <<<<<<<<<<<<<<
 *             if not isinstance(string,str):
 *                 raise TypeError("Atom constructor accept only string")
 */
  }

  /* "pyclp/pyclp.pyx":647
 *     """
 *     cdef pyclp.dident ec_dict_ptr
 *     def __init__(self,string):             # <<<<<<<<<<<<<<
 *         cdef char* c_string
 *         Term.__init__(self,None)
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pyclp.pyclp.Atom.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_py_byte_string);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":661
 *             self.set_pword(pyclp.ec_atom(self.ec_dict_ptr))
 * 
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:             # <<<<<<<<<<<<<<
 *         """Override Term.set_pword to get
 *         """
 */

static int __pyx_f_5pyclp_5pyclp_4Atom_set_pword(struct __pyx_obj_5pyclp_5pyclp_Atom *__pyx_v_self, pword __pyx_v_in_pword) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("set_pword", 0);

  /* "pyclp/pyclp.pyx":664
 *         """Override Term.set_pword to get
 *         """
 *         Term.set_pword(self,in_pword)             # <<<<<<<<<<<<<<
 *         # Get dictionary entry and store. This required when
 *         # retrieving the result of a query.
 */
  __pyx_t_1 = __pyx_f_5pyclp_5pyclp_4Term_set_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self), __pyx_v_in_pword); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 664, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":667
 *         # Get dictionary entry and store. This required when
 *         # retrieving the result of a query.
 *         if ec_get_atom(self.get_pword(),&(self.ec_dict_ptr)) != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             raise pyclpEx("Failed retrieving of Atom dictionary item")
 * 
 */
  __pyx_t_2 = ((ec_get_atom(((struct __pyx_vtabstruct_5pyclp_5pyclp_Atom *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self)), (&__pyx_v_self->ec_dict_ptr)) != PSUCCEED) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "pyclp/pyclp.pyx":668
 *         # retrieving the result of a query.
 *         if ec_get_atom(self.get_pword(),&(self.ec_dict_ptr)) != pyclp.PSUCCEED:
 *             raise pyclpEx("Failed retrieving of Atom dictionary item")             # <<<<<<<<<<<<<<
 * 
 *     def __str__(self):
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 668, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_kp_s_Failed_retrieving_of_Atom_dictio) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_kp_s_Failed_retrieving_of_Atom_dictio);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 668, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 668, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":667
 *         # Get dictionary entry and store. This required when
 *         # retrieving the result of a query.
 *         if ec_get_atom(self.get_pword(),&(self.ec_dict_ptr)) != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             raise pyclpEx("Failed retrieving of Atom dictionary item")
 * 
 */
  }

  /* "pyclp/pyclp.pyx":661
 *             self.set_pword(pyclp.ec_atom(self.ec_dict_ptr))
 * 
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:             # <<<<<<<<<<<<<<
 *         """Override Term.set_pword to get
 *         """
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pyclp.pyclp.Atom.set_pword", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":670
 *             raise pyclpEx("Failed retrieving of Atom dictionary item")
 * 
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         """
 *         Convert to string for pretty printing
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_4Atom_3__str__(PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_4Atom_2__str__[] = "\n        Convert to string for pretty printing\n        ";
#if CYTHON_UPDATE_DESCRIPTOR_DOC
struct wrapperbase __pyx_wrapperbase_5pyclp_5pyclp_4Atom_2__str__;
#endif
static PyObject *__pyx_pw_5pyclp_5pyclp_4Atom_3__str__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__str__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_4Atom_2__str__(((struct __pyx_obj_5pyclp_5pyclp_Atom *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_4Atom_2__str__(struct __pyx_obj_5pyclp_5pyclp_Atom *__pyx_v_self) {
  char *__pyx_v_Name;
  PyObject *__pyx_v_string = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__str__", 0);

  /* "pyclp/pyclp.pyx":675
 *         """
 *         cdef char* Name
 *         Name=DidName(self.ec_dict_ptr)             # <<<<<<<<<<<<<<
 *         string=tounicode(Name)
 *         return string
 */
  __pyx_v_Name = DidName(__pyx_v_self->ec_dict_ptr);

  /* "pyclp/pyclp.pyx":676
 *         cdef char* Name
 *         Name=DidName(self.ec_dict_ptr)
 *         string=tounicode(Name)             # <<<<<<<<<<<<<<
 *         return string
 * 
 */
  __pyx_t_1 = __pyx_f_5pyclp_5pyclp_tounicode(__pyx_v_Name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 676, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_string = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":677
 *         Name=DidName(self.ec_dict_ptr)
 *         string=tounicode(Name)
 *         return string             # <<<<<<<<<<<<<<
 * 
 * cdef class PList(Term):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_string);
  __pyx_r = __pyx_v_string;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":670
 *             raise pyclpEx("Failed retrieving of Atom dictionary item")
 * 
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         """
 *         Convert to string for pretty printing
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Atom.__str__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_string);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_4Atom_5__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_4Atom_5__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_4Atom_4__reduce_cython__(((struct __pyx_obj_5pyclp_5pyclp_Atom *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_4Atom_4__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Atom *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Atom.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_4Atom_7__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_4Atom_7__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_4Atom_6__setstate_cython__(((struct __pyx_obj_5pyclp_5pyclp_Atom *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_4Atom_6__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Atom *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Atom.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":732
 * 
 *     """
 *     def __init__(self,in_list,tail=[]):             # <<<<<<<<<<<<<<
 *         cdef int list_lenght
 *         cdef int index
 */

/* Python wrapper */
static int __pyx_pw_5pyclp_5pyclp_5PList_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pyclp_5pyclp_5PList_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_in_list = 0;
  PyObject *__pyx_v_tail = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_in_list,&__pyx_n_s_tail,0};
    PyObject* values[2] = {0,0};
    values[1] = __pyx_k__19;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_in_list)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_tail);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 732, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_in_list = values[0];
    __pyx_v_tail = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 732, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.PList.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_5PList___init__(((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_self), __pyx_v_in_list, __pyx_v_tail);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pyclp_5pyclp_5PList___init__(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self, PyObject *__pyx_v_in_list, PyObject *__pyx_v_tail) {
  int __pyx_v_list_lenght;
  int __pyx_v_index;
  pword __pyx_v_tail_pword;
  struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_term_item = 0;
  CYTHON_UNUSED PyObject *__pyx_v_item = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  Py_ssize_t __pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "pyclp/pyclp.pyx":737
 *         cdef pyclp.pword tail_pword
 *         cdef Term term_item
 *         Term.__init__(self,None)             # <<<<<<<<<<<<<<
 *         if in_list is not None:
 *             if not( isinstance(in_list,list) or isinstance(in_list,tuple)):
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Term), __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 737, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  __pyx_t_4 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_4 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, ((PyObject *)__pyx_v_self), Py_None};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 737, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, ((PyObject *)__pyx_v_self), Py_None};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 737, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 737, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (__pyx_t_3) {
      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
    }
    __Pyx_INCREF(((PyObject *)__pyx_v_self));
    __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, ((PyObject *)__pyx_v_self));
    __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(Py_None);
    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, Py_None);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 737, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":738
 *         cdef Term term_item
 *         Term.__init__(self,None)
 *         if in_list is not None:             # <<<<<<<<<<<<<<
 *             if not( isinstance(in_list,list) or isinstance(in_list,tuple)):
 *                 raise TypeError("PList constructor accept only list or tuple")
 */
  __pyx_t_6 = (__pyx_v_in_list != Py_None);
  __pyx_t_7 = (__pyx_t_6 != 0);
  if (__pyx_t_7) {

    /* "pyclp/pyclp.pyx":739
 *         Term.__init__(self,None)
 *         if in_list is not None:
 *             if not( isinstance(in_list,list) or isinstance(in_list,tuple)):             # <<<<<<<<<<<<<<
 *                 raise TypeError("PList constructor accept only list or tuple")
 *             if not(isinstance(tail,list) or isinstance(tail,Term)):
 */
    __pyx_t_6 = PyList_Check(__pyx_v_in_list); 
    __pyx_t_8 = (__pyx_t_6 != 0);
    if (!__pyx_t_8) {
    } else {
      __pyx_t_7 = __pyx_t_8;
      goto __pyx_L5_bool_binop_done;
    }
    __pyx_t_8 = PyTuple_Check(__pyx_v_in_list); 
    __pyx_t_6 = (__pyx_t_8 != 0);
    __pyx_t_7 = __pyx_t_6;
    __pyx_L5_bool_binop_done:;
    __pyx_t_6 = ((!__pyx_t_7) != 0);
    if (unlikely(__pyx_t_6)) {

      /* "pyclp/pyclp.pyx":740
 *         if in_list is not None:
 *             if not( isinstance(in_list,list) or isinstance(in_list,tuple)):
 *                 raise TypeError("PList constructor accept only list or tuple")             # <<<<<<<<<<<<<<
 *             if not(isinstance(tail,list) or isinstance(tail,Term)):
 *                 raise TypeError("PList tail shall be a list or a Term")
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 740, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 740, __pyx_L1_error)

      /* "pyclp/pyclp.pyx":739
 *         Term.__init__(self,None)
 *         if in_list is not None:
 *             if not( isinstance(in_list,list) or isinstance(in_list,tuple)):             # <<<<<<<<<<<<<<
 *                 raise TypeError("PList constructor accept only list or tuple")
 *             if not(isinstance(tail,list) or isinstance(tail,Term)):
 */
    }

    /* "pyclp/pyclp.pyx":741
 *             if not( isinstance(in_list,list) or isinstance(in_list,tuple)):
 *                 raise TypeError("PList constructor accept only list or tuple")
 *             if not(isinstance(tail,list) or isinstance(tail,Term)):             # <<<<<<<<<<<<<<
 *                 raise TypeError("PList tail shall be a list or a Term")
 *             list_lenght=len(in_list)
 */
    __pyx_t_7 = PyList_Check(__pyx_v_tail); 
    __pyx_t_8 = (__pyx_t_7 != 0);
    if (!__pyx_t_8) {
    } else {
      __pyx_t_6 = __pyx_t_8;
      goto __pyx_L8_bool_binop_done;
    }
    __pyx_t_8 = __Pyx_TypeCheck(__pyx_v_tail, __pyx_ptype_5pyclp_5pyclp_Term); 
    __pyx_t_7 = (__pyx_t_8 != 0);
    __pyx_t_6 = __pyx_t_7;
    __pyx_L8_bool_binop_done:;
    __pyx_t_7 = ((!__pyx_t_6) != 0);
    if (unlikely(__pyx_t_7)) {

      /* "pyclp/pyclp.pyx":742
 *                 raise TypeError("PList constructor accept only list or tuple")
 *             if not(isinstance(tail,list) or isinstance(tail,Term)):
 *                 raise TypeError("PList tail shall be a list or a Term")             # <<<<<<<<<<<<<<
 *             list_lenght=len(in_list)
 *             # If lenght is 0 means an empty list --> []
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 742, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 742, __pyx_L1_error)

      /* "pyclp/pyclp.pyx":741
 *             if not( isinstance(in_list,list) or isinstance(in_list,tuple)):
 *                 raise TypeError("PList constructor accept only list or tuple")
 *             if not(isinstance(tail,list) or isinstance(tail,Term)):             # <<<<<<<<<<<<<<
 *                 raise TypeError("PList tail shall be a list or a Term")
 *             list_lenght=len(in_list)
 */
    }

    /* "pyclp/pyclp.pyx":743
 *             if not(isinstance(tail,list) or isinstance(tail,Term)):
 *                 raise TypeError("PList tail shall be a list or a Term")
 *             list_lenght=len(in_list)             # <<<<<<<<<<<<<<
 *             # If lenght is 0 means an empty list --> []
 *             if (list_lenght == 0):
 */
    __pyx_t_9 = PyObject_Length(__pyx_v_in_list); if (unlikely(__pyx_t_9 == ((Py_ssize_t)-1))) __PYX_ERR(0, 743, __pyx_L1_error)
    __pyx_v_list_lenght = __pyx_t_9;

    /* "pyclp/pyclp.pyx":745
 *             list_lenght=len(in_list)
 *             # If lenght is 0 means an empty list --> []
 *             if (list_lenght == 0):             # <<<<<<<<<<<<<<
 *                 tail_pword=pyclp.ec_nil()
 *             else:
 */
    __pyx_t_7 = ((__pyx_v_list_lenght == 0) != 0);
    if (__pyx_t_7) {

      /* "pyclp/pyclp.pyx":746
 *             # If lenght is 0 means an empty list --> []
 *             if (list_lenght == 0):
 *                 tail_pword=pyclp.ec_nil()             # <<<<<<<<<<<<<<
 *             else:
 *                 #Generate the starting tail for building the list
 */
      __pyx_v_tail_pword = ec_nil();

      /* "pyclp/pyclp.pyx":745
 *             list_lenght=len(in_list)
 *             # If lenght is 0 means an empty list --> []
 *             if (list_lenght == 0):             # <<<<<<<<<<<<<<
 *                 tail_pword=pyclp.ec_nil()
 *             else:
 */
      goto __pyx_L10;
    }

    /* "pyclp/pyclp.pyx":749
 *             else:
 *                 #Generate the starting tail for building the list
 *                 if isinstance(tail,list) or isinstance(tail,tuple):             # <<<<<<<<<<<<<<
 *                     if len(tail) == 0:
 *                         tail_pword=pyclp.ec_nil()
 */
    /*else*/ {
      __pyx_t_6 = PyList_Check(__pyx_v_tail); 
      __pyx_t_8 = (__pyx_t_6 != 0);
      if (!__pyx_t_8) {
      } else {
        __pyx_t_7 = __pyx_t_8;
        goto __pyx_L12_bool_binop_done;
      }
      __pyx_t_8 = PyTuple_Check(__pyx_v_tail); 
      __pyx_t_6 = (__pyx_t_8 != 0);
      __pyx_t_7 = __pyx_t_6;
      __pyx_L12_bool_binop_done:;
      if (__pyx_t_7) {

        /* "pyclp/pyclp.pyx":750
 *                 #Generate the starting tail for building the list
 *                 if isinstance(tail,list) or isinstance(tail,tuple):
 *                     if len(tail) == 0:             # <<<<<<<<<<<<<<
 *                         tail_pword=pyclp.ec_nil()
 *                     else:
 */
        __pyx_t_9 = PyObject_Length(__pyx_v_tail); if (unlikely(__pyx_t_9 == ((Py_ssize_t)-1))) __PYX_ERR(0, 750, __pyx_L1_error)
        __pyx_t_7 = ((__pyx_t_9 == 0) != 0);
        if (__pyx_t_7) {

          /* "pyclp/pyclp.pyx":751
 *                 if isinstance(tail,list) or isinstance(tail,tuple):
 *                     if len(tail) == 0:
 *                         tail_pword=pyclp.ec_nil()             # <<<<<<<<<<<<<<
 *                     else:
 *                         tail_pword=PList(tail).get_pword()
 */
          __pyx_v_tail_pword = ec_nil();

          /* "pyclp/pyclp.pyx":750
 *                 #Generate the starting tail for building the list
 *                 if isinstance(tail,list) or isinstance(tail,tuple):
 *                     if len(tail) == 0:             # <<<<<<<<<<<<<<
 *                         tail_pword=pyclp.ec_nil()
 *                     else:
 */
          goto __pyx_L14;
        }

        /* "pyclp/pyclp.pyx":753
 *                         tail_pword=pyclp.ec_nil()
 *                     else:
 *                         tail_pword=PList(tail).get_pword()             # <<<<<<<<<<<<<<
 *                 elif isinstance(tail,Term):
 *                         tail_pword=(<Term>tail).get_pword()
 */
        /*else*/ {
          __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_5pyclp_5pyclp_PList), __pyx_v_tail); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 753, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_v_tail_pword = ((struct __pyx_vtabstruct_5pyclp_5pyclp_PList *)((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_t_1)->__pyx_base.__pyx_vtab)->__pyx_base.get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_t_1));
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        }
        __pyx_L14:;

        /* "pyclp/pyclp.pyx":749
 *             else:
 *                 #Generate the starting tail for building the list
 *                 if isinstance(tail,list) or isinstance(tail,tuple):             # <<<<<<<<<<<<<<
 *                     if len(tail) == 0:
 *                         tail_pword=pyclp.ec_nil()
 */
        goto __pyx_L11;
      }

      /* "pyclp/pyclp.pyx":754
 *                     else:
 *                         tail_pword=PList(tail).get_pword()
 *                 elif isinstance(tail,Term):             # <<<<<<<<<<<<<<
 *                         tail_pword=(<Term>tail).get_pword()
 *                 else:
 */
      __pyx_t_7 = __Pyx_TypeCheck(__pyx_v_tail, __pyx_ptype_5pyclp_5pyclp_Term); 
      __pyx_t_6 = (__pyx_t_7 != 0);
      if (likely(__pyx_t_6)) {

        /* "pyclp/pyclp.pyx":755
 *                         tail_pword=PList(tail).get_pword()
 *                 elif isinstance(tail,Term):
 *                         tail_pword=(<Term>tail).get_pword()             # <<<<<<<<<<<<<<
 *                 else:
 *                     raise TypeError("PList tail shall be a list, tuple or  Term")
 */
        __pyx_v_tail_pword = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_tail)->__pyx_vtab)->get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_tail));

        /* "pyclp/pyclp.pyx":754
 *                     else:
 *                         tail_pword=PList(tail).get_pword()
 *                 elif isinstance(tail,Term):             # <<<<<<<<<<<<<<
 *                         tail_pword=(<Term>tail).get_pword()
 *                 else:
 */
        goto __pyx_L11;
      }

      /* "pyclp/pyclp.pyx":757
 *                         tail_pword=(<Term>tail).get_pword()
 *                 else:
 *                     raise TypeError("PList tail shall be a list, tuple or  Term")             # <<<<<<<<<<<<<<
 *                 #Convert not Term arguments
 *                 for index in range(list_lenght-1,-1,-1):
 */
      /*else*/ {
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 757, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_Raise(__pyx_t_1, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __PYX_ERR(0, 757, __pyx_L1_error)
      }
      __pyx_L11:;

      /* "pyclp/pyclp.pyx":759
 *                     raise TypeError("PList tail shall be a list, tuple or  Term")
 *                 #Convert not Term arguments
 *                 for index in range(list_lenght-1,-1,-1):             # <<<<<<<<<<<<<<
 *                     item=in_list[index]
 *                     if isinstance(in_list[index],Term):
 */
      for (__pyx_t_4 = (__pyx_v_list_lenght - 1); __pyx_t_4 > -1; __pyx_t_4-=1) {
        __pyx_v_index = __pyx_t_4;

        /* "pyclp/pyclp.pyx":760
 *                 #Convert not Term arguments
 *                 for index in range(list_lenght-1,-1,-1):
 *                     item=in_list[index]             # <<<<<<<<<<<<<<
 *                     if isinstance(in_list[index],Term):
 *                         term_item= in_list[index]
 */
        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_in_list, __pyx_v_index, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 760, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_1);
        __pyx_t_1 = 0;

        /* "pyclp/pyclp.pyx":761
 *                 for index in range(list_lenght-1,-1,-1):
 *                     item=in_list[index]
 *                     if isinstance(in_list[index],Term):             # <<<<<<<<<<<<<<
 *                         term_item= in_list[index]
 *                     #This to allow the coversion of nested lists.
 */
        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_in_list, __pyx_v_index, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 761, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_6 = __Pyx_TypeCheck(__pyx_t_1, __pyx_ptype_5pyclp_5pyclp_Term); 
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_t_7 = (__pyx_t_6 != 0);
        if (__pyx_t_7) {

          /* "pyclp/pyclp.pyx":762
 *                     item=in_list[index]
 *                     if isinstance(in_list[index],Term):
 *                         term_item= in_list[index]             # <<<<<<<<<<<<<<
 *                     #This to allow the coversion of nested lists.
 *                     elif isinstance(in_list[index],list) or isinstance(in_list[index],tuple):
 */
          __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_in_list, __pyx_v_index, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 762, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5pyclp_5pyclp_Term))))) __PYX_ERR(0, 762, __pyx_L1_error)
          __Pyx_XDECREF_SET(__pyx_v_term_item, ((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_t_1));
          __pyx_t_1 = 0;

          /* "pyclp/pyclp.pyx":761
 *                 for index in range(list_lenght-1,-1,-1):
 *                     item=in_list[index]
 *                     if isinstance(in_list[index],Term):             # <<<<<<<<<<<<<<
 *                         term_item= in_list[index]
 *                     #This to allow the coversion of nested lists.
 */
          goto __pyx_L17;
        }

        /* "pyclp/pyclp.pyx":764
 *                         term_item= in_list[index]
 *                     #This to allow the coversion of nested lists.
 *                     elif isinstance(in_list[index],list) or isinstance(in_list[index],tuple):             # <<<<<<<<<<<<<<
 *                         term_item=PList(in_list[index])
 *                     else:
 */
        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_in_list, __pyx_v_index, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 764, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_6 = PyList_Check(__pyx_t_1); 
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_t_8 = (__pyx_t_6 != 0);
        if (!__pyx_t_8) {
        } else {
          __pyx_t_7 = __pyx_t_8;
          goto __pyx_L18_bool_binop_done;
        }
        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_in_list, __pyx_v_index, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 764, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_8 = PyTuple_Check(__pyx_t_1); 
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_t_6 = (__pyx_t_8 != 0);
        __pyx_t_7 = __pyx_t_6;
        __pyx_L18_bool_binop_done:;
        if (__pyx_t_7) {

          /* "pyclp/pyclp.pyx":765
 *                     #This to allow the coversion of nested lists.
 *                     elif isinstance(in_list[index],list) or isinstance(in_list[index],tuple):
 *                         term_item=PList(in_list[index])             # <<<<<<<<<<<<<<
 *                     else:
 *                         term_item=Term(in_list[index])
 */
          __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_in_list, __pyx_v_index, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 765, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_5pyclp_5pyclp_PList), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 765, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          __Pyx_XDECREF_SET(__pyx_v_term_item, ((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_t_2));
          __pyx_t_2 = 0;

          /* "pyclp/pyclp.pyx":764
 *                         term_item= in_list[index]
 *                     #This to allow the coversion of nested lists.
 *                     elif isinstance(in_list[index],list) or isinstance(in_list[index],tuple):             # <<<<<<<<<<<<<<
 *                         term_item=PList(in_list[index])
 *                     else:
 */
          goto __pyx_L17;
        }

        /* "pyclp/pyclp.pyx":767
 *                         term_item=PList(in_list[index])
 *                     else:
 *                         term_item=Term(in_list[index])             # <<<<<<<<<<<<<<
 *                     tail_pword=pyclp.ec_list(term_item.get_pword(),tail_pword)
 *             self.ref.set(tail_pword)
 */
        /*else*/ {
          __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_in_list, __pyx_v_index, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 767, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Term), __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 767, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          __Pyx_XDECREF_SET(__pyx_v_term_item, ((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_t_1));
          __pyx_t_1 = 0;
        }
        __pyx_L17:;

        /* "pyclp/pyclp.pyx":768
 *                     else:
 *                         term_item=Term(in_list[index])
 *                     tail_pword=pyclp.ec_list(term_item.get_pword(),tail_pword)             # <<<<<<<<<<<<<<
 *             self.ref.set(tail_pword)
 * 
 */
        __pyx_v_tail_pword = ec_list(((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)__pyx_v_term_item->__pyx_vtab)->get_pword(__pyx_v_term_item), __pyx_v_tail_pword);
      }
    }
    __pyx_L10:;

    /* "pyclp/pyclp.pyx":769
 *                         term_item=Term(in_list[index])
 *                     tail_pword=pyclp.ec_list(term_item.get_pword(),tail_pword)
 *             self.ref.set(tail_pword)             # <<<<<<<<<<<<<<
 * 
 *     def head_generator(self):
 */
    ((struct __pyx_vtabstruct_5pyclp_5pyclp_Ref *)__pyx_v_self->__pyx_base.ref->__pyx_vtab)->set(__pyx_v_self->__pyx_base.ref, __pyx_v_tail_pword);

    /* "pyclp/pyclp.pyx":738
 *         cdef Term term_item
 *         Term.__init__(self,None)
 *         if in_list is not None:             # <<<<<<<<<<<<<<
 *             if not( isinstance(in_list,list) or isinstance(in_list,tuple)):
 *                 raise TypeError("PList constructor accept only list or tuple")
 */
  }

  /* "pyclp/pyclp.pyx":732
 * 
 *     """
 *     def __init__(self,in_list,tail=[]):             # <<<<<<<<<<<<<<
 *         cdef int list_lenght
 *         cdef int index
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pyclp.pyclp.PList.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_term_item);
  __Pyx_XDECREF(__pyx_v_item);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_5pyclp_5pyclp_5PList_4generator(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "pyclp/pyclp.pyx":771
 *             self.ref.set(tail_pword)
 * 
 *     def head_generator(self):             # <<<<<<<<<<<<<<
 *         cdef pyclp.pword tail
 *         cdef pyclp.pword head
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_3head_generator(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_3head_generator(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("head_generator (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_5PList_2head_generator(((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_2head_generator(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self) {
  struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("head_generator", 0);
  __pyx_cur_scope = (struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator *)__pyx_tp_new_5pyclp_5pyclp___pyx_scope_struct__head_generator(__pyx_ptype_5pyclp_5pyclp___pyx_scope_struct__head_generator, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 771, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_self = __pyx_v_self;
  __Pyx_INCREF((PyObject *)__pyx_cur_scope->__pyx_v_self);
  __Pyx_GIVEREF((PyObject *)__pyx_cur_scope->__pyx_v_self);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_5pyclp_5pyclp_5PList_4generator, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_head_generator, __pyx_n_s_PList_head_generator, __pyx_n_s_pyclp_pyclp); if (unlikely(!gen)) __PYX_ERR(0, 771, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyclp.pyclp.PList.head_generator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_5pyclp_5pyclp_5PList_4generator(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator *__pyx_cur_scope = ((struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("head_generator", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    case 1: goto __pyx_L7_resume_from_yield;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 771, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":774
 *         cdef pyclp.pword tail
 *         cdef pyclp.pword head
 *         tail=self.get_pword()             # <<<<<<<<<<<<<<
 *         while(1):
 *             res=pyclp.ec_get_list(tail,&head,&tail)
 */
  __pyx_cur_scope->__pyx_v_tail = ((struct __pyx_vtabstruct_5pyclp_5pyclp_PList *)__pyx_cur_scope->__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_cur_scope->__pyx_v_self));

  /* "pyclp/pyclp.pyx":775
 *         cdef pyclp.pword head
 *         tail=self.get_pword()
 *         while(1):             # <<<<<<<<<<<<<<
 *             res=pyclp.ec_get_list(tail,&head,&tail)
 *             if res == pyclp.PSUCCEED:
 */
  while (1) {

    /* "pyclp/pyclp.pyx":776
 *         tail=self.get_pword()
 *         while(1):
 *             res=pyclp.ec_get_list(tail,&head,&tail)             # <<<<<<<<<<<<<<
 *             if res == pyclp.PSUCCEED:
 *                 yield pword2object(head)
 */
    __pyx_cur_scope->__pyx_v_res = ec_get_list(__pyx_cur_scope->__pyx_v_tail, (&__pyx_cur_scope->__pyx_v_head), (&__pyx_cur_scope->__pyx_v_tail));

    /* "pyclp/pyclp.pyx":777
 *         while(1):
 *             res=pyclp.ec_get_list(tail,&head,&tail)
 *             if res == pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *                 yield pword2object(head)
 *             else:
 */
    __pyx_t_1 = ((__pyx_cur_scope->__pyx_v_res == PSUCCEED) != 0);
    if (__pyx_t_1) {

      /* "pyclp/pyclp.pyx":778
 *             res=pyclp.ec_get_list(tail,&head,&tail)
 *             if res == pyclp.PSUCCEED:
 *                 yield pword2object(head)             # <<<<<<<<<<<<<<
 *             else:
 *                 return
 */
      __pyx_t_2 = __pyx_f_5pyclp_5pyclp_pword2object(__pyx_cur_scope->__pyx_v_head); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 778, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_XGIVEREF(__pyx_r);
      __Pyx_RefNannyFinishContext();
      __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
      /* return from generator, yielding value */
      __pyx_generator->resume_label = 1;
      return __pyx_r;
      __pyx_L7_resume_from_yield:;
      if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 778, __pyx_L1_error)

      /* "pyclp/pyclp.pyx":777
 *         while(1):
 *             res=pyclp.ec_get_list(tail,&head,&tail)
 *             if res == pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *                 yield pword2object(head)
 *             else:
 */
      goto __pyx_L6;
    }

    /* "pyclp/pyclp.pyx":780
 *                 yield pword2object(head)
 *             else:
 *                 return             # <<<<<<<<<<<<<<
 *     def head_tail_generator(self):
 *         cdef pyclp.pword tail
 */
    /*else*/ {
      __Pyx_XDECREF(__pyx_r);
      __pyx_r = NULL;
      goto __pyx_L0;
    }
    __pyx_L6:;
  }
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* "pyclp/pyclp.pyx":771
 *             self.ref.set(tail_pword)
 * 
 *     def head_generator(self):             # <<<<<<<<<<<<<<
 *         cdef pyclp.pword tail
 *         cdef pyclp.pword head
 */

  /* function exit code */
  PyErr_SetNone(PyExc_StopIteration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("head_generator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_5pyclp_5pyclp_5PList_7generator1(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "pyclp/pyclp.pyx":781
 *             else:
 *                 return
 *     def head_tail_generator(self):             # <<<<<<<<<<<<<<
 *         cdef pyclp.pword tail
 *         cdef pyclp.pword head
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_6head_tail_generator(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_6head_tail_generator(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("head_tail_generator (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_5PList_5head_tail_generator(((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_5head_tail_generator(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self) {
  struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("head_tail_generator", 0);
  __pyx_cur_scope = (struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator *)__pyx_tp_new_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator(__pyx_ptype_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 781, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_self = __pyx_v_self;
  __Pyx_INCREF((PyObject *)__pyx_cur_scope->__pyx_v_self);
  __Pyx_GIVEREF((PyObject *)__pyx_cur_scope->__pyx_v_self);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_5pyclp_5pyclp_5PList_7generator1, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_head_tail_generator, __pyx_n_s_PList_head_tail_generator, __pyx_n_s_pyclp_pyclp); if (unlikely(!gen)) __PYX_ERR(0, 781, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyclp.pyclp.PList.head_tail_generator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_5pyclp_5pyclp_5PList_7generator1(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator *__pyx_cur_scope = ((struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("head_tail_generator", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    case 1: goto __pyx_L7_resume_from_yield;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 781, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":784
 *         cdef pyclp.pword tail
 *         cdef pyclp.pword head
 *         tail=self.get_pword()             # <<<<<<<<<<<<<<
 *         while(1):
 *             if pyclp.ec_get_list(tail,&head,&tail) != pyclp.PSUCCEED:
 */
  __pyx_cur_scope->__pyx_v_tail = ((struct __pyx_vtabstruct_5pyclp_5pyclp_PList *)__pyx_cur_scope->__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_cur_scope->__pyx_v_self));

  /* "pyclp/pyclp.pyx":785
 *         cdef pyclp.pword head
 *         tail=self.get_pword()
 *         while(1):             # <<<<<<<<<<<<<<
 *             if pyclp.ec_get_list(tail,&head,&tail) != pyclp.PSUCCEED:
 *                 return
 */
  while (1) {

    /* "pyclp/pyclp.pyx":786
 *         tail=self.get_pword()
 *         while(1):
 *             if pyclp.ec_get_list(tail,&head,&tail) != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *                 return
 *             yield (pword2object(head),pword2object(tail))
 */
    __pyx_t_1 = ((ec_get_list(__pyx_cur_scope->__pyx_v_tail, (&__pyx_cur_scope->__pyx_v_head), (&__pyx_cur_scope->__pyx_v_tail)) != PSUCCEED) != 0);
    if (__pyx_t_1) {

      /* "pyclp/pyclp.pyx":787
 *         while(1):
 *             if pyclp.ec_get_list(tail,&head,&tail) != pyclp.PSUCCEED:
 *                 return             # <<<<<<<<<<<<<<
 *             yield (pword2object(head),pword2object(tail))
 *     def __iter__(self):
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_r = NULL;
      goto __pyx_L0;

      /* "pyclp/pyclp.pyx":786
 *         tail=self.get_pword()
 *         while(1):
 *             if pyclp.ec_get_list(tail,&head,&tail) != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *                 return
 *             yield (pword2object(head),pword2object(tail))
 */
    }

    /* "pyclp/pyclp.pyx":788
 *             if pyclp.ec_get_list(tail,&head,&tail) != pyclp.PSUCCEED:
 *                 return
 *             yield (pword2object(head),pword2object(tail))             # <<<<<<<<<<<<<<
 *     def __iter__(self):
 *         return self.head_generator()
 */
    __pyx_t_2 = __pyx_f_5pyclp_5pyclp_pword2object(__pyx_cur_scope->__pyx_v_head); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 788, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __pyx_f_5pyclp_5pyclp_pword2object(__pyx_cur_scope->__pyx_v_tail); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 788, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 788, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_3);
    __pyx_t_2 = 0;
    __pyx_t_3 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    __Pyx_XGIVEREF(__pyx_r);
    __Pyx_RefNannyFinishContext();
    __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
    /* return from generator, yielding value */
    __pyx_generator->resume_label = 1;
    return __pyx_r;
    __pyx_L7_resume_from_yield:;
    if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 788, __pyx_L1_error)
  }
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* "pyclp/pyclp.pyx":781
 *             else:
 *                 return
 *     def head_tail_generator(self):             # <<<<<<<<<<<<<<
 *         cdef pyclp.pword tail
 *         cdef pyclp.pword head
 */

  /* function exit code */
  PyErr_SetNone(PyExc_StopIteration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("head_tail_generator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":789
 *                 return
 *             yield (pword2object(head),pword2object(tail))
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self.head_generator()
 *     def __len__(self):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_9__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_9__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_5PList_8__iter__(((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_8__iter__(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__iter__", 0);

  /* "pyclp/pyclp.pyx":790
 *             yield (pword2object(head),pword2object(tail))
 *     def __iter__(self):
 *         return self.head_generator()             # <<<<<<<<<<<<<<
 *     def __len__(self):
 *         cdef int index=0
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_head_generator); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 790, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 790, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":789
 *                 return
 *             yield (pword2object(head),pword2object(tail))
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self.head_generator()
 *     def __len__(self):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pyclp.pyclp.PList.__iter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":791
 *     def __iter__(self):
 *         return self.head_generator()
 *     def __len__(self):             # <<<<<<<<<<<<<<
 *         cdef int index=0
 *         for x in self:
 */

/* Python wrapper */
static Py_ssize_t __pyx_pw_5pyclp_5pyclp_5PList_11__len__(PyObject *__pyx_v_self); /*proto*/
static Py_ssize_t __pyx_pw_5pyclp_5pyclp_5PList_11__len__(PyObject *__pyx_v_self) {
  Py_ssize_t __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__len__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_5PList_10__len__(((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static Py_ssize_t __pyx_pf_5pyclp_5pyclp_5PList_10__len__(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self) {
  int __pyx_v_index;
  CYTHON_UNUSED PyObject *__pyx_v_x = NULL;
  Py_ssize_t __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__len__", 0);

  /* "pyclp/pyclp.pyx":792
 *         return self.head_generator()
 *     def __len__(self):
 *         cdef int index=0             # <<<<<<<<<<<<<<
 *         for x in self:
 *             index +=1
 */
  __pyx_v_index = 0;

  /* "pyclp/pyclp.pyx":793
 *     def __len__(self):
 *         cdef int index=0
 *         for x in self:             # <<<<<<<<<<<<<<
 *             index +=1
 *         return index
 */
  if (likely(PyList_CheckExact(((PyObject *)__pyx_v_self))) || PyTuple_CheckExact(((PyObject *)__pyx_v_self))) {
    __pyx_t_1 = ((PyObject *)__pyx_v_self); __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 793, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 793, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 793, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 793, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 793, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 793, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 793, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XDECREF_SET(__pyx_v_x, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "pyclp/pyclp.pyx":794
 *         cdef int index=0
 *         for x in self:
 *             index +=1             # <<<<<<<<<<<<<<
 *         return index
 *     def iterheadtail(self):
 */
    __pyx_v_index = (__pyx_v_index + 1);

    /* "pyclp/pyclp.pyx":793
 *     def __len__(self):
 *         cdef int index=0
 *         for x in self:             # <<<<<<<<<<<<<<
 *             index +=1
 *         return index
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":795
 *         for x in self:
 *             index +=1
 *         return index             # <<<<<<<<<<<<<<
 *     def iterheadtail(self):
 *         """
 */
  __pyx_r = __pyx_v_index;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":791
 *     def __iter__(self):
 *         return self.head_generator()
 *     def __len__(self):             # <<<<<<<<<<<<<<
 *         cdef int index=0
 *         for x in self:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pyclp.pyclp.PList.__len__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_x);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":796
 *             index +=1
 *         return index
 *     def iterheadtail(self):             # <<<<<<<<<<<<<<
 *         """
 *         .. deprecated:: 1.5
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_13iterheadtail(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_5PList_12iterheadtail[] = "\n        .. deprecated:: 1.5\n        \n        Replaced by :py:func:`PList.iterHeadTail`\n        ";
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_13iterheadtail(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("iterheadtail (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_5PList_12iterheadtail(((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_12iterheadtail(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("iterheadtail", 0);

  /* "pyclp/pyclp.pyx":802
 *         Replaced by :py:func:`PList.iterHeadTail`
 *         """
 *         return self.iterHeadTail()             # <<<<<<<<<<<<<<
 *     def iterHeadTail(self):
 *         """
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_iterHeadTail); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 802, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 802, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":796
 *             index +=1
 *         return index
 *     def iterheadtail(self):             # <<<<<<<<<<<<<<
 *         """
 *         .. deprecated:: 1.5
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pyclp.pyclp.PList.iterheadtail", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":803
 *         """
 *         return self.iterHeadTail()
 *     def iterHeadTail(self):             # <<<<<<<<<<<<<<
 *         """
 *         :returns: Iterator that returns a tuple (head,tail) where head is a element of the list and \
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_15iterHeadTail(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_5PList_14iterHeadTail[] = "\n        :returns: Iterator that returns a tuple (head,tail) where head is a element of the list and             tail is the remaining list\n            \n        ";
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_15iterHeadTail(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("iterHeadTail (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_5PList_14iterHeadTail(((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_14iterHeadTail(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("iterHeadTail", 0);

  /* "pyclp/pyclp.pyx":809
 * 
 *         """
 *         return self.head_tail_generator()             # <<<<<<<<<<<<<<
 * 
 *     cdef int get_head_tail(self,pyclp.pword *head_ptr,pyclp.pword *tail_ptr) except -1:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_head_tail_generator); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 809, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 809, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":803
 *         """
 *         return self.iterHeadTail()
 *     def iterHeadTail(self):             # <<<<<<<<<<<<<<
 *         """
 *         :returns: Iterator that returns a tuple (head,tail) where head is a element of the list and \
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pyclp.pyclp.PList.iterHeadTail", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":811
 *         return self.head_tail_generator()
 * 
 *     cdef int get_head_tail(self,pyclp.pword *head_ptr,pyclp.pword *tail_ptr) except -1:             # <<<<<<<<<<<<<<
 *         if pyclp.ec_get_list(tail_ptr[0],head_ptr,tail_ptr) != pyclp.PSUCCEED:
 *             raise IndexError("Argument index out of range")
 */

static int __pyx_f_5pyclp_5pyclp_5PList_get_head_tail(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self, pword *__pyx_v_head_ptr, pword *__pyx_v_tail_ptr) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("get_head_tail", 0);

  /* "pyclp/pyclp.pyx":812
 * 
 *     cdef int get_head_tail(self,pyclp.pword *head_ptr,pyclp.pword *tail_ptr) except -1:
 *         if pyclp.ec_get_list(tail_ptr[0],head_ptr,tail_ptr) != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             raise IndexError("Argument index out of range")
 *         return 1
 */
  __pyx_t_1 = ((ec_get_list((__pyx_v_tail_ptr[0]), __pyx_v_head_ptr, __pyx_v_tail_ptr) != PSUCCEED) != 0);
  if (unlikely(__pyx_t_1)) {

    /* "pyclp/pyclp.pyx":813
 *     cdef int get_head_tail(self,pyclp.pword *head_ptr,pyclp.pword *tail_ptr) except -1:
 *         if pyclp.ec_get_list(tail_ptr[0],head_ptr,tail_ptr) != pyclp.PSUCCEED:
 *             raise IndexError("Argument index out of range")             # <<<<<<<<<<<<<<
 *         return 1
 * 
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_IndexError, __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 813, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 813, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":812
 * 
 *     cdef int get_head_tail(self,pyclp.pword *head_ptr,pyclp.pword *tail_ptr) except -1:
 *         if pyclp.ec_get_list(tail_ptr[0],head_ptr,tail_ptr) != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             raise IndexError("Argument index out of range")
 *         return 1
 */
  }

  /* "pyclp/pyclp.pyx":814
 *         if pyclp.ec_get_list(tail_ptr[0],head_ptr,tail_ptr) != pyclp.PSUCCEED:
 *             raise IndexError("Argument index out of range")
 *         return 1             # <<<<<<<<<<<<<<
 * 
 *     def __getitem__(self,index):
 */
  __pyx_r = 1;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":811
 *         return self.head_tail_generator()
 * 
 *     cdef int get_head_tail(self,pyclp.pword *head_ptr,pyclp.pword *tail_ptr) except -1:             # <<<<<<<<<<<<<<
 *         if pyclp.ec_get_list(tail_ptr[0],head_ptr,tail_ptr) != pyclp.PSUCCEED:
 *             raise IndexError("Argument index out of range")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pyclp.pyclp.PList.get_head_tail", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":816
 *         return 1
 * 
 *     def __getitem__(self,index):             # <<<<<<<<<<<<<<
 *         """Implement python list protocol
 *         """
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_17__getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_5PList_16__getitem__[] = "Implement python list protocol\n        ";
#if CYTHON_UPDATE_DESCRIPTOR_DOC
struct wrapperbase __pyx_wrapperbase_5pyclp_5pyclp_5PList_16__getitem__;
#endif
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_17__getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__getitem__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_5PList_16__getitem__(((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_self), ((PyObject *)__pyx_v_index));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_16__getitem__(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self, PyObject *__pyx_v_index) {
  pword __pyx_v_tail;
  pword __pyx_v_head;
  pword *__pyx_v_array_pword;
  int __pyx_v_c_index;
  int __pyx_v_c_k;
  PyObject *__pyx_v_result = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  long __pyx_t_12;
  PyObject *__pyx_t_13 = NULL;
  char const *__pyx_t_14;
  PyObject *__pyx_t_15 = NULL;
  PyObject *__pyx_t_16 = NULL;
  PyObject *__pyx_t_17 = NULL;
  long __pyx_t_18;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__getitem__", 0);

  /* "pyclp/pyclp.pyx":823
 *         cdef pyclp.pword *array_pword
 *         cdef int c_index
 *         cdef int c_k=0             # <<<<<<<<<<<<<<
 * 
 *         c_index=<int?>index
 */
  __pyx_v_c_k = 0;

  /* "pyclp/pyclp.pyx":825
 *         cdef int c_k=0
 * 
 *         c_index=<int?>index             # <<<<<<<<<<<<<<
 *         tail=self.get_pword()
 *         if c_index < 0:
 */
  __pyx_t_1 = __Pyx_PyInt_As_int(__pyx_v_index); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 825, __pyx_L1_error)
  __pyx_v_c_index = ((int)__pyx_t_1);

  /* "pyclp/pyclp.pyx":826
 * 
 *         c_index=<int?>index
 *         tail=self.get_pword()             # <<<<<<<<<<<<<<
 *         if c_index < 0:
 *             c_index=abs(c_index)
 */
  __pyx_v_tail = ((struct __pyx_vtabstruct_5pyclp_5pyclp_PList *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self));

  /* "pyclp/pyclp.pyx":827
 *         c_index=<int?>index
 *         tail=self.get_pword()
 *         if c_index < 0:             # <<<<<<<<<<<<<<
 *             c_index=abs(c_index)
 *             # Create fifo
 */
  __pyx_t_2 = ((__pyx_v_c_index < 0) != 0);
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":828
 *         tail=self.get_pword()
 *         if c_index < 0:
 *             c_index=abs(c_index)             # <<<<<<<<<<<<<<
 *             # Create fifo
 *             array_pword=<pyclp.pword *>(libc.stdlib.calloc(c_index,sizeof(pyclp.pword)))
 */
    __pyx_t_1 = abs(__pyx_v_c_index); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 828, __pyx_L1_error)
    __pyx_v_c_index = __pyx_t_1;

    /* "pyclp/pyclp.pyx":830
 *             c_index=abs(c_index)
 *             # Create fifo
 *             array_pword=<pyclp.pword *>(libc.stdlib.calloc(c_index,sizeof(pyclp.pword)))             # <<<<<<<<<<<<<<
 *             for c_k in range(c_index):
 *                 self.get_head_tail(&head,&tail)
 */
    __pyx_v_array_pword = ((pword *)calloc(__pyx_v_c_index, (sizeof(pword))));

    /* "pyclp/pyclp.pyx":831
 *             # Create fifo
 *             array_pword=<pyclp.pword *>(libc.stdlib.calloc(c_index,sizeof(pyclp.pword)))
 *             for c_k in range(c_index):             # <<<<<<<<<<<<<<
 *                 self.get_head_tail(&head,&tail)
 *                 array_pword[c_k]=head
 */
    __pyx_t_1 = __pyx_v_c_index;
    __pyx_t_3 = __pyx_t_1;
    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
      __pyx_v_c_k = __pyx_t_4;

      /* "pyclp/pyclp.pyx":832
 *             array_pword=<pyclp.pword *>(libc.stdlib.calloc(c_index,sizeof(pyclp.pword)))
 *             for c_k in range(c_index):
 *                 self.get_head_tail(&head,&tail)             # <<<<<<<<<<<<<<
 *                 array_pword[c_k]=head
 *             try:
 */
      __pyx_t_5 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_PList *)__pyx_v_self->__pyx_base.__pyx_vtab)->get_head_tail(__pyx_v_self, (&__pyx_v_head), (&__pyx_v_tail)); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 832, __pyx_L1_error)

      /* "pyclp/pyclp.pyx":833
 *             for c_k in range(c_index):
 *                 self.get_head_tail(&head,&tail)
 *                 array_pword[c_k]=head             # <<<<<<<<<<<<<<
 *             try:
 *                 while(1):
 */
      (__pyx_v_array_pword[__pyx_v_c_k]) = __pyx_v_head;
    }

    /* "pyclp/pyclp.pyx":834
 *                 self.get_head_tail(&head,&tail)
 *                 array_pword[c_k]=head
 *             try:             # <<<<<<<<<<<<<<
 *                 while(1):
 *                     self.get_head_tail(&head,&tail)
 */
    /*try:*/ {
      {
        __Pyx_PyThreadState_declare
        __Pyx_PyThreadState_assign
        __Pyx_ExceptionSave(&__pyx_t_6, &__pyx_t_7, &__pyx_t_8);
        __Pyx_XGOTREF(__pyx_t_6);
        __Pyx_XGOTREF(__pyx_t_7);
        __Pyx_XGOTREF(__pyx_t_8);
        /*try:*/ {

          /* "pyclp/pyclp.pyx":835
 *                 array_pword[c_k]=head
 *             try:
 *                 while(1):             # <<<<<<<<<<<<<<
 *                     self.get_head_tail(&head,&tail)
 *                     c_k+=1
 */
          while (1) {

            /* "pyclp/pyclp.pyx":836
 *             try:
 *                 while(1):
 *                     self.get_head_tail(&head,&tail)             # <<<<<<<<<<<<<<
 *                     c_k+=1
 *                     c_k=c_k % c_index
 */
            __pyx_t_1 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_PList *)__pyx_v_self->__pyx_base.__pyx_vtab)->get_head_tail(__pyx_v_self, (&__pyx_v_head), (&__pyx_v_tail)); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 836, __pyx_L9_error)

            /* "pyclp/pyclp.pyx":837
 *                 while(1):
 *                     self.get_head_tail(&head,&tail)
 *                     c_k+=1             # <<<<<<<<<<<<<<
 *                     c_k=c_k % c_index
 *                     array_pword[c_k]=head
 */
            __pyx_v_c_k = (__pyx_v_c_k + 1);

            /* "pyclp/pyclp.pyx":838
 *                     self.get_head_tail(&head,&tail)
 *                     c_k+=1
 *                     c_k=c_k % c_index             # <<<<<<<<<<<<<<
 *                     array_pword[c_k]=head
 *             except IndexError:
 */
            if (unlikely(__pyx_v_c_index == 0)) {
              PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
              __PYX_ERR(0, 838, __pyx_L9_error)
            }
            __pyx_v_c_k = __Pyx_mod_int(__pyx_v_c_k, __pyx_v_c_index);

            /* "pyclp/pyclp.pyx":839
 *                     c_k+=1
 *                     c_k=c_k % c_index
 *                     array_pword[c_k]=head             # <<<<<<<<<<<<<<
 *             except IndexError:
 *                 result=pword2object(array_pword[(c_k - c_index +1)%c_index])
 */
            (__pyx_v_array_pword[__pyx_v_c_k]) = __pyx_v_head;
          }

          /* "pyclp/pyclp.pyx":834
 *                 self.get_head_tail(&head,&tail)
 *                 array_pword[c_k]=head
 *             try:             # <<<<<<<<<<<<<<
 *                 while(1):
 *                     self.get_head_tail(&head,&tail)
 */
        }
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        goto __pyx_L14_try_end;
        __pyx_L9_error:;

        /* "pyclp/pyclp.pyx":840
 *                     c_k=c_k % c_index
 *                     array_pword[c_k]=head
 *             except IndexError:             # <<<<<<<<<<<<<<
 *                 result=pword2object(array_pword[(c_k - c_index +1)%c_index])
 *             finally:
 */
        __pyx_t_1 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_IndexError);
        if (__pyx_t_1) {
          __Pyx_AddTraceback("pyclp.pyclp.PList.__getitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
          if (__Pyx_GetException(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11) < 0) __PYX_ERR(0, 840, __pyx_L11_except_error)
          __Pyx_GOTREF(__pyx_t_9);
          __Pyx_GOTREF(__pyx_t_10);
          __Pyx_GOTREF(__pyx_t_11);

          /* "pyclp/pyclp.pyx":841
 *                     array_pword[c_k]=head
 *             except IndexError:
 *                 result=pword2object(array_pword[(c_k - c_index +1)%c_index])             # <<<<<<<<<<<<<<
 *             finally:
 *                 libc.stdlib.free(array_pword)
 */
          __pyx_t_12 = ((__pyx_v_c_k - __pyx_v_c_index) + 1);
          if (unlikely(__pyx_v_c_index == 0)) {
            PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
            __PYX_ERR(0, 841, __pyx_L11_except_error)
          }
          __pyx_t_13 = __pyx_f_5pyclp_5pyclp_pword2object((__pyx_v_array_pword[__Pyx_mod_long(__pyx_t_12, __pyx_v_c_index)])); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 841, __pyx_L11_except_error)
          __Pyx_GOTREF(__pyx_t_13);
          __pyx_v_result = __pyx_t_13;
          __pyx_t_13 = 0;
          __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
          __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
          __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
          goto __pyx_L10_exception_handled;
        }
        goto __pyx_L11_except_error;
        __pyx_L11_except_error:;

        /* "pyclp/pyclp.pyx":834
 *                 self.get_head_tail(&head,&tail)
 *                 array_pword[c_k]=head
 *             try:             # <<<<<<<<<<<<<<
 *                 while(1):
 *                     self.get_head_tail(&head,&tail)
 */
        __Pyx_XGIVEREF(__pyx_t_6);
        __Pyx_XGIVEREF(__pyx_t_7);
        __Pyx_XGIVEREF(__pyx_t_8);
        __Pyx_ExceptionReset(__pyx_t_6, __pyx_t_7, __pyx_t_8);
        goto __pyx_L7_error;
        __pyx_L10_exception_handled:;
        __Pyx_XGIVEREF(__pyx_t_6);
        __Pyx_XGIVEREF(__pyx_t_7);
        __Pyx_XGIVEREF(__pyx_t_8);
        __Pyx_ExceptionReset(__pyx_t_6, __pyx_t_7, __pyx_t_8);
        __pyx_L14_try_end:;
      }
    }

    /* "pyclp/pyclp.pyx":843
 *                 result=pword2object(array_pword[(c_k - c_index +1)%c_index])
 *             finally:
 *                 libc.stdlib.free(array_pword)             # <<<<<<<<<<<<<<
 *             return result
 * 
 */
    /*finally:*/ {
      /*normal exit:*/{
        free(__pyx_v_array_pword);
        goto __pyx_L8;
      }
      __pyx_L7_error:;
      /*exception exit:*/{
        __Pyx_PyThreadState_declare
        __Pyx_PyThreadState_assign
        __pyx_t_8 = 0; __pyx_t_7 = 0; __pyx_t_6 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0; __pyx_t_17 = 0;
        __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
        __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
        __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
        __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
        if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_15, &__pyx_t_16, &__pyx_t_17);
        if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_8, &__pyx_t_7, &__pyx_t_6) < 0)) __Pyx_ErrFetch(&__pyx_t_8, &__pyx_t_7, &__pyx_t_6);
        __Pyx_XGOTREF(__pyx_t_8);
        __Pyx_XGOTREF(__pyx_t_7);
        __Pyx_XGOTREF(__pyx_t_6);
        __Pyx_XGOTREF(__pyx_t_15);
        __Pyx_XGOTREF(__pyx_t_16);
        __Pyx_XGOTREF(__pyx_t_17);
        __pyx_t_1 = __pyx_lineno; __pyx_t_3 = __pyx_clineno; __pyx_t_14 = __pyx_filename;
        {
          free(__pyx_v_array_pword);
        }
        if (PY_MAJOR_VERSION >= 3) {
          __Pyx_XGIVEREF(__pyx_t_15);
          __Pyx_XGIVEREF(__pyx_t_16);
          __Pyx_XGIVEREF(__pyx_t_17);
          __Pyx_ExceptionReset(__pyx_t_15, __pyx_t_16, __pyx_t_17);
        }
        __Pyx_XGIVEREF(__pyx_t_8);
        __Pyx_XGIVEREF(__pyx_t_7);
        __Pyx_XGIVEREF(__pyx_t_6);
        __Pyx_ErrRestore(__pyx_t_8, __pyx_t_7, __pyx_t_6);
        __pyx_t_8 = 0; __pyx_t_7 = 0; __pyx_t_6 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0; __pyx_t_17 = 0;
        __pyx_lineno = __pyx_t_1; __pyx_clineno = __pyx_t_3; __pyx_filename = __pyx_t_14;
        goto __pyx_L1_error;
      }
      __pyx_L8:;
    }

    /* "pyclp/pyclp.pyx":844
 *             finally:
 *                 libc.stdlib.free(array_pword)
 *             return result             # <<<<<<<<<<<<<<
 * 
 *         else:
 */
    __Pyx_XDECREF(__pyx_r);
    if (unlikely(!__pyx_v_result)) { __Pyx_RaiseUnboundLocalError("result"); __PYX_ERR(0, 844, __pyx_L1_error) }
    __Pyx_INCREF(__pyx_v_result);
    __pyx_r = __pyx_v_result;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":827
 *         c_index=<int?>index
 *         tail=self.get_pword()
 *         if c_index < 0:             # <<<<<<<<<<<<<<
 *             c_index=abs(c_index)
 *             # Create fifo
 */
  }

  /* "pyclp/pyclp.pyx":847
 * 
 *         else:
 *             for c_k in range(c_index+1):             # <<<<<<<<<<<<<<
 *                 self.get_head_tail(&head,&tail)
 *             return pword2object(head)
 */
  /*else*/ {
    __pyx_t_12 = (__pyx_v_c_index + 1);
    __pyx_t_18 = __pyx_t_12;
    for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_18; __pyx_t_3+=1) {
      __pyx_v_c_k = __pyx_t_3;

      /* "pyclp/pyclp.pyx":848
 *         else:
 *             for c_k in range(c_index+1):
 *                 self.get_head_tail(&head,&tail)             # <<<<<<<<<<<<<<
 *             return pword2object(head)
 * 
 */
      __pyx_t_1 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_PList *)__pyx_v_self->__pyx_base.__pyx_vtab)->get_head_tail(__pyx_v_self, (&__pyx_v_head), (&__pyx_v_tail)); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 848, __pyx_L1_error)
    }

    /* "pyclp/pyclp.pyx":849
 *             for c_k in range(c_index+1):
 *                 self.get_head_tail(&head,&tail)
 *             return pword2object(head)             # <<<<<<<<<<<<<<
 * 
 *     def getListTail(self):
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_11 = __pyx_f_5pyclp_5pyclp_pword2object(__pyx_v_head); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 849, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_11);
    __pyx_r = __pyx_t_11;
    __pyx_t_11 = 0;
    goto __pyx_L0;
  }

  /* "pyclp/pyclp.pyx":816
 *         return 1
 * 
 *     def __getitem__(self,index):             # <<<<<<<<<<<<<<
 *         """Implement python list protocol
 *         """
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_AddTraceback("pyclp.pyclp.PList.__getitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_result);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":851
 *             return pword2object(head)
 * 
 *     def getListTail(self):             # <<<<<<<<<<<<<<
 *         """
 *         Convert a PList in a python list and the tail.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_19getListTail(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_5PList_18getListTail[] = "\n        Convert a PList in a python list and the tail.\n        \n        **Examples**::\n        \n            prolog              python\n            [1,2,3,f(1,2)]  --> ([1,2,3,Compound('f',1,2)],PList([]))\n            [1,2,3|A]       --> ([1,2,3],Var())\n            [1,2,3|dummy]   --> ([1,2,3],Atom('dummy'))\n        \n        :returns: a tuple (list,tail). First element is a python list containing each element of prolog list converted to a pyclp object             second element is a pyclp object representing the tail of prolog list.\n        \n        ";
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_19getListTail(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getListTail (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_5PList_18getListTail(((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_18getListTail(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self) {
  PyObject *__pyx_v_returned_list = NULL;
  PyObject *__pyx_v_head = NULL;
  PyObject *__pyx_v_tail = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  Py_ssize_t __pyx_t_4;
  PyObject *(*__pyx_t_5)(PyObject *);
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *(*__pyx_t_8)(PyObject *);
  int __pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("getListTail", 0);

  /* "pyclp/pyclp.pyx":866
 * 
 *         """
 *         returned_list=[]             # <<<<<<<<<<<<<<
 *         for head,tail in self.iterHeadTail():
 *             returned_list.append(head)
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 866, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_returned_list = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":867
 *         """
 *         returned_list=[]
 *         for head,tail in self.iterHeadTail():             # <<<<<<<<<<<<<<
 *             returned_list.append(head)
 *         return (returned_list,tail)
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_iterHeadTail); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 867, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 867, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
    __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_4 = 0;
    __pyx_t_5 = NULL;
  } else {
    __pyx_t_4 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 867, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 867, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  for (;;) {
    if (likely(!__pyx_t_5)) {
      if (likely(PyList_CheckExact(__pyx_t_2))) {
        if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_4); __Pyx_INCREF(__pyx_t_1); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 867, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 867, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      } else {
        if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_4); __Pyx_INCREF(__pyx_t_1); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 867, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 867, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      }
    } else {
      __pyx_t_1 = __pyx_t_5(__pyx_t_2);
      if (unlikely(!__pyx_t_1)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 867, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_1);
    }
    if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
      PyObject* sequence = __pyx_t_1;
      Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
      if (unlikely(size != 2)) {
        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
        __PYX_ERR(0, 867, __pyx_L1_error)
      }
      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
      if (likely(PyTuple_CheckExact(sequence))) {
        __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
        __pyx_t_6 = PyTuple_GET_ITEM(sequence, 1); 
      } else {
        __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
        __pyx_t_6 = PyList_GET_ITEM(sequence, 1); 
      }
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_6);
      #else
      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 867, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 867, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    } else {
      Py_ssize_t index = -1;
      __pyx_t_7 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 867, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_8 = Py_TYPE(__pyx_t_7)->tp_iternext;
      index = 0; __pyx_t_3 = __pyx_t_8(__pyx_t_7); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_3);
      index = 1; __pyx_t_6 = __pyx_t_8(__pyx_t_7); if (unlikely(!__pyx_t_6)) goto __pyx_L5_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_6);
      if (__Pyx_IternextUnpackEndCheck(__pyx_t_8(__pyx_t_7), 2) < 0) __PYX_ERR(0, 867, __pyx_L1_error)
      __pyx_t_8 = NULL;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      goto __pyx_L6_unpacking_done;
      __pyx_L5_unpacking_failed:;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_t_8 = NULL;
      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
      __PYX_ERR(0, 867, __pyx_L1_error)
      __pyx_L6_unpacking_done:;
    }
    __Pyx_XDECREF_SET(__pyx_v_head, __pyx_t_3);
    __pyx_t_3 = 0;
    __Pyx_XDECREF_SET(__pyx_v_tail, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "pyclp/pyclp.pyx":868
 *         returned_list=[]
 *         for head,tail in self.iterHeadTail():
 *             returned_list.append(head)             # <<<<<<<<<<<<<<
 *         return (returned_list,tail)
 *     cpdef bint isNil(self):
 */
    __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_returned_list, __pyx_v_head); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 868, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":867
 *         """
 *         returned_list=[]
 *         for head,tail in self.iterHeadTail():             # <<<<<<<<<<<<<<
 *             returned_list.append(head)
 *         return (returned_list,tail)
 */
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pyclp/pyclp.pyx":869
 *         for head,tail in self.iterHeadTail():
 *             returned_list.append(head)
 *         return (returned_list,tail)             # <<<<<<<<<<<<<<
 *     cpdef bint isNil(self):
 *         """
 */
  __Pyx_XDECREF(__pyx_r);
  if (unlikely(!__pyx_v_tail)) { __Pyx_RaiseUnboundLocalError("tail"); __PYX_ERR(0, 869, __pyx_L1_error) }
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 869, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_returned_list);
  __Pyx_GIVEREF(__pyx_v_returned_list);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_returned_list);
  __Pyx_INCREF(__pyx_v_tail);
  __Pyx_GIVEREF(__pyx_v_tail);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_tail);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":851
 *             return pword2object(head)
 * 
 *     def getListTail(self):             # <<<<<<<<<<<<<<
 *         """
 *         Convert a PList in a python list and the tail.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("pyclp.pyclp.PList.getListTail", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_returned_list);
  __Pyx_XDECREF(__pyx_v_head);
  __Pyx_XDECREF(__pyx_v_tail);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":870
 *             returned_list.append(head)
 *         return (returned_list,tail)
 *     cpdef bint isNil(self):             # <<<<<<<<<<<<<<
 *         """
 *         Check if the PList is the nil list --> []
 */

static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_21isNil(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static int __pyx_f_5pyclp_5pyclp_5PList_isNil(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self, int __pyx_skip_dispatch) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("isNil", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_isNil); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 870, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_5pyclp_5pyclp_5PList_21isNil)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 870, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 870, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "pyclp/pyclp.pyx":877
 * 
 *         """
 *         if pyclp.ec_get_nil(self.get_pword()) == pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             return True
 *         else:
 */
  __pyx_t_5 = ((ec_get_nil(((struct __pyx_vtabstruct_5pyclp_5pyclp_PList *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self))) == PSUCCEED) != 0);
  if (__pyx_t_5) {

    /* "pyclp/pyclp.pyx":878
 *         """
 *         if pyclp.ec_get_nil(self.get_pword()) == pyclp.PSUCCEED:
 *             return True             # <<<<<<<<<<<<<<
 *         else:
 *             return False
 */
    __pyx_r = 1;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":877
 * 
 *         """
 *         if pyclp.ec_get_nil(self.get_pword()) == pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             return True
 *         else:
 */
  }

  /* "pyclp/pyclp.pyx":880
 *             return True
 *         else:
 *             return False             # <<<<<<<<<<<<<<
 * 
 *     def __str__(self):
 */
  /*else*/ {
    __pyx_r = 0;
    goto __pyx_L0;
  }

  /* "pyclp/pyclp.pyx":870
 *             returned_list.append(head)
 *         return (returned_list,tail)
 *     cpdef bint isNil(self):             # <<<<<<<<<<<<<<
 *         """
 *         Check if the PList is the nil list --> []
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("pyclp.pyclp.PList.isNil", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_21isNil(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_5PList_20isNil[] = "\n        Check if the PList is the nil list --> []\n        \n        :returns: True if it is the empty list\n        \n        ";
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_21isNil(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isNil (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_5PList_20isNil(((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_20isNil(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("isNil", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_f_5pyclp_5pyclp_5PList_isNil(__pyx_v_self, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 870, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.PList.isNil", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":882
 *             return False
 * 
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         """
 *         Pretty printing of the list
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_23__str__(PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_5PList_22__str__[] = "\n        Pretty printing of the list \n        ";
#if CYTHON_UPDATE_DESCRIPTOR_DOC
struct wrapperbase __pyx_wrapperbase_5pyclp_5pyclp_5PList_22__str__;
#endif
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_23__str__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__str__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_5PList_22__str__(((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_22__str__(struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self) {
  PyObject *__pyx_v_list_element = NULL;
  PyObject *__pyx_v_tail = NULL;
  PyObject *__pyx_v_list_string = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *(*__pyx_t_5)(PyObject *);
  int __pyx_t_6;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__str__", 0);

  /* "pyclp/pyclp.pyx":886
 *         Pretty printing of the list
 *         """
 *         list_element,tail=self.getListTail()             # <<<<<<<<<<<<<<
 *         list_string=list(map(formatTermStr,list_element))
 *         #Convert all pyclp object to a string
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_getListTail); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 886, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 886, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
    PyObject* sequence = __pyx_t_1;
    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
    if (unlikely(size != 2)) {
      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
      __PYX_ERR(0, 886, __pyx_L1_error)
    }
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    if (likely(PyTuple_CheckExact(sequence))) {
      __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
    } else {
      __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
      __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
    }
    __Pyx_INCREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_t_3);
    #else
    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 886, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 886, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  } else {
    Py_ssize_t index = -1;
    __pyx_t_4 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 886, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_5 = Py_TYPE(__pyx_t_4)->tp_iternext;
    index = 0; __pyx_t_2 = __pyx_t_5(__pyx_t_4); if (unlikely(!__pyx_t_2)) goto __pyx_L3_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_2);
    index = 1; __pyx_t_3 = __pyx_t_5(__pyx_t_4); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_3);
    if (__Pyx_IternextUnpackEndCheck(__pyx_t_5(__pyx_t_4), 2) < 0) __PYX_ERR(0, 886, __pyx_L1_error)
    __pyx_t_5 = NULL;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    goto __pyx_L4_unpacking_done;
    __pyx_L3_unpacking_failed:;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_5 = NULL;
    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
    __PYX_ERR(0, 886, __pyx_L1_error)
    __pyx_L4_unpacking_done:;
  }
  __pyx_v_list_element = __pyx_t_2;
  __pyx_t_2 = 0;
  __pyx_v_tail = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "pyclp/pyclp.pyx":887
 *         """
 *         list_element,tail=self.getListTail()
 *         list_string=list(map(formatTermStr,list_element))             # <<<<<<<<<<<<<<
 *         #Convert all pyclp object to a string
 *         list_string=list(map(str,list_string))
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_formatTermStr); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 887, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 887, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
  __Pyx_INCREF(__pyx_v_list_element);
  __Pyx_GIVEREF(__pyx_v_list_element);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_list_element);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_map, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 887, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 887, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_list_string = ((PyObject*)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "pyclp/pyclp.pyx":889
 *         list_string=list(map(formatTermStr,list_element))
 *         #Convert all pyclp object to a string
 *         list_string=list(map(str,list_string))             # <<<<<<<<<<<<<<
 *         if isinstance(tail,PList):
 *             return "[{0}]".format(",".join(list_string))
 */
  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 889, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(((PyObject *)(&PyString_Type)));
  __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)(&PyString_Type)));
  __Pyx_INCREF(__pyx_v_list_string);
  __Pyx_GIVEREF(__pyx_v_list_string);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_list_string);
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_map, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 889, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 889, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF_SET(__pyx_v_list_string, ((PyObject*)__pyx_t_3));
  __pyx_t_3 = 0;

  /* "pyclp/pyclp.pyx":890
 *         #Convert all pyclp object to a string
 *         list_string=list(map(str,list_string))
 *         if isinstance(tail,PList):             # <<<<<<<<<<<<<<
 *             return "[{0}]".format(",".join(list_string))
 *         else: # Just in case the tail is not a nil list
 */
  __pyx_t_6 = __Pyx_TypeCheck(__pyx_v_tail, __pyx_ptype_5pyclp_5pyclp_PList); 
  __pyx_t_7 = (__pyx_t_6 != 0);
  if (__pyx_t_7) {

    /* "pyclp/pyclp.pyx":891
 *         list_string=list(map(str,list_string))
 *         if isinstance(tail,PList):
 *             return "[{0}]".format(",".join(list_string))             # <<<<<<<<<<<<<<
 *         else: # Just in case the tail is not a nil list
 *             return "[{0}|{1}]".format(",".join(list_string),str(tail))
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_0, __pyx_n_s_format); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 891, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyString_Join(__pyx_kp_s__24, __pyx_v_list_string); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 891, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_4, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_2);
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 891, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":890
 *         #Convert all pyclp object to a string
 *         list_string=list(map(str,list_string))
 *         if isinstance(tail,PList):             # <<<<<<<<<<<<<<
 *             return "[{0}]".format(",".join(list_string))
 *         else: # Just in case the tail is not a nil list
 */
  }

  /* "pyclp/pyclp.pyx":893
 *             return "[{0}]".format(",".join(list_string))
 *         else: # Just in case the tail is not a nil list
 *             return "[{0}|{1}]".format(",".join(list_string),str(tail))             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_0_1, __pyx_n_s_format); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 893, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyString_Join(__pyx_kp_s__24, __pyx_v_list_string); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 893, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_tail); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 893, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_8 = NULL;
    __pyx_t_9 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
        __pyx_t_9 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_1)) {
      PyObject *__pyx_temp[3] = {__pyx_t_8, __pyx_t_2, __pyx_t_4};
      __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 893, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
      PyObject *__pyx_temp[3] = {__pyx_t_8, __pyx_t_2, __pyx_t_4};
      __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 893, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    } else
    #endif
    {
      __pyx_t_10 = PyTuple_New(2+__pyx_t_9); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 893, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_10);
      if (__pyx_t_8) {
        __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_8); __pyx_t_8 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_2);
      PyTuple_SET_ITEM(__pyx_t_10, 0+__pyx_t_9, __pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_10, 1+__pyx_t_9, __pyx_t_4);
      __pyx_t_2 = 0;
      __pyx_t_4 = 0;
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_10, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 893, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;
  }

  /* "pyclp/pyclp.pyx":882
 *             return False
 * 
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         """
 *         Pretty printing of the list
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_AddTraceback("pyclp.pyclp.PList.__str__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_list_element);
  __Pyx_XDECREF(__pyx_v_tail);
  __Pyx_XDECREF(__pyx_v_list_string);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_25__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_25__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_5PList_24__reduce_cython__(((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_24__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.PList.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_27__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_5PList_27__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_5PList_26__setstate_cython__(((struct __pyx_obj_5pyclp_5pyclp_PList *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_5PList_26__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_PList *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.PList.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":923
 *     """
 *     cdef pyclp.dident ec_dict_ptr
 *     def __init__(self,functor_string,*args):             # <<<<<<<<<<<<<<
 *         cdef int arity
 *         cdef int index
 */

/* Python wrapper */
static int __pyx_pw_5pyclp_5pyclp_8Compound_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pyclp_5pyclp_8Compound_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_functor_string = 0;
  PyObject *__pyx_v_args = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  if (PyTuple_GET_SIZE(__pyx_args) > 1) {
    __pyx_v_args = PyTuple_GetSlice(__pyx_args, 1, PyTuple_GET_SIZE(__pyx_args));
    if (unlikely(!__pyx_v_args)) {
      __Pyx_RefNannyFinishContext();
      return -1;
    }
    __Pyx_GOTREF(__pyx_v_args);
  } else {
    __pyx_v_args = __pyx_empty_tuple; __Pyx_INCREF(__pyx_empty_tuple);
  }
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_functor_string,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        default:
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_functor_string)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        const Py_ssize_t used_pos_args = (pos_args < 1) ? pos_args : 1;
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, used_pos_args, "__init__") < 0)) __PYX_ERR(0, 923, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) < 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_functor_string = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 923, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_DECREF(__pyx_v_args); __pyx_v_args = 0;
  __Pyx_AddTraceback("pyclp.pyclp.Compound.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_8Compound___init__(((struct __pyx_obj_5pyclp_5pyclp_Compound *)__pyx_v_self), __pyx_v_functor_string, __pyx_v_args);

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_args);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pyclp_5pyclp_8Compound___init__(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self, PyObject *__pyx_v_functor_string, PyObject *__pyx_v_args) {
  int __pyx_v_arity;
  int __pyx_v_index;
  pword *__pyx_v_array_pword;
  char *__pyx_v_c_string;
  PyObject *__pyx_v_py_byte_string = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  Py_ssize_t __pyx_t_8;
  Py_ssize_t __pyx_t_9;
  int __pyx_t_10;
  int __pyx_t_11;
  int __pyx_t_12;
  char *__pyx_t_13;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);
  __Pyx_INCREF(__pyx_v_args);

  /* "pyclp/pyclp.pyx":928
 *         cdef pyclp.pword * array_pword
 *         cdef char* c_string
 *         Term.__init__(self,None)             # <<<<<<<<<<<<<<
 *         args=list(args)
 *         if functor_string is not None:
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Term), __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 928, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  __pyx_t_4 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_4 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, ((PyObject *)__pyx_v_self), Py_None};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 928, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, ((PyObject *)__pyx_v_self), Py_None};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 928, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 928, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (__pyx_t_3) {
      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
    }
    __Pyx_INCREF(((PyObject *)__pyx_v_self));
    __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, ((PyObject *)__pyx_v_self));
    __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(Py_None);
    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, Py_None);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 928, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":929
 *         cdef char* c_string
 *         Term.__init__(self,None)
 *         args=list(args)             # <<<<<<<<<<<<<<
 *         if functor_string is not None:
 *             arity=len(args)
 */
  __pyx_t_1 = PySequence_List(__pyx_v_args); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 929, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF_SET(__pyx_v_args, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":930
 *         Term.__init__(self,None)
 *         args=list(args)
 *         if functor_string is not None:             # <<<<<<<<<<<<<<
 *             arity=len(args)
 *             if arity ==0:
 */
  __pyx_t_6 = (__pyx_v_functor_string != Py_None);
  __pyx_t_7 = (__pyx_t_6 != 0);
  if (__pyx_t_7) {

    /* "pyclp/pyclp.pyx":931
 *         args=list(args)
 *         if functor_string is not None:
 *             arity=len(args)             # <<<<<<<<<<<<<<
 *             if arity ==0:
 *                 raise pyclpEx("Arity of compound item shall be >0")
 */
    __pyx_t_8 = PyObject_Length(__pyx_v_args); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 931, __pyx_L1_error)
    __pyx_v_arity = __pyx_t_8;

    /* "pyclp/pyclp.pyx":932
 *         if functor_string is not None:
 *             arity=len(args)
 *             if arity ==0:             # <<<<<<<<<<<<<<
 *                 raise pyclpEx("Arity of compound item shall be >0")
 *             #Convert not Term arguments
 */
    __pyx_t_7 = ((__pyx_v_arity == 0) != 0);
    if (unlikely(__pyx_t_7)) {

      /* "pyclp/pyclp.pyx":933
 *             arity=len(args)
 *             if arity ==0:
 *                 raise pyclpEx("Arity of compound item shall be >0")             # <<<<<<<<<<<<<<
 *             #Convert not Term arguments
 *             for index in range(len(args)):
 */
      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 933, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_5 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_2, function);
        }
      }
      __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_kp_s_Arity_of_compound_item_shall_be) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_Arity_of_compound_item_shall_be);
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 933, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 933, __pyx_L1_error)

      /* "pyclp/pyclp.pyx":932
 *         if functor_string is not None:
 *             arity=len(args)
 *             if arity ==0:             # <<<<<<<<<<<<<<
 *                 raise pyclpEx("Arity of compound item shall be >0")
 *             #Convert not Term arguments
 */
    }

    /* "pyclp/pyclp.pyx":935
 *                 raise pyclpEx("Arity of compound item shall be >0")
 *             #Convert not Term arguments
 *             for index in range(len(args)):             # <<<<<<<<<<<<<<
 *                 if isinstance(args[index],list) or isinstance(args[index],tuple):
 *                     args[index]=PList(args[index])
 */
    __pyx_t_8 = PyObject_Length(__pyx_v_args); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 935, __pyx_L1_error)
    __pyx_t_9 = __pyx_t_8;
    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_9; __pyx_t_4+=1) {
      __pyx_v_index = __pyx_t_4;

      /* "pyclp/pyclp.pyx":936
 *             #Convert not Term arguments
 *             for index in range(len(args)):
 *                 if isinstance(args[index],list) or isinstance(args[index],tuple):             # <<<<<<<<<<<<<<
 *                     args[index]=PList(args[index])
 *                 if not isinstance(args[index],Term):
 */
      __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_args, __pyx_v_index, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 936, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_6 = PyList_Check(__pyx_t_1); 
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_10 = (__pyx_t_6 != 0);
      if (!__pyx_t_10) {
      } else {
        __pyx_t_7 = __pyx_t_10;
        goto __pyx_L8_bool_binop_done;
      }
      __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_args, __pyx_v_index, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 936, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_10 = PyTuple_Check(__pyx_t_1); 
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_6 = (__pyx_t_10 != 0);
      __pyx_t_7 = __pyx_t_6;
      __pyx_L8_bool_binop_done:;
      if (__pyx_t_7) {

        /* "pyclp/pyclp.pyx":937
 *             for index in range(len(args)):
 *                 if isinstance(args[index],list) or isinstance(args[index],tuple):
 *                     args[index]=PList(args[index])             # <<<<<<<<<<<<<<
 *                 if not isinstance(args[index],Term):
 *                     args[index]=Term(args[index])
 */
        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_args, __pyx_v_index, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 937, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_5pyclp_5pyclp_PList), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 937, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        if (unlikely(__Pyx_SetItemInt(__pyx_v_args, __pyx_v_index, __pyx_t_2, int, 1, __Pyx_PyInt_From_int, 0, 1, 1) < 0)) __PYX_ERR(0, 937, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

        /* "pyclp/pyclp.pyx":936
 *             #Convert not Term arguments
 *             for index in range(len(args)):
 *                 if isinstance(args[index],list) or isinstance(args[index],tuple):             # <<<<<<<<<<<<<<
 *                     args[index]=PList(args[index])
 *                 if not isinstance(args[index],Term):
 */
      }

      /* "pyclp/pyclp.pyx":938
 *                 if isinstance(args[index],list) or isinstance(args[index],tuple):
 *                     args[index]=PList(args[index])
 *                 if not isinstance(args[index],Term):             # <<<<<<<<<<<<<<
 *                     args[index]=Term(args[index])
 *             #Create c array for eclipse function
 */
      __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_args, __pyx_v_index, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 938, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_7 = __Pyx_TypeCheck(__pyx_t_2, __pyx_ptype_5pyclp_5pyclp_Term); 
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_6 = ((!(__pyx_t_7 != 0)) != 0);
      if (__pyx_t_6) {

        /* "pyclp/pyclp.pyx":939
 *                     args[index]=PList(args[index])
 *                 if not isinstance(args[index],Term):
 *                     args[index]=Term(args[index])             # <<<<<<<<<<<<<<
 *             #Create c array for eclipse function
 *             array_pword=<pyclp.pword *>(libc.stdlib.calloc(arity,sizeof(pyclp.pword)))
 */
        __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_args, __pyx_v_index, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 939, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Term), __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 939, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        if (unlikely(__Pyx_SetItemInt(__pyx_v_args, __pyx_v_index, __pyx_t_1, int, 1, __Pyx_PyInt_From_int, 0, 1, 1) < 0)) __PYX_ERR(0, 939, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "pyclp/pyclp.pyx":938
 *                 if isinstance(args[index],list) or isinstance(args[index],tuple):
 *                     args[index]=PList(args[index])
 *                 if not isinstance(args[index],Term):             # <<<<<<<<<<<<<<
 *                     args[index]=Term(args[index])
 *             #Create c array for eclipse function
 */
      }
    }

    /* "pyclp/pyclp.pyx":941
 *                     args[index]=Term(args[index])
 *             #Create c array for eclipse function
 *             array_pword=<pyclp.pword *>(libc.stdlib.calloc(arity,sizeof(pyclp.pword)))             # <<<<<<<<<<<<<<
 *             for index in range(arity):
 *                 array_pword[index]=(<Term>(args[index])).get_pword()
 */
    __pyx_v_array_pword = ((pword *)calloc(__pyx_v_arity, (sizeof(pword))));

    /* "pyclp/pyclp.pyx":942
 *             #Create c array for eclipse function
 *             array_pword=<pyclp.pword *>(libc.stdlib.calloc(arity,sizeof(pyclp.pword)))
 *             for index in range(arity):             # <<<<<<<<<<<<<<
 *                 array_pword[index]=(<Term>(args[index])).get_pword()
 *             py_byte_string = tobytes(functor_string)
 */
    __pyx_t_4 = __pyx_v_arity;
    __pyx_t_11 = __pyx_t_4;
    for (__pyx_t_12 = 0; __pyx_t_12 < __pyx_t_11; __pyx_t_12+=1) {
      __pyx_v_index = __pyx_t_12;

      /* "pyclp/pyclp.pyx":943
 *             array_pword=<pyclp.pword *>(libc.stdlib.calloc(arity,sizeof(pyclp.pword)))
 *             for index in range(arity):
 *                 array_pword[index]=(<Term>(args[index])).get_pword()             # <<<<<<<<<<<<<<
 *             py_byte_string = tobytes(functor_string)
 *             c_string = py_byte_string # type casting
 */
      __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_args, __pyx_v_index, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 943, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      (__pyx_v_array_pword[__pyx_v_index]) = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_t_1)->__pyx_vtab)->get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_t_1));
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    }

    /* "pyclp/pyclp.pyx":944
 *             for index in range(arity):
 *                 array_pword[index]=(<Term>(args[index])).get_pword()
 *             py_byte_string = tobytes(functor_string)             # <<<<<<<<<<<<<<
 *             c_string = py_byte_string # type casting
 *             #Function dictionary element
 */
    __pyx_t_1 = __pyx_f_5pyclp_5pyclp_tobytes(__pyx_v_functor_string); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 944, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_v_py_byte_string = ((PyObject*)__pyx_t_1);
    __pyx_t_1 = 0;

    /* "pyclp/pyclp.pyx":945
 *                 array_pword[index]=(<Term>(args[index])).get_pword()
 *             py_byte_string = tobytes(functor_string)
 *             c_string = py_byte_string # type casting             # <<<<<<<<<<<<<<
 *             #Function dictionary element
 *             self.ec_dict_ptr=pyclp.ec_did(c_string,arity)
 */
    if (unlikely(__pyx_v_py_byte_string == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
      __PYX_ERR(0, 945, __pyx_L1_error)
    }
    __pyx_t_13 = __Pyx_PyBytes_AsWritableString(__pyx_v_py_byte_string); if (unlikely((!__pyx_t_13) && PyErr_Occurred())) __PYX_ERR(0, 945, __pyx_L1_error)
    __pyx_v_c_string = __pyx_t_13;

    /* "pyclp/pyclp.pyx":947
 *             c_string = py_byte_string # type casting
 *             #Function dictionary element
 *             self.ec_dict_ptr=pyclp.ec_did(c_string,arity)             # <<<<<<<<<<<<<<
 *             #Generate pword of compound term
 *             self.ref.set(pyclp.ec_term_array(self.ec_dict_ptr,array_pword))
 */
    __pyx_v_self->ec_dict_ptr = ec_did(__pyx_v_c_string, __pyx_v_arity);

    /* "pyclp/pyclp.pyx":949
 *             self.ec_dict_ptr=pyclp.ec_did(c_string,arity)
 *             #Generate pword of compound term
 *             self.ref.set(pyclp.ec_term_array(self.ec_dict_ptr,array_pword))             # <<<<<<<<<<<<<<
 *             libc.stdlib.free(array_pword)
 *     cpdef int arity(self):
 */
    ((struct __pyx_vtabstruct_5pyclp_5pyclp_Ref *)__pyx_v_self->__pyx_base.ref->__pyx_vtab)->set(__pyx_v_self->__pyx_base.ref, ec_term_array(__pyx_v_self->ec_dict_ptr, __pyx_v_array_pword));

    /* "pyclp/pyclp.pyx":950
 *             #Generate pword of compound term
 *             self.ref.set(pyclp.ec_term_array(self.ec_dict_ptr,array_pword))
 *             libc.stdlib.free(array_pword)             # <<<<<<<<<<<<<<
 *     cpdef int arity(self):
 *         """
 */
    free(__pyx_v_array_pword);

    /* "pyclp/pyclp.pyx":930
 *         Term.__init__(self,None)
 *         args=list(args)
 *         if functor_string is not None:             # <<<<<<<<<<<<<<
 *             arity=len(args)
 *             if arity ==0:
 */
  }

  /* "pyclp/pyclp.pyx":923
 *     """
 *     cdef pyclp.dident ec_dict_ptr
 *     def __init__(self,functor_string,*args):             # <<<<<<<<<<<<<<
 *         cdef int arity
 *         cdef int index
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pyclp.pyclp.Compound.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_args);
  __Pyx_XDECREF(__pyx_v_py_byte_string);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":951
 *             self.ref.set(pyclp.ec_term_array(self.ec_dict_ptr,array_pword))
 *             libc.stdlib.free(array_pword)
 *     cpdef int arity(self):             # <<<<<<<<<<<<<<
 *         """
 *         :return: arity of Compound object.
 */

static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_3arity(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static int __pyx_f_5pyclp_5pyclp_8Compound_arity(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self, int __pyx_skip_dispatch) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("arity", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_arity); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 951, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_5pyclp_5pyclp_8Compound_3arity)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 951, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 951, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "pyclp/pyclp.pyx":955
 *         :return: arity of Compound object.
 *         """
 *         return pyclp.DidArity(self.ec_dict_ptr)             # <<<<<<<<<<<<<<
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:
 *         Term.set_pword(self,in_pword)
 */
  __pyx_r = DidArity(__pyx_v_self->ec_dict_ptr);
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":951
 *             self.ref.set(pyclp.ec_term_array(self.ec_dict_ptr,array_pword))
 *             libc.stdlib.free(array_pword)
 *     cpdef int arity(self):             # <<<<<<<<<<<<<<
 *         """
 *         :return: arity of Compound object.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("pyclp.pyclp.Compound.arity", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_3arity(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_8Compound_2arity[] = "\n        :return: arity of Compound object.\n        ";
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_3arity(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("arity (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_8Compound_2arity(((struct __pyx_obj_5pyclp_5pyclp_Compound *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_2arity(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("arity", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_f_5pyclp_5pyclp_8Compound_arity(__pyx_v_self, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 951, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Compound.arity", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":956
 *         """
 *         return pyclp.DidArity(self.ec_dict_ptr)
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:             # <<<<<<<<<<<<<<
 *         Term.set_pword(self,in_pword)
 *         if ec_get_functor(self.get_pword(),&(self.ec_dict_ptr)) != pyclp.PSUCCEED:
 */

static int __pyx_f_5pyclp_5pyclp_8Compound_set_pword(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self, pword __pyx_v_in_pword) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("set_pword", 0);

  /* "pyclp/pyclp.pyx":957
 *         return pyclp.DidArity(self.ec_dict_ptr)
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:
 *         Term.set_pword(self,in_pword)             # <<<<<<<<<<<<<<
 *         if ec_get_functor(self.get_pword(),&(self.ec_dict_ptr)) != pyclp.PSUCCEED:
 *             raise pyclpEx("Failed retrieving of Functor dictionary item")
 */
  __pyx_t_1 = __pyx_f_5pyclp_5pyclp_4Term_set_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self), __pyx_v_in_pword); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 957, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":958
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:
 *         Term.set_pword(self,in_pword)
 *         if ec_get_functor(self.get_pword(),&(self.ec_dict_ptr)) != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             raise pyclpEx("Failed retrieving of Functor dictionary item")
 *     cdef object get_functor_string(self):
 */
  __pyx_t_2 = ((ec_get_functor(((struct __pyx_vtabstruct_5pyclp_5pyclp_Compound *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self)), (&__pyx_v_self->ec_dict_ptr)) != PSUCCEED) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "pyclp/pyclp.pyx":959
 *         Term.set_pword(self,in_pword)
 *         if ec_get_functor(self.get_pword(),&(self.ec_dict_ptr)) != pyclp.PSUCCEED:
 *             raise pyclpEx("Failed retrieving of Functor dictionary item")             # <<<<<<<<<<<<<<
 *     cdef object get_functor_string(self):
 *         cdef char* Name
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 959, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_kp_s_Failed_retrieving_of_Functor_dic) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_kp_s_Failed_retrieving_of_Functor_dic);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 959, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 959, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":958
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:
 *         Term.set_pword(self,in_pword)
 *         if ec_get_functor(self.get_pword(),&(self.ec_dict_ptr)) != pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             raise pyclpEx("Failed retrieving of Functor dictionary item")
 *     cdef object get_functor_string(self):
 */
  }

  /* "pyclp/pyclp.pyx":956
 *         """
 *         return pyclp.DidArity(self.ec_dict_ptr)
 *     cdef int set_pword(self,pyclp.pword in_pword) except -1:             # <<<<<<<<<<<<<<
 *         Term.set_pword(self,in_pword)
 *         if ec_get_functor(self.get_pword(),&(self.ec_dict_ptr)) != pyclp.PSUCCEED:
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pyclp.pyclp.Compound.set_pword", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":960
 *         if ec_get_functor(self.get_pword(),&(self.ec_dict_ptr)) != pyclp.PSUCCEED:
 *             raise pyclpEx("Failed retrieving of Functor dictionary item")
 *     cdef object get_functor_string(self):             # <<<<<<<<<<<<<<
 *         cdef char* Name
 *         Name=DidName(self.ec_dict_ptr)
 */

static PyObject *__pyx_f_5pyclp_5pyclp_8Compound_get_functor_string(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self) {
  char *__pyx_v_Name;
  PyObject *__pyx_v_string = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("get_functor_string", 0);

  /* "pyclp/pyclp.pyx":962
 *     cdef object get_functor_string(self):
 *         cdef char* Name
 *         Name=DidName(self.ec_dict_ptr)             # <<<<<<<<<<<<<<
 *         string=tounicode(Name)
 *         return string
 */
  __pyx_v_Name = DidName(__pyx_v_self->ec_dict_ptr);

  /* "pyclp/pyclp.pyx":963
 *         cdef char* Name
 *         Name=DidName(self.ec_dict_ptr)
 *         string=tounicode(Name)             # <<<<<<<<<<<<<<
 *         return string
 *     def functor(self):
 */
  __pyx_t_1 = __pyx_f_5pyclp_5pyclp_tounicode(__pyx_v_Name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 963, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_string = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":964
 *         Name=DidName(self.ec_dict_ptr)
 *         string=tounicode(Name)
 *         return string             # <<<<<<<<<<<<<<
 *     def functor(self):
 *         """
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_string);
  __pyx_r = __pyx_v_string;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":960
 *         if ec_get_functor(self.get_pword(),&(self.ec_dict_ptr)) != pyclp.PSUCCEED:
 *             raise pyclpEx("Failed retrieving of Functor dictionary item")
 *     cdef object get_functor_string(self):             # <<<<<<<<<<<<<<
 *         cdef char* Name
 *         Name=DidName(self.ec_dict_ptr)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Compound.get_functor_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_string);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":965
 *         string=tounicode(Name)
 *         return string
 *     def functor(self):             # <<<<<<<<<<<<<<
 *         """
 *         :return: string storing name of functor
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_5functor(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_8Compound_4functor[] = "        \n        :return: string storing name of functor\n        ";
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_5functor(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("functor (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_8Compound_4functor(((struct __pyx_obj_5pyclp_5pyclp_Compound *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_4functor(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("functor", 0);

  /* "pyclp/pyclp.pyx":969
 *         :return: string storing name of functor
 *         """
 *         return self.get_functor_string()             # <<<<<<<<<<<<<<
 *     def arguments(self):
 *         """
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Compound *)__pyx_v_self->__pyx_base.__pyx_vtab)->get_functor_string(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 969, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":965
 *         string=tounicode(Name)
 *         return string
 *     def functor(self):             # <<<<<<<<<<<<<<
 *         """
 *         :return: string storing name of functor
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Compound.functor", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_5pyclp_5pyclp_8Compound_8generator2(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "pyclp/pyclp.pyx":970
 *         """
 *         return self.get_functor_string()
 *     def arguments(self):             # <<<<<<<<<<<<<<
 *         """
 *         Return an iterator over compound term arguments
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_7arguments(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_8Compound_6arguments[] = "\n        Return an iterator over compound term arguments\n        ";
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_7arguments(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("arguments (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_8Compound_6arguments(((struct __pyx_obj_5pyclp_5pyclp_Compound *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_6arguments(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self) {
  struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("arguments", 0);
  __pyx_cur_scope = (struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments *)__pyx_tp_new_5pyclp_5pyclp___pyx_scope_struct_2_arguments(__pyx_ptype_5pyclp_5pyclp___pyx_scope_struct_2_arguments, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 970, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_self = __pyx_v_self;
  __Pyx_INCREF((PyObject *)__pyx_cur_scope->__pyx_v_self);
  __Pyx_GIVEREF((PyObject *)__pyx_cur_scope->__pyx_v_self);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_5pyclp_5pyclp_8Compound_8generator2, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_arguments, __pyx_n_s_Compound_arguments, __pyx_n_s_pyclp_pyclp); if (unlikely(!gen)) __PYX_ERR(0, 970, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyclp.pyclp.Compound.arguments", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_5pyclp_5pyclp_8Compound_8generator2(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments *__pyx_cur_scope = ((struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("arguments", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    case 1: goto __pyx_L7_resume_from_yield;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 970, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":977
 *         cdef pyclp.pword arg_pword
 *         cdef int result
 *         for index in range(self.arity()):             # <<<<<<<<<<<<<<
 *             result=pyclp.ec_get_arg(index+1,self.get_pword(),&arg_pword)
 *             if result == pyclp.PSUCCEED:
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Compound *)__pyx_cur_scope->__pyx_v_self->__pyx_base.__pyx_vtab)->arity(__pyx_cur_scope->__pyx_v_self, 0);
  __pyx_t_2 = __pyx_t_1;
  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
    __pyx_cur_scope->__pyx_v_index = __pyx_t_3;

    /* "pyclp/pyclp.pyx":978
 *         cdef int result
 *         for index in range(self.arity()):
 *             result=pyclp.ec_get_arg(index+1,self.get_pword(),&arg_pword)             # <<<<<<<<<<<<<<
 *             if result == pyclp.PSUCCEED:
 *                 yield pword2object(arg_pword)
 */
    __pyx_cur_scope->__pyx_v_result = ec_get_arg((__pyx_cur_scope->__pyx_v_index + 1), ((struct __pyx_vtabstruct_5pyclp_5pyclp_Compound *)__pyx_cur_scope->__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_cur_scope->__pyx_v_self)), (&__pyx_cur_scope->__pyx_v_arg_pword));

    /* "pyclp/pyclp.pyx":979
 *         for index in range(self.arity()):
 *             result=pyclp.ec_get_arg(index+1,self.get_pword(),&arg_pword)
 *             if result == pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *                 yield pword2object(arg_pword)
 *             elif result == pyclp.RANGE_ERROR:
 */
    __pyx_t_4 = ((__pyx_cur_scope->__pyx_v_result == PSUCCEED) != 0);
    if (__pyx_t_4) {

      /* "pyclp/pyclp.pyx":980
 *             result=pyclp.ec_get_arg(index+1,self.get_pword(),&arg_pword)
 *             if result == pyclp.PSUCCEED:
 *                 yield pword2object(arg_pword)             # <<<<<<<<<<<<<<
 *             elif result == pyclp.RANGE_ERROR:
 *                 raise pyclpEx("Functor arity bigger than available args")
 */
      __pyx_t_5 = __pyx_f_5pyclp_5pyclp_pword2object(__pyx_cur_scope->__pyx_v_arg_pword); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 980, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_r = __pyx_t_5;
      __pyx_t_5 = 0;
      __pyx_cur_scope->__pyx_t_0 = __pyx_t_1;
      __pyx_cur_scope->__pyx_t_1 = __pyx_t_2;
      __pyx_cur_scope->__pyx_t_2 = __pyx_t_3;
      __Pyx_XGIVEREF(__pyx_r);
      __Pyx_RefNannyFinishContext();
      __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
      /* return from generator, yielding value */
      __pyx_generator->resume_label = 1;
      return __pyx_r;
      __pyx_L7_resume_from_yield:;
      __pyx_t_1 = __pyx_cur_scope->__pyx_t_0;
      __pyx_t_2 = __pyx_cur_scope->__pyx_t_1;
      __pyx_t_3 = __pyx_cur_scope->__pyx_t_2;
      if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 980, __pyx_L1_error)

      /* "pyclp/pyclp.pyx":979
 *         for index in range(self.arity()):
 *             result=pyclp.ec_get_arg(index+1,self.get_pword(),&arg_pword)
 *             if result == pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *                 yield pword2object(arg_pword)
 *             elif result == pyclp.RANGE_ERROR:
 */
      goto __pyx_L6;
    }

    /* "pyclp/pyclp.pyx":981
 *             if result == pyclp.PSUCCEED:
 *                 yield pword2object(arg_pword)
 *             elif result == pyclp.RANGE_ERROR:             # <<<<<<<<<<<<<<
 *                 raise pyclpEx("Functor arity bigger than available args")
 *             else:
 */
    __pyx_t_4 = ((__pyx_cur_scope->__pyx_v_result == RANGE_ERROR) != 0);
    if (unlikely(__pyx_t_4)) {

      /* "pyclp/pyclp.pyx":982
 *                 yield pword2object(arg_pword)
 *             elif result == pyclp.RANGE_ERROR:
 *                 raise pyclpEx("Functor arity bigger than available args")             # <<<<<<<<<<<<<<
 *             else:
 *                 raise pyclpEx("Unknow error during args getting")
 */
      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 982, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_7)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_7);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_kp_s_Functor_arity_bigger_than_availa) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_kp_s_Functor_arity_bigger_than_availa);
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 982, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __PYX_ERR(0, 982, __pyx_L1_error)

      /* "pyclp/pyclp.pyx":981
 *             if result == pyclp.PSUCCEED:
 *                 yield pword2object(arg_pword)
 *             elif result == pyclp.RANGE_ERROR:             # <<<<<<<<<<<<<<
 *                 raise pyclpEx("Functor arity bigger than available args")
 *             else:
 */
    }

    /* "pyclp/pyclp.pyx":984
 *                 raise pyclpEx("Functor arity bigger than available args")
 *             else:
 *                 raise pyclpEx("Unknow error during args getting")             # <<<<<<<<<<<<<<
 *     def __iter__(self):
 *         return self.arguments()
 */
    /*else*/ {
      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 984, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_7)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_7);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_kp_s_Unknow_error_during_args_getting) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_kp_s_Unknow_error_during_args_getting);
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 984, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __PYX_ERR(0, 984, __pyx_L1_error)
    }
    __pyx_L6:;
  }
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* "pyclp/pyclp.pyx":970
 *         """
 *         return self.get_functor_string()
 *     def arguments(self):             # <<<<<<<<<<<<<<
 *         """
 *         Return an iterator over compound term arguments
 */

  /* function exit code */
  PyErr_SetNone(PyExc_StopIteration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("arguments", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":985
 *             else:
 *                 raise pyclpEx("Unknow error during args getting")
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self.arguments()
 *     def __len__(self):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_10__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_10__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_8Compound_9__iter__(((struct __pyx_obj_5pyclp_5pyclp_Compound *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_9__iter__(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__iter__", 0);

  /* "pyclp/pyclp.pyx":986
 *                 raise pyclpEx("Unknow error during args getting")
 *     def __iter__(self):
 *         return self.arguments()             # <<<<<<<<<<<<<<
 *     def __len__(self):
 *         return self.arity()
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_arguments); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 986, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 986, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":985
 *             else:
 *                 raise pyclpEx("Unknow error during args getting")
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self.arguments()
 *     def __len__(self):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pyclp.pyclp.Compound.__iter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":987
 *     def __iter__(self):
 *         return self.arguments()
 *     def __len__(self):             # <<<<<<<<<<<<<<
 *         return self.arity()
 *     def __getitem__(self,index):
 */

/* Python wrapper */
static Py_ssize_t __pyx_pw_5pyclp_5pyclp_8Compound_12__len__(PyObject *__pyx_v_self); /*proto*/
static Py_ssize_t __pyx_pw_5pyclp_5pyclp_8Compound_12__len__(PyObject *__pyx_v_self) {
  Py_ssize_t __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__len__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_8Compound_11__len__(((struct __pyx_obj_5pyclp_5pyclp_Compound *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static Py_ssize_t __pyx_pf_5pyclp_5pyclp_8Compound_11__len__(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self) {
  Py_ssize_t __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__len__", 0);

  /* "pyclp/pyclp.pyx":988
 *         return self.arguments()
 *     def __len__(self):
 *         return self.arity()             # <<<<<<<<<<<<<<
 *     def __getitem__(self,index):
 *         cdef int arity
 */
  __pyx_r = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Compound *)__pyx_v_self->__pyx_base.__pyx_vtab)->arity(__pyx_v_self, 0);
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":987
 *     def __iter__(self):
 *         return self.arguments()
 *     def __len__(self):             # <<<<<<<<<<<<<<
 *         return self.arity()
 *     def __getitem__(self,index):
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":989
 *     def __len__(self):
 *         return self.arity()
 *     def __getitem__(self,index):             # <<<<<<<<<<<<<<
 *         cdef int arity
 *         cdef int result
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_14__getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_14__getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__getitem__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_8Compound_13__getitem__(((struct __pyx_obj_5pyclp_5pyclp_Compound *)__pyx_v_self), ((PyObject *)__pyx_v_index));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_13__getitem__(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self, PyObject *__pyx_v_index) {
  int __pyx_v_arity;
  int __pyx_v_result;
  pword __pyx_v_arg_pword;
  int __pyx_v_c_index;
  PyObject *__pyx_v_item_returned = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__getitem__", 0);

  /* "pyclp/pyclp.pyx":994
 *         cdef pyclp.pword arg_pword
 *         cdef int c_index
 *         arity=self.arity()             # <<<<<<<<<<<<<<
 *         if not isinstance(index,int):
 *             raise TypeError("Index shall be a integer")
 */
  __pyx_v_arity = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Compound *)__pyx_v_self->__pyx_base.__pyx_vtab)->arity(__pyx_v_self, 0);

  /* "pyclp/pyclp.pyx":995
 *         cdef int c_index
 *         arity=self.arity()
 *         if not isinstance(index,int):             # <<<<<<<<<<<<<<
 *             raise TypeError("Index shall be a integer")
 *         else:
 */
  __pyx_t_1 = PyInt_Check(__pyx_v_index); 
  __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "pyclp/pyclp.pyx":996
 *         arity=self.arity()
 *         if not isinstance(index,int):
 *             raise TypeError("Index shall be a integer")             # <<<<<<<<<<<<<<
 *         else:
 *             c_index=<int>index
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 996, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 996, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":995
 *         cdef int c_index
 *         arity=self.arity()
 *         if not isinstance(index,int):             # <<<<<<<<<<<<<<
 *             raise TypeError("Index shall be a integer")
 *         else:
 */
  }

  /* "pyclp/pyclp.pyx":998
 *             raise TypeError("Index shall be a integer")
 *         else:
 *             c_index=<int>index             # <<<<<<<<<<<<<<
 *         if c_index < 0:
 *             c_index=arity+c_index
 */
  /*else*/ {
    __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_v_index); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 998, __pyx_L1_error)
    __pyx_v_c_index = ((int)__pyx_t_4);
  }

  /* "pyclp/pyclp.pyx":999
 *         else:
 *             c_index=<int>index
 *         if c_index < 0:             # <<<<<<<<<<<<<<
 *             c_index=arity+c_index
 *         if (<int>abs(c_index)) >=  arity:
 */
  __pyx_t_2 = ((__pyx_v_c_index < 0) != 0);
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":1000
 *             c_index=<int>index
 *         if c_index < 0:
 *             c_index=arity+c_index             # <<<<<<<<<<<<<<
 *         if (<int>abs(c_index)) >=  arity:
 *             raise IndexError("Argument index out of range {0} arity {1}".format(index,arity))
 */
    __pyx_v_c_index = (__pyx_v_arity + __pyx_v_c_index);

    /* "pyclp/pyclp.pyx":999
 *         else:
 *             c_index=<int>index
 *         if c_index < 0:             # <<<<<<<<<<<<<<
 *             c_index=arity+c_index
 *         if (<int>abs(c_index)) >=  arity:
 */
  }

  /* "pyclp/pyclp.pyx":1001
 *         if c_index < 0:
 *             c_index=arity+c_index
 *         if (<int>abs(c_index)) >=  arity:             # <<<<<<<<<<<<<<
 *             raise IndexError("Argument index out of range {0} arity {1}".format(index,arity))
 * 
 */
  __pyx_t_4 = abs(__pyx_v_c_index); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 1001, __pyx_L1_error)
  __pyx_t_2 = ((((int)__pyx_t_4) >= __pyx_v_arity) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "pyclp/pyclp.pyx":1002
 *             c_index=arity+c_index
 *         if (<int>abs(c_index)) >=  arity:
 *             raise IndexError("Argument index out of range {0} arity {1}".format(index,arity))             # <<<<<<<<<<<<<<
 * 
 *         result=pyclp.ec_get_arg(c_index+1,self.get_pword(),&arg_pword)
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Argument_index_out_of_range_0_ar, __pyx_n_s_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1002, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = __Pyx_PyInt_From_int(__pyx_v_arity); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1002, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = NULL;
    __pyx_t_4 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
        __pyx_t_4 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_index, __pyx_t_6};
      __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1002, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_index, __pyx_t_6};
      __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1002, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else
    #endif
    {
      __pyx_t_8 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1002, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      if (__pyx_t_7) {
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __pyx_t_7 = NULL;
      }
      __Pyx_INCREF(__pyx_v_index);
      __Pyx_GIVEREF(__pyx_v_index);
      PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_4, __pyx_v_index);
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_4, __pyx_t_6);
      __pyx_t_6 = 0;
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1002, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1002, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 1002, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":1001
 *         if c_index < 0:
 *             c_index=arity+c_index
 *         if (<int>abs(c_index)) >=  arity:             # <<<<<<<<<<<<<<
 *             raise IndexError("Argument index out of range {0} arity {1}".format(index,arity))
 * 
 */
  }

  /* "pyclp/pyclp.pyx":1004
 *             raise IndexError("Argument index out of range {0} arity {1}".format(index,arity))
 * 
 *         result=pyclp.ec_get_arg(c_index+1,self.get_pword(),&arg_pword)             # <<<<<<<<<<<<<<
 *         if result == pyclp.PSUCCEED:
 *             item_returned=pword2object(arg_pword)
 */
  __pyx_v_result = ec_get_arg((__pyx_v_c_index + 1), ((struct __pyx_vtabstruct_5pyclp_5pyclp_Compound *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.get_pword(((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_v_self)), (&__pyx_v_arg_pword));

  /* "pyclp/pyclp.pyx":1005
 * 
 *         result=pyclp.ec_get_arg(c_index+1,self.get_pword(),&arg_pword)
 *         if result == pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             item_returned=pword2object(arg_pword)
 *         elif result == pyclp.RANGE_ERROR:
 */
  __pyx_t_2 = ((__pyx_v_result == PSUCCEED) != 0);
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":1006
 *         result=pyclp.ec_get_arg(c_index+1,self.get_pword(),&arg_pword)
 *         if result == pyclp.PSUCCEED:
 *             item_returned=pword2object(arg_pword)             # <<<<<<<<<<<<<<
 *         elif result == pyclp.RANGE_ERROR:
 *             raise pyclpEx("Range error while getting args probably data corruption")
 */
    __pyx_t_5 = __pyx_f_5pyclp_5pyclp_pword2object(__pyx_v_arg_pword); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1006, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_v_item_returned = __pyx_t_5;
    __pyx_t_5 = 0;

    /* "pyclp/pyclp.pyx":1005
 * 
 *         result=pyclp.ec_get_arg(c_index+1,self.get_pword(),&arg_pword)
 *         if result == pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             item_returned=pword2object(arg_pword)
 *         elif result == pyclp.RANGE_ERROR:
 */
    goto __pyx_L6;
  }

  /* "pyclp/pyclp.pyx":1007
 *         if result == pyclp.PSUCCEED:
 *             item_returned=pword2object(arg_pword)
 *         elif result == pyclp.RANGE_ERROR:             # <<<<<<<<<<<<<<
 *             raise pyclpEx("Range error while getting args probably data corruption")
 *         else:
 */
  __pyx_t_2 = ((__pyx_v_result == RANGE_ERROR) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "pyclp/pyclp.pyx":1008
 *             item_returned=pword2object(arg_pword)
 *         elif result == pyclp.RANGE_ERROR:
 *             raise pyclpEx("Range error while getting args probably data corruption")             # <<<<<<<<<<<<<<
 *         else:
 *             raise pyclpEx("Unknow error during args getting")
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1008, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_8 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_5 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_8, __pyx_kp_s_Range_error_while_getting_args_p) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_Range_error_while_getting_args_p);
    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1008, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 1008, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":1007
 *         if result == pyclp.PSUCCEED:
 *             item_returned=pword2object(arg_pword)
 *         elif result == pyclp.RANGE_ERROR:             # <<<<<<<<<<<<<<
 *             raise pyclpEx("Range error while getting args probably data corruption")
 *         else:
 */
  }

  /* "pyclp/pyclp.pyx":1010
 *             raise pyclpEx("Range error while getting args probably data corruption")
 *         else:
 *             raise pyclpEx("Unknow error during args getting")             # <<<<<<<<<<<<<<
 * 
 *         return item_returned
 */
  /*else*/ {
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pyclpEx); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1010, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_8 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_5 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_8, __pyx_kp_s_Unknow_error_during_args_getting) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_Unknow_error_during_args_getting);
    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1010, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 1010, __pyx_L1_error)
  }
  __pyx_L6:;

  /* "pyclp/pyclp.pyx":1012
 *             raise pyclpEx("Unknow error during args getting")
 * 
 *         return item_returned             # <<<<<<<<<<<<<<
 * 
 *     def __str__(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_item_returned);
  __pyx_r = __pyx_v_item_returned;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":989
 *     def __len__(self):
 *         return self.arity()
 *     def __getitem__(self,index):             # <<<<<<<<<<<<<<
 *         cdef int arity
 *         cdef int result
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("pyclp.pyclp.Compound.__getitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_item_returned);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":1014
 *         return item_returned
 * 
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         cdef int arity
 *         cdef list list_args_text
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_16__str__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_16__str__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__str__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_8Compound_15__str__(((struct __pyx_obj_5pyclp_5pyclp_Compound *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_15__str__(struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self) {
  PyObject *__pyx_v_list_args_text = 0;
  PyObject *__pyx_v_functor_string = NULL;
  PyObject *__pyx_v_result = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__str__", 0);

  /* "pyclp/pyclp.pyx":1017
 *         cdef int arity
 *         cdef list list_args_text
 *         list_args_text=[]             # <<<<<<<<<<<<<<
 *         functor_string=self.get_functor_string()
 *         list_args_text=list(map(formatTermStr,self.arguments()))
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1017, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_list_args_text = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":1018
 *         cdef list list_args_text
 *         list_args_text=[]
 *         functor_string=self.get_functor_string()             # <<<<<<<<<<<<<<
 *         list_args_text=list(map(formatTermStr,self.arguments()))
 *         result=str.join(",",list_args_text)
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Compound *)__pyx_v_self->__pyx_base.__pyx_vtab)->get_functor_string(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1018, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_functor_string = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":1019
 *         list_args_text=[]
 *         functor_string=self.get_functor_string()
 *         list_args_text=list(map(formatTermStr,self.arguments()))             # <<<<<<<<<<<<<<
 *         result=str.join(",",list_args_text)
 *         result="{0!s}({1})".format(functor_string,result)
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_formatTermStr); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1019, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_arguments); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1019, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1019, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1019, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_map, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1019, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PySequence_List(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1019, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF_SET(__pyx_v_list_args_text, ((PyObject*)__pyx_t_3));
  __pyx_t_3 = 0;

  /* "pyclp/pyclp.pyx":1020
 *         functor_string=self.get_functor_string()
 *         list_args_text=list(map(formatTermStr,self.arguments()))
 *         result=str.join(",",list_args_text)             # <<<<<<<<<<<<<<
 *         result="{0!s}({1})".format(functor_string,result)
 *         return result
 */
  __pyx_t_3 = __Pyx_PyString_Join(__pyx_kp_s__24, __pyx_v_list_args_text); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1020, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_v_result = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "pyclp/pyclp.pyx":1021
 *         list_args_text=list(map(formatTermStr,self.arguments()))
 *         result=str.join(",",list_args_text)
 *         result="{0!s}({1})".format(functor_string,result)             # <<<<<<<<<<<<<<
 *         return result
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_0_s_1, __pyx_n_s_format); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1021, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = NULL;
  __pyx_t_5 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_5 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_v_functor_string, __pyx_v_result};
    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1021, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_GOTREF(__pyx_t_3);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_v_functor_string, __pyx_v_result};
    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1021, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_GOTREF(__pyx_t_3);
  } else
  #endif
  {
    __pyx_t_4 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1021, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (__pyx_t_1) {
      __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1); __pyx_t_1 = NULL;
    }
    __Pyx_INCREF(__pyx_v_functor_string);
    __Pyx_GIVEREF(__pyx_v_functor_string);
    PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_5, __pyx_v_functor_string);
    __Pyx_INCREF(__pyx_v_result);
    __Pyx_GIVEREF(__pyx_v_result);
    PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_5, __pyx_v_result);
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1021, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_3);
  __pyx_t_3 = 0;

  /* "pyclp/pyclp.pyx":1022
 *         result=str.join(",",list_args_text)
 *         result="{0!s}({1})".format(functor_string,result)
 *         return result             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_result);
  __pyx_r = __pyx_v_result;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":1014
 *         return item_returned
 * 
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         cdef int arity
 *         cdef list list_args_text
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pyclp.pyclp.Compound.__str__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_list_args_text);
  __Pyx_XDECREF(__pyx_v_functor_string);
  __Pyx_XDECREF(__pyx_v_result);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_18__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_18__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_8Compound_17__reduce_cython__(((struct __pyx_obj_5pyclp_5pyclp_Compound *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_17__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Compound.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_20__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_8Compound_20__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_8Compound_19__setstate_cython__(((struct __pyx_obj_5pyclp_5pyclp_Compound *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_8Compound_19__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Compound *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__29, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Compound.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":1035
 *     Class to create Prolog variable.
 *     """
 *     def __init__(self):             # <<<<<<<<<<<<<<
 *         Term.__init__(self,None)
 *     cpdef value(self):
 */

/* Python wrapper */
static int __pyx_pw_5pyclp_5pyclp_3Var_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pyclp_5pyclp_3Var_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__init__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__init__", 0))) return -1;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_3Var___init__(((struct __pyx_obj_5pyclp_5pyclp_Var *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pyclp_5pyclp_3Var___init__(struct __pyx_obj_5pyclp_5pyclp_Var *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "pyclp/pyclp.pyx":1036
 *     """
 *     def __init__(self):
 *         Term.__init__(self,None)             # <<<<<<<<<<<<<<
 *     cpdef value(self):
 *         """
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Term), __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1036, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  __pyx_t_4 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_4 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, ((PyObject *)__pyx_v_self), Py_None};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1036, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, ((PyObject *)__pyx_v_self), Py_None};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1036, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1036, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (__pyx_t_3) {
      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
    }
    __Pyx_INCREF(((PyObject *)__pyx_v_self));
    __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, ((PyObject *)__pyx_v_self));
    __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(Py_None);
    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, Py_None);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1036, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":1035
 *     Class to create Prolog variable.
 *     """
 *     def __init__(self):             # <<<<<<<<<<<<<<
 *         Term.__init__(self,None)
 *     cpdef value(self):
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pyclp.pyclp.Var.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":1037
 *     def __init__(self):
 *         Term.__init__(self,None)
 *     cpdef value(self):             # <<<<<<<<<<<<<<
 *         """
 *         :rtype: integer, float, string, :py:class:`PList`, :py:class:`Atom`, :py:class:`Compound`, None (if var is uninstantiated)
 */

static PyObject *__pyx_pw_5pyclp_5pyclp_3Var_3value(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_5pyclp_5pyclp_3Var_value(struct __pyx_obj_5pyclp_5pyclp_Var *__pyx_v_self, int __pyx_skip_dispatch) {
  pword __pyx_v_pword_value;
  PyObject *__pyx_v_result = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("value", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1037, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_5pyclp_5pyclp_3Var_3value)) {
        __Pyx_XDECREF(__pyx_r);
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1037, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_r = __pyx_t_2;
        __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "pyclp/pyclp.pyx":1043
 *         """
 *         cdef pyclp.pword pword_value
 *         pword_value=self.ref.get()             # <<<<<<<<<<<<<<
 *         if pyclp.ec_is_var(pword_value)== pyclp.PSUCCEED:
 *             result=None
 */
  __pyx_v_pword_value = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Ref *)__pyx_v_self->__pyx_base.ref->__pyx_vtab)->get(__pyx_v_self->__pyx_base.ref);

  /* "pyclp/pyclp.pyx":1044
 *         cdef pyclp.pword pword_value
 *         pword_value=self.ref.get()
 *         if pyclp.ec_is_var(pword_value)== pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             result=None
 *         else:
 */
  __pyx_t_5 = ((ec_is_var(__pyx_v_pword_value) == PSUCCEED) != 0);
  if (__pyx_t_5) {

    /* "pyclp/pyclp.pyx":1045
 *         pword_value=self.ref.get()
 *         if pyclp.ec_is_var(pword_value)== pyclp.PSUCCEED:
 *             result=None             # <<<<<<<<<<<<<<
 *         else:
 *             result=pword2object(pword_value)
 */
    __Pyx_INCREF(Py_None);
    __pyx_v_result = Py_None;

    /* "pyclp/pyclp.pyx":1044
 *         cdef pyclp.pword pword_value
 *         pword_value=self.ref.get()
 *         if pyclp.ec_is_var(pword_value)== pyclp.PSUCCEED:             # <<<<<<<<<<<<<<
 *             result=None
 *         else:
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":1047
 *             result=None
 *         else:
 *             result=pword2object(pword_value)             # <<<<<<<<<<<<<<
 *         return result
 *     def __str__(self):
 */
  /*else*/ {
    __pyx_t_1 = __pyx_f_5pyclp_5pyclp_pword2object(__pyx_v_pword_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1047, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_v_result = __pyx_t_1;
    __pyx_t_1 = 0;
  }
  __pyx_L3:;

  /* "pyclp/pyclp.pyx":1048
 *         else:
 *             result=pword2object(pword_value)
 *         return result             # <<<<<<<<<<<<<<
 *     def __str__(self):
 *         """
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_result);
  __pyx_r = __pyx_v_result;
  goto __pyx_L0;

  /* "pyclp/pyclp.pyx":1037
 *     def __init__(self):
 *         Term.__init__(self,None)
 *     cpdef value(self):             # <<<<<<<<<<<<<<
 *         """
 *         :rtype: integer, float, string, :py:class:`PList`, :py:class:`Atom`, :py:class:`Compound`, None (if var is uninstantiated)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pyclp.pyclp.Var.value", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_result);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_3Var_3value(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_3Var_2value[] = "\n        :rtype: integer, float, string, :py:class:`PList`, :py:class:`Atom`, :py:class:`Compound`, None (if var is uninstantiated)\n        \n        ";
static PyObject *__pyx_pw_5pyclp_5pyclp_3Var_3value(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("value (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_3Var_2value(((struct __pyx_obj_5pyclp_5pyclp_Var *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_3Var_2value(struct __pyx_obj_5pyclp_5pyclp_Var *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("value", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_5pyclp_5pyclp_3Var_value(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1037, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Var.value", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":1049
 *             result=pword2object(pword_value)
 *         return result
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         """
 *         :return: Return pretty print string of object unified to this variable.\
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_3Var_5__str__(PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_3Var_4__str__[] = "\n        :return: Return pretty print string of object unified to this variable.        If variable is uninstantiated it returns '_'\n        ";
#if CYTHON_UPDATE_DESCRIPTOR_DOC
struct wrapperbase __pyx_wrapperbase_5pyclp_5pyclp_3Var_4__str__;
#endif
static PyObject *__pyx_pw_5pyclp_5pyclp_3Var_5__str__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__str__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_3Var_4__str__(((struct __pyx_obj_5pyclp_5pyclp_Var *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_3Var_4__str__(struct __pyx_obj_5pyclp_5pyclp_Var *__pyx_v_self) {
  PyObject *__pyx_v_var_value = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__str__", 0);

  /* "pyclp/pyclp.pyx":1054
 *         If variable is uninstantiated it returns '_'
 *         """
 *         var_value=self.value()             # <<<<<<<<<<<<<<
 *         if var_value is None:
 *             return "_"
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_5pyclp_5pyclp_Var *)__pyx_v_self->__pyx_base.__pyx_vtab)->value(__pyx_v_self, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1054, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_var_value = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":1055
 *         """
 *         var_value=self.value()
 *         if var_value is None:             # <<<<<<<<<<<<<<
 *             return "_"
 *         else:
 */
  __pyx_t_2 = (__pyx_v_var_value == Py_None);
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "pyclp/pyclp.pyx":1056
 *         var_value=self.value()
 *         if var_value is None:
 *             return "_"             # <<<<<<<<<<<<<<
 *         else:
 *             return str(var_value)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_n_s__30);
    __pyx_r = __pyx_n_s__30;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":1055
 *         """
 *         var_value=self.value()
 *         if var_value is None:             # <<<<<<<<<<<<<<
 *             return "_"
 *         else:
 */
  }

  /* "pyclp/pyclp.pyx":1058
 *             return "_"
 *         else:
 *             return str(var_value)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_var_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1058, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;
  }

  /* "pyclp/pyclp.pyx":1049
 *             result=pword2object(pword_value)
 *         return result
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         """
 *         :return: Return pretty print string of object unified to this variable.\
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Var.__str__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_var_value);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_3Var_7__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_3Var_7__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_3Var_6__reduce_cython__(((struct __pyx_obj_5pyclp_5pyclp_Var *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_3Var_6__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Var *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__31, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Var.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_3Var_9__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static PyObject *__pyx_pw_5pyclp_5pyclp_3Var_9__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pyclp_5pyclp_3Var_8__setstate_cython__(((struct __pyx_obj_5pyclp_5pyclp_Var *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_3Var_8__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyclp_5pyclp_Var *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__32, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyclp.pyclp.Var.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":1062
 * 
 * 
 * def unify(term1,term2):             # <<<<<<<<<<<<<<
 *     """
 *     Implements unify as described in
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_13unify(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_12unify[] = "\n    Implements unify as described in \n    `ec_unify <http://www.eclipseclp.org/doc/embedding/embroot013.html>`_\n    This function shall be used only inside python function tha are called\n    from ECLiPSe\n    \n    :type term1: pyclp.Var, pyclp.Compound, pyclp.PList    \n    :type term2: pyclp.Var, pyclp.Compound, pyclp.PList\n    \n    :returns: pyclp.SUCCEED or pyclp.FAIL  \n    \n    ";
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_13unify = {"unify", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyclp_5pyclp_13unify, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyclp_5pyclp_12unify};
static PyObject *__pyx_pw_5pyclp_5pyclp_13unify(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_term1 = 0;
  PyObject *__pyx_v_term2 = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("unify (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_term1,&__pyx_n_s_term2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_term1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_term2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("unify", 1, 2, 2, 1); __PYX_ERR(0, 1062, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "unify") < 0)) __PYX_ERR(0, 1062, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_term1 = values[0];
    __pyx_v_term2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("unify", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1062, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.unify", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_12unify(__pyx_self, __pyx_v_term1, __pyx_v_term2);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_12unify(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_term1, PyObject *__pyx_v_term2) {
  struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_term1_term = 0;
  struct __pyx_obj_5pyclp_5pyclp_Term *__pyx_v_term2_term = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("unify", 0);

  /* "pyclp/pyclp.pyx":1078
 *     cdef Term term2_term
 * 
 *     if not isinstance(term1,Term):             # <<<<<<<<<<<<<<
 *         term1_term=Term(term1)
 *     else:
 */
  __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_term1, __pyx_ptype_5pyclp_5pyclp_Term); 
  __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
  if (__pyx_t_2) {

    /* "pyclp/pyclp.pyx":1079
 * 
 *     if not isinstance(term1,Term):
 *         term1_term=Term(term1)             # <<<<<<<<<<<<<<
 *     else:
 *         term1_term=term1
 */
    __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Term), __pyx_v_term1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1079, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_term1_term = ((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_t_3);
    __pyx_t_3 = 0;

    /* "pyclp/pyclp.pyx":1078
 *     cdef Term term2_term
 * 
 *     if not isinstance(term1,Term):             # <<<<<<<<<<<<<<
 *         term1_term=Term(term1)
 *     else:
 */
    goto __pyx_L3;
  }

  /* "pyclp/pyclp.pyx":1081
 *         term1_term=Term(term1)
 *     else:
 *         term1_term=term1             # <<<<<<<<<<<<<<
 * 
 *     if not isinstance(term2,Term):
 */
  /*else*/ {
    if (!(likely(((__pyx_v_term1) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_term1, __pyx_ptype_5pyclp_5pyclp_Term))))) __PYX_ERR(0, 1081, __pyx_L1_error)
    __pyx_t_3 = __pyx_v_term1;
    __Pyx_INCREF(__pyx_t_3);
    __pyx_v_term1_term = ((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_t_3);
    __pyx_t_3 = 0;
  }
  __pyx_L3:;

  /* "pyclp/pyclp.pyx":1083
 *         term1_term=term1
 * 
 *     if not isinstance(term2,Term):             # <<<<<<<<<<<<<<
 *         term2_term=Term(term2)
 *     else:
 */
  __pyx_t_2 = __Pyx_TypeCheck(__pyx_v_term2, __pyx_ptype_5pyclp_5pyclp_Term); 
  __pyx_t_1 = ((!(__pyx_t_2 != 0)) != 0);
  if (__pyx_t_1) {

    /* "pyclp/pyclp.pyx":1084
 * 
 *     if not isinstance(term2,Term):
 *         term2_term=Term(term2)             # <<<<<<<<<<<<<<
 *     else:
 *         term2_term=term2
 */
    __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_5pyclp_5pyclp_Term), __pyx_v_term2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1084, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_term2_term = ((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_t_3);
    __pyx_t_3 = 0;

    /* "pyclp/pyclp.pyx":1083
 *         term1_term=term1
 * 
 *     if not isinstance(term2,Term):             # <<<<<<<<<<<<<<
 *         term2_term=Term(term2)
 *     else:
 */
    goto __pyx_L4;
  }

  /* "pyclp/pyclp.pyx":1086
 *         term2_term=Term(term2)
 *     else:
 *         term2_term=term2             # <<<<<<<<<<<<<<
 * 
 *     if pyclp.PSUCCEED==pyclp.ec_unify(term1_term.get_pword(),term2_term.get_pword()):
 */
  /*else*/ {
    if (!(likely(((__pyx_v_term2) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_term2, __pyx_ptype_5pyclp_5pyclp_Term))))) __PYX_ERR(0, 1086, __pyx_L1_error)
    __pyx_t_3 = __pyx_v_term2;
    __Pyx_INCREF(__pyx_t_3);
    __pyx_v_term2_term = ((struct __pyx_obj_5pyclp_5pyclp_Term *)__pyx_t_3);
    __pyx_t_3 = 0;
  }
  __pyx_L4:;

  /* "pyclp/pyclp.pyx":1088
 *         term2_term=term2
 * 
 *     if pyclp.PSUCCEED==pyclp.ec_unify(term1_term.get_pword(),term2_term.get_pword()):             # <<<<<<<<<<<<<<
 *         return SUCCEED
 *     else:
 */
  __pyx_t_1 = ((PSUCCEED == ec_unify(((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)__pyx_v_term1_term->__pyx_vtab)->get_pword(__pyx_v_term1_term), ((struct __pyx_vtabstruct_5pyclp_5pyclp_Term *)__pyx_v_term2_term->__pyx_vtab)->get_pword(__pyx_v_term2_term))) != 0);
  if (__pyx_t_1) {

    /* "pyclp/pyclp.pyx":1089
 * 
 *     if pyclp.PSUCCEED==pyclp.ec_unify(term1_term.get_pword(),term2_term.get_pword()):
 *         return SUCCEED             # <<<<<<<<<<<<<<
 *     else:
 *         return FAIL
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_SUCCEED); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1089, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "pyclp/pyclp.pyx":1088
 *         term2_term=term2
 * 
 *     if pyclp.PSUCCEED==pyclp.ec_unify(term1_term.get_pword(),term2_term.get_pword()):             # <<<<<<<<<<<<<<
 *         return SUCCEED
 *     else:
 */
  }

  /* "pyclp/pyclp.pyx":1091
 *         return SUCCEED
 *     else:
 *         return FAIL             # <<<<<<<<<<<<<<
 * 
 * def addPythonFunction(eclipse_name,func):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_FAIL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1091, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;
  }

  /* "pyclp/pyclp.pyx":1062
 * 
 * 
 * def unify(term1,term2):             # <<<<<<<<<<<<<<
 *     """
 *     Implements unify as described in
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pyclp.pyclp.unify", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_term1_term);
  __Pyx_XDECREF((PyObject *)__pyx_v_term2_term);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyclp/pyclp.pyx":1093
 *         return FAIL
 * 
 * def addPythonFunction(eclipse_name,func):             # <<<<<<<<<<<<<<
 *     """
 *     Register a python function to be called from Eclipse using the predicate call_python.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pyclp_5pyclp_15addPythonFunction(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pyclp_5pyclp_14addPythonFunction[] = "\n    Register a python function to be called from Eclipse using the predicate call_python.\n    It shall be called after :py:func:`init`\n    \n    E.g. call_python(<eclipse_name>,<list of terms.>).\n    \n    The registered python function will be called as:\n    \n    <func>(<list of terms>)\n    \n    The registered function shall return pyclp.SUCCEED or any other value for reporting FAIL. \n    \n    :param eclipse_name: str or byte string. Name to be used to with predicate call_python_function\n    :param func: It shall be the function to be called. \n    \n    ";
static PyMethodDef __pyx_mdef_5pyclp_5pyclp_15addPythonFunction = {"addPythonFunction", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyclp_5pyclp_15addPythonFunction, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyclp_5pyclp_14addPythonFunction};
static PyObject *__pyx_pw_5pyclp_5pyclp_15addPythonFunction(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_eclipse_name = 0;
  PyObject *__pyx_v_func = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("addPythonFunction (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_eclipse_name,&__pyx_n_s_func,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_eclipse_name)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_func)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("addPythonFunction", 1, 2, 2, 1); __PYX_ERR(0, 1093, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "addPythonFunction") < 0)) __PYX_ERR(0, 1093, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_eclipse_name = values[0];
    __pyx_v_func = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("addPythonFunction", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1093, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyclp.pyclp.addPythonFunction", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pyclp_5pyclp_14addPythonFunction(__pyx_self, __pyx_v_eclipse_name, __pyx_v_func);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pyclp_5pyclp_14addPythonFunction(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_eclipse_name, PyObject *__pyx_v_func) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("addPythonFunction", 0);

  /* "pyclp/pyclp.pyx":1110
 * 
 *     """
 *     if not isinstance(func,types.FunctionType):             # <<<<<<<<<<<<<<
 *         raise TypeError("func shall be a function")
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_types); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1110, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_FunctionType); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1110, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = PyObject_IsInstance(__pyx_v_func, __pyx_t_2); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 1110, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = ((!(__pyx_t_3 != 0)) != 0);
  if (unlikely(__pyx_t_4)) {

    /* "pyclp/pyclp.pyx":1111
 *     """
 *     if not isinstance(func,types.FunctionType):
 *         raise TypeError("func shall be a function")             # <<<<<<<<<<<<<<
 * 
 *     if isinstance(eclipse_name,unicode) or isinstance(eclipse_name,str):
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__33, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1111, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 1111, __pyx_L1_error)

    /* "pyclp/pyclp.pyx":1110
 * 
 *     """
 *     if not isinstance(func,types.FunctionType):             # <<<<<<<<<<<<<<
 *         raise TypeError("func shall be a function")
 * 
 */
  }

  /* "pyclp/pyclp.pyx":1113
 *         raise TypeError("func shall be a function")
 * 
 *     if isinstance(eclipse_name,unicode) or isinstance(eclipse_name,str):             # <<<<<<<<<<<<<<
 *         python_pred2func[eclipse_name]=func
 *     else:
 */
  __pyx_t_3 = PyUnicode_Check(__pyx_v_eclipse_name); 
  __pyx_t_5 = (__pyx_t_3 != 0);
  if (!__pyx_t_5) {
  } else {
    __pyx_t_4 = __pyx_t_5;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_t_5 = PyString_Check(__pyx_v_eclipse_name); 
  __pyx_t_3 = (__pyx_t_5 != 0);
  __pyx_t_4 = __pyx_t_3;
  __pyx_L5_bool_binop_done:;
  if (likely(__pyx_t_4)) {

    /* "pyclp/pyclp.pyx":1114
 * 
 *     if isinstance(eclipse_name,unicode) or isinstance(eclipse_name,str):
 *         python_pred2func[eclipse_name]=func             # <<<<<<<<<<<<<<
 *     else:
 *         raise ValueError("eclipse_name shall be a text, got %s" % type(string))
 */
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_python_pred2func); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1114, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (unlikely(PyObject_SetItem(__pyx_t_2, __pyx_v_eclipse_name, __pyx_v_func) < 0)) __PYX_ERR(0, 1114, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "pyclp/pyclp.pyx":1113
 *         raise TypeError("func shall be a function")
 * 
 *     if isinstance(eclipse_name,unicode) or isinstance(eclipse_name,str):             # <<<<<<<<<<<<<<
 *         python_pred2func[eclipse_name]=func
 *     else:
 */
    goto __pyx_L4;
  }

  /* "pyclp/pyclp.pyx":1116
 *         python_pred2func[eclipse_name]=func
 *     else:
 *         raise ValueError("eclipse_name shall be a text, got %s" % type(string))             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_string); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1116, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = __Pyx_PyString_FormatSafe(__pyx_kp_s_eclipse_name_shall_be_a_text_got, ((PyObject *)Py_TYPE(__pyx_t_2))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1116, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1116, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 1116, __pyx_L1_error)
  }
  __pyx_L4:;

  /* "pyclp/pyclp.pyx":1093
 *         return FAIL
 * 
 * def addPythonFunction(eclipse_name,func):             # <<<<<<<<<<<<<<
 *     """
 *     Register a python function to be called from Eclipse using the predicate call_python.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pyclp.pyclp.addPythonFunction", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static struct __pyx_vtabstruct_5pyclp_5pyclp_Ref __pyx_vtable_5pyclp_5pyclp_Ref;

static PyObject *__pyx_tp_new_5pyclp_5pyclp_Ref(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_5pyclp_5pyclp_Ref *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pyclp_5pyclp_Ref *)o);
  p->__pyx_vtab = __pyx_vtabptr_5pyclp_5pyclp_Ref;
  if (unlikely(__pyx_pw_5pyclp_5pyclp_3Ref_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_5pyclp_5pyclp_Ref(PyObject *o) {
  struct __pyx_obj_5pyclp_5pyclp_Ref *p = (struct __pyx_obj_5pyclp_5pyclp_Ref *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    __Pyx_SET_REFCNT(o, Py_REFCNT(o) + 1);
    __pyx_pw_5pyclp_5pyclp_3Ref_7__dealloc__(o);
    __Pyx_SET_REFCNT(o, Py_REFCNT(o) - 1);
    PyErr_Restore(etype, eval, etb);
  }
  if (p->__weakref__) PyObject_ClearWeakRefs(o);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_5pyclp_5pyclp_Ref[] = {
  {"cinit", (PyCFunction)__pyx_pw_5pyclp_5pyclp_3Ref_3cinit, METH_NOARGS, 0},
  {"dealloc", (PyCFunction)__pyx_pw_5pyclp_5pyclp_3Ref_9dealloc, METH_NOARGS, 0},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_5pyclp_5pyclp_3Ref_11__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_5pyclp_5pyclp_3Ref_13__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pyclp_5pyclp_Ref = {
  PyVarObject_HEAD_INIT(0, 0)
  "pyclp.pyclp.Ref", /*tp_name*/
  sizeof(struct __pyx_obj_5pyclp_5pyclp_Ref), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pyclp_5pyclp_Ref, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  0, /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_5pyclp_5pyclp_Ref, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_5pyclp_5pyclp_3Ref_5__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pyclp_5pyclp_Ref, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};
static struct __pyx_vtabstruct_5pyclp_5pyclp_Term __pyx_vtable_5pyclp_5pyclp_Term;

static PyObject *__pyx_tp_new_5pyclp_5pyclp_Term(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_5pyclp_5pyclp_Term *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pyclp_5pyclp_Term *)o);
  p->__pyx_vtab = __pyx_vtabptr_5pyclp_5pyclp_Term;
  p->ref = ((struct __pyx_obj_5pyclp_5pyclp_Ref *)Py_None); Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_5pyclp_5pyclp_Term(PyObject *o) {
  struct __pyx_obj_5pyclp_5pyclp_Term *p = (struct __pyx_obj_5pyclp_5pyclp_Term *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->ref);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_5pyclp_5pyclp_Term(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_5pyclp_5pyclp_Term *p = (struct __pyx_obj_5pyclp_5pyclp_Term *)o;
  if (p->ref) {
    e = (*v)(((PyObject *)p->ref), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_5pyclp_5pyclp_Term(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_5pyclp_5pyclp_Term *p = (struct __pyx_obj_5pyclp_5pyclp_Term *)o;
  tmp = ((PyObject*)p->ref);
  p->ref = ((struct __pyx_obj_5pyclp_5pyclp_Ref *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_5pyclp_5pyclp_Term[] = {
  {"post_goal", (PyCFunction)__pyx_pw_5pyclp_5pyclp_4Term_7post_goal, METH_NOARGS, __pyx_doc_5pyclp_5pyclp_4Term_6post_goal},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_5pyclp_5pyclp_4Term_9__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_5pyclp_5pyclp_4Term_11__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pyclp_5pyclp_Term = {
  PyVarObject_HEAD_INIT(0, 0)
  "pyclp.pyclp.Term", /*tp_name*/
  sizeof(struct __pyx_obj_5pyclp_5pyclp_Term), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pyclp_5pyclp_Term, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  __pyx_pw_5pyclp_5pyclp_4Term_3__cmp__, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "Class for prolog Term.\n    Compound, Atom,PList and Var are derived from this class.\n    User doesn't need to use directly it.\n    ", /*tp_doc*/
  __pyx_tp_traverse_5pyclp_5pyclp_Term, /*tp_traverse*/
  __pyx_tp_clear_5pyclp_5pyclp_Term, /*tp_clear*/
  __pyx_pw_5pyclp_5pyclp_4Term_5__richcmp__, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_5pyclp_5pyclp_Term, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_5pyclp_5pyclp_4Term_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pyclp_5pyclp_Term, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};
static struct __pyx_vtabstruct_5pyclp_5pyclp_Atom __pyx_vtable_5pyclp_5pyclp_Atom;

static PyObject *__pyx_tp_new_5pyclp_5pyclp_Atom(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_5pyclp_5pyclp_Atom *p;
  PyObject *o = __pyx_tp_new_5pyclp_5pyclp_Term(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pyclp_5pyclp_Atom *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_5pyclp_5pyclp_Term*)__pyx_vtabptr_5pyclp_5pyclp_Atom;
  return o;
}

static PyMethodDef __pyx_methods_5pyclp_5pyclp_Atom[] = {
  {"__reduce_cython__", (PyCFunction)__pyx_pw_5pyclp_5pyclp_4Atom_5__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_5pyclp_5pyclp_4Atom_7__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pyclp_5pyclp_Atom = {
  PyVarObject_HEAD_INIT(0, 0)
  "pyclp.pyclp.Atom", /*tp_name*/
  sizeof(struct __pyx_obj_5pyclp_5pyclp_Atom), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pyclp_5pyclp_Term, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_5pyclp_5pyclp_4Term_3__cmp__, /*tp_compare*/
  #else
  0, /*tp_compare*/
  #endif
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  __pyx_pw_5pyclp_5pyclp_4Atom_3__str__, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    Class to create Atom.\n    \n    :param atom_id: atom name\n    :type atom_id: string\n    \n    ", /*tp_doc*/
  __pyx_tp_traverse_5pyclp_5pyclp_Term, /*tp_traverse*/
  __pyx_tp_clear_5pyclp_5pyclp_Term, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_5pyclp_5pyclp_Atom, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_5pyclp_5pyclp_4Atom_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pyclp_5pyclp_Atom, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};
static struct __pyx_vtabstruct_5pyclp_5pyclp_PList __pyx_vtable_5pyclp_5pyclp_PList;

static PyObject *__pyx_tp_new_5pyclp_5pyclp_PList(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_5pyclp_5pyclp_PList *p;
  PyObject *o = __pyx_tp_new_5pyclp_5pyclp_Term(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pyclp_5pyclp_PList *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_5pyclp_5pyclp_Term*)__pyx_vtabptr_5pyclp_5pyclp_PList;
  return o;
}
static PyObject *__pyx_sq_item_5pyclp_5pyclp_PList(PyObject *o, Py_ssize_t i) {
  PyObject *r;
  PyObject *x = PyInt_FromSsize_t(i); if(!x) return 0;
  r = Py_TYPE(o)->tp_as_mapping->mp_subscript(o, x);
  Py_DECREF(x);
  return r;
}

static PyMethodDef __pyx_methods_5pyclp_5pyclp_PList[] = {
  {"head_generator", (PyCFunction)__pyx_pw_5pyclp_5pyclp_5PList_3head_generator, METH_NOARGS, 0},
  {"head_tail_generator", (PyCFunction)__pyx_pw_5pyclp_5pyclp_5PList_6head_tail_generator, METH_NOARGS, 0},
  {"iterheadtail", (PyCFunction)__pyx_pw_5pyclp_5pyclp_5PList_13iterheadtail, METH_NOARGS, __pyx_doc_5pyclp_5pyclp_5PList_12iterheadtail},
  {"iterHeadTail", (PyCFunction)__pyx_pw_5pyclp_5pyclp_5PList_15iterHeadTail, METH_NOARGS, __pyx_doc_5pyclp_5pyclp_5PList_14iterHeadTail},
  {"getListTail", (PyCFunction)__pyx_pw_5pyclp_5pyclp_5PList_19getListTail, METH_NOARGS, __pyx_doc_5pyclp_5pyclp_5PList_18getListTail},
  {"isNil", (PyCFunction)__pyx_pw_5pyclp_5pyclp_5PList_21isNil, METH_NOARGS, __pyx_doc_5pyclp_5pyclp_5PList_20isNil},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_5pyclp_5pyclp_5PList_25__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_5pyclp_5pyclp_5PList_27__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PySequenceMethods __pyx_tp_as_sequence_PList = {
  __pyx_pw_5pyclp_5pyclp_5PList_11__len__, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  __pyx_sq_item_5pyclp_5pyclp_PList, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_PList = {
  __pyx_pw_5pyclp_5pyclp_5PList_11__len__, /*mp_length*/
  __pyx_pw_5pyclp_5pyclp_5PList_17__getitem__, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyTypeObject __pyx_type_5pyclp_5pyclp_PList = {
  PyVarObject_HEAD_INIT(0, 0)
  "pyclp.pyclp.PList", /*tp_name*/
  sizeof(struct __pyx_obj_5pyclp_5pyclp_PList), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pyclp_5pyclp_Term, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_5pyclp_5pyclp_4Term_3__cmp__, /*tp_compare*/
  #else
  0, /*tp_compare*/
  #endif
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  &__pyx_tp_as_sequence_PList, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_PList, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  __pyx_pw_5pyclp_5pyclp_5PList_23__str__, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    Class to create and read Prolog lists.\n    \n    When creating a new instance a list or tuple shall be provided.\n    string,float and integer are automatically transformed in term as in\n    Compound class.\n    This class support iterator protocol this means that you can loop on the list as for python list\n    \n    **Example**::\n        \n        init()\n        my_list=PList([1,2,3])\n        for x in my_list:\n            print(x)\n            \n    This class support retrieving values by indexing.\n    \n    **Example**::\n        \n        init()\n        my_list=PList([1,2,3])\n        print(my_list[3])\n    \n    .. warning::\n        As for all other terms it is not possible to change their values.\n        \n    **Special cases**\n    \n    Empty prolog list can be created with PList([])\n    To check that a returned PList is the empty list it avaiable the method :py:func:`pyclp.PList.isNil`\n    \n    **Head Tail**\n    \n    In prolog it is possible to define a list using the operator |\n    \n    **Example of prolog list and head tail decomposition**::\n        \n        %Prolog list example\n        [1,2,3|myAtom]\n        [1|A]\n        %Also regular list have a tail: []\n        [1,2,3]=[1,2,3|[]]\n        %All list can be decomposed recursively as head tail couple\n        [1,2,3]\n        [1|[2,3]]\n        [1|[2|[3]]]\n        [1|[2|[3|[]]]]\n        \n    \n\n        \n    ", /*tp_doc*/
  __pyx_tp_traverse_5pyclp_5pyclp_Term, /*tp_traverse*/
  __pyx_tp_clear_5pyclp_5pyclp_Term, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_5pyclp_5pyclp_5PList_9__iter__, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_5pyclp_5pyclp_PList, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_5pyclp_5pyclp_5PList_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pyclp_5pyclp_PList, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};
static struct __pyx_vtabstruct_5pyclp_5pyclp_Compound __pyx_vtable_5pyclp_5pyclp_Compound;

static PyObject *__pyx_tp_new_5pyclp_5pyclp_Compound(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_5pyclp_5pyclp_Compound *p;
  PyObject *o = __pyx_tp_new_5pyclp_5pyclp_Term(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pyclp_5pyclp_Compound *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_5pyclp_5pyclp_Term*)__pyx_vtabptr_5pyclp_5pyclp_Compound;
  return o;
}
static PyObject *__pyx_sq_item_5pyclp_5pyclp_Compound(PyObject *o, Py_ssize_t i) {
  PyObject *r;
  PyObject *x = PyInt_FromSsize_t(i); if(!x) return 0;
  r = Py_TYPE(o)->tp_as_mapping->mp_subscript(o, x);
  Py_DECREF(x);
  return r;
}

static PyMethodDef __pyx_methods_5pyclp_5pyclp_Compound[] = {
  {"arity", (PyCFunction)__pyx_pw_5pyclp_5pyclp_8Compound_3arity, METH_NOARGS, __pyx_doc_5pyclp_5pyclp_8Compound_2arity},
  {"functor", (PyCFunction)__pyx_pw_5pyclp_5pyclp_8Compound_5functor, METH_NOARGS, __pyx_doc_5pyclp_5pyclp_8Compound_4functor},
  {"arguments", (PyCFunction)__pyx_pw_5pyclp_5pyclp_8Compound_7arguments, METH_NOARGS, __pyx_doc_5pyclp_5pyclp_8Compound_6arguments},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_5pyclp_5pyclp_8Compound_18__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_5pyclp_5pyclp_8Compound_20__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PySequenceMethods __pyx_tp_as_sequence_Compound = {
  __pyx_pw_5pyclp_5pyclp_8Compound_12__len__, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  __pyx_sq_item_5pyclp_5pyclp_Compound, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_Compound = {
  __pyx_pw_5pyclp_5pyclp_8Compound_12__len__, /*mp_length*/
  __pyx_pw_5pyclp_5pyclp_8Compound_14__getitem__, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyTypeObject __pyx_type_5pyclp_5pyclp_Compound = {
  PyVarObject_HEAD_INIT(0, 0)
  "pyclp.pyclp.Compound", /*tp_name*/
  sizeof(struct __pyx_obj_5pyclp_5pyclp_Compound), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pyclp_5pyclp_Term, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_5pyclp_5pyclp_4Term_3__cmp__, /*tp_compare*/
  #else
  0, /*tp_compare*/
  #endif
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  &__pyx_tp_as_sequence_Compound, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_Compound, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  __pyx_pw_5pyclp_5pyclp_8Compound_16__str__, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    Class to create compound terms.\n    \n    :param functor_string: A string with functor name.\n    :param args: Any number of arguments of type integer, float,string and :py:class:`PList`, :py:class:`Atom`, :py:class:`Compound`\n    \n    len(arg) function called with a Compound object return the arity of compound term.\n    \n    This class support iterator protocol this means that you can iterate over term arguments \n    or get the arguments by index protocol:\n    \n    Example::\n        \n        init()\n        my_compound=Compound(\"test\",1,\"dummy\")\n        for x in my_compound:\n            print(x)\n        print(my_compound[0])  # Print first argument.\n    \n    .. warning::\n        As for all other terms it is not possible to change their values.\n    \n    ", /*tp_doc*/
  __pyx_tp_traverse_5pyclp_5pyclp_Term, /*tp_traverse*/
  __pyx_tp_clear_5pyclp_5pyclp_Term, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_5pyclp_5pyclp_8Compound_10__iter__, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_5pyclp_5pyclp_Compound, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_5pyclp_5pyclp_8Compound_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pyclp_5pyclp_Compound, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};
static struct __pyx_vtabstruct_5pyclp_5pyclp_Var __pyx_vtable_5pyclp_5pyclp_Var;

static PyObject *__pyx_tp_new_5pyclp_5pyclp_Var(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_5pyclp_5pyclp_Var *p;
  PyObject *o = __pyx_tp_new_5pyclp_5pyclp_Term(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pyclp_5pyclp_Var *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_5pyclp_5pyclp_Term*)__pyx_vtabptr_5pyclp_5pyclp_Var;
  return o;
}

static PyMethodDef __pyx_methods_5pyclp_5pyclp_Var[] = {
  {"value", (PyCFunction)__pyx_pw_5pyclp_5pyclp_3Var_3value, METH_NOARGS, __pyx_doc_5pyclp_5pyclp_3Var_2value},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_5pyclp_5pyclp_3Var_7__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_5pyclp_5pyclp_3Var_9__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pyclp_5pyclp_Var = {
  PyVarObject_HEAD_INIT(0, 0)
  "pyclp.pyclp.Var", /*tp_name*/
  sizeof(struct __pyx_obj_5pyclp_5pyclp_Var), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pyclp_5pyclp_Term, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_5pyclp_5pyclp_4Term_3__cmp__, /*tp_compare*/
  #else
  0, /*tp_compare*/
  #endif
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  __pyx_pw_5pyclp_5pyclp_3Var_5__str__, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    Class to create Prolog variable.\n    ", /*tp_doc*/
  __pyx_tp_traverse_5pyclp_5pyclp_Term, /*tp_traverse*/
  __pyx_tp_clear_5pyclp_5pyclp_Term, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_5pyclp_5pyclp_Var, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_5pyclp_5pyclp_3Var_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pyclp_5pyclp_Var, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator *__pyx_freelist_5pyclp_5pyclp___pyx_scope_struct__head_generator[8];
static int __pyx_freecount_5pyclp_5pyclp___pyx_scope_struct__head_generator = 0;

static PyObject *__pyx_tp_new_5pyclp_5pyclp___pyx_scope_struct__head_generator(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_5pyclp_5pyclp___pyx_scope_struct__head_generator > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator)))) {
    o = (PyObject*)__pyx_freelist_5pyclp_5pyclp___pyx_scope_struct__head_generator[--__pyx_freecount_5pyclp_5pyclp___pyx_scope_struct__head_generator];
    memset(o, 0, sizeof(struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_5pyclp_5pyclp___pyx_scope_struct__head_generator(PyObject *o) {
  struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator *p = (struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_self);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_5pyclp_5pyclp___pyx_scope_struct__head_generator < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator)))) {
    __pyx_freelist_5pyclp_5pyclp___pyx_scope_struct__head_generator[__pyx_freecount_5pyclp_5pyclp___pyx_scope_struct__head_generator++] = ((struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_5pyclp_5pyclp___pyx_scope_struct__head_generator(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator *p = (struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator *)o;
  if (p->__pyx_v_self) {
    e = (*v)(((PyObject *)p->__pyx_v_self), a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_5pyclp_5pyclp___pyx_scope_struct__head_generator = {
  PyVarObject_HEAD_INIT(0, 0)
  "pyclp.pyclp.__pyx_scope_struct__head_generator", /*tp_name*/
  sizeof(struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct__head_generator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pyclp_5pyclp___pyx_scope_struct__head_generator, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_5pyclp_5pyclp___pyx_scope_struct__head_generator, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pyclp_5pyclp___pyx_scope_struct__head_generator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator *__pyx_freelist_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator[8];
static int __pyx_freecount_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator = 0;

static PyObject *__pyx_tp_new_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator)))) {
    o = (PyObject*)__pyx_freelist_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator[--__pyx_freecount_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator];
    memset(o, 0, sizeof(struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator(PyObject *o) {
  struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator *p = (struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_self);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator)))) {
    __pyx_freelist_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator[__pyx_freecount_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator++] = ((struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator *p = (struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator *)o;
  if (p->__pyx_v_self) {
    e = (*v)(((PyObject *)p->__pyx_v_self), a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator = {
  PyVarObject_HEAD_INIT(0, 0)
  "pyclp.pyclp.__pyx_scope_struct_1_head_tail_generator", /*tp_name*/
  sizeof(struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments *__pyx_freelist_5pyclp_5pyclp___pyx_scope_struct_2_arguments[8];
static int __pyx_freecount_5pyclp_5pyclp___pyx_scope_struct_2_arguments = 0;

static PyObject *__pyx_tp_new_5pyclp_5pyclp___pyx_scope_struct_2_arguments(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_5pyclp_5pyclp___pyx_scope_struct_2_arguments > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments)))) {
    o = (PyObject*)__pyx_freelist_5pyclp_5pyclp___pyx_scope_struct_2_arguments[--__pyx_freecount_5pyclp_5pyclp___pyx_scope_struct_2_arguments];
    memset(o, 0, sizeof(struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_5pyclp_5pyclp___pyx_scope_struct_2_arguments(PyObject *o) {
  struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments *p = (struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_self);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_5pyclp_5pyclp___pyx_scope_struct_2_arguments < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments)))) {
    __pyx_freelist_5pyclp_5pyclp___pyx_scope_struct_2_arguments[__pyx_freecount_5pyclp_5pyclp___pyx_scope_struct_2_arguments++] = ((struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_5pyclp_5pyclp___pyx_scope_struct_2_arguments(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments *p = (struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments *)o;
  if (p->__pyx_v_self) {
    e = (*v)(((PyObject *)p->__pyx_v_self), a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_5pyclp_5pyclp___pyx_scope_struct_2_arguments = {
  PyVarObject_HEAD_INIT(0, 0)
  "pyclp.pyclp.__pyx_scope_struct_2_arguments", /*tp_name*/
  sizeof(struct __pyx_obj_5pyclp_5pyclp___pyx_scope_struct_2_arguments), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pyclp_5pyclp___pyx_scope_struct_2_arguments, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_5pyclp_5pyclp___pyx_scope_struct_2_arguments, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pyclp_5pyclp___pyx_scope_struct_2_arguments, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {"formatTermStr", (PyCFunction)__pyx_pw_5pyclp_5pyclp_1formatTermStr, METH_O, __pyx_doc_5pyclp_5pyclp_formatTermStr},
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
#if CYTHON_PEP489_MULTI_PHASE_INIT
static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
static int __pyx_pymod_exec_pyclp(PyObject* module); /*proto*/
static PyModuleDef_Slot __pyx_moduledef_slots[] = {
  {Py_mod_create, (void*)__pyx_pymod_create},
  {Py_mod_exec, (void*)__pyx_pymod_exec_pyclp},
  {0, NULL}
};
#endif

static struct PyModuleDef __pyx_moduledef = {
    PyModuleDef_HEAD_INIT,
    "pyclp",
    __pyx_k_Pyclp_is_a_Python_library_to_in, /* m_doc */
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    0, /* m_size */
  #else
    -1, /* m_size */
  #endif
    __pyx_methods /* m_methods */,
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    __pyx_moduledef_slots, /* m_slots */
  #else
    NULL, /* m_reload */
  #endif
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif
#ifndef CYTHON_SMALL_CODE
#if defined(__clang__)
    #define CYTHON_SMALL_CODE
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
    #define CYTHON_SMALL_CODE __attribute__((cold))
#else
    #define CYTHON_SMALL_CODE
#endif
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_, __pyx_k_, sizeof(__pyx_k_), 0, 0, 1, 0},
  {&__pyx_kp_s_0, __pyx_k_0, sizeof(__pyx_k_0), 0, 0, 1, 0},
  {&__pyx_kp_s_0_1, __pyx_k_0_1, sizeof(__pyx_k_0_1), 0, 0, 1, 0},
  {&__pyx_kp_s_0_s_1, __pyx_k_0_s_1, sizeof(__pyx_k_0_s_1), 0, 0, 1, 0},
  {&__pyx_kp_s_Argument_index_out_of_range, __pyx_k_Argument_index_out_of_range, sizeof(__pyx_k_Argument_index_out_of_range), 0, 0, 1, 0},
  {&__pyx_kp_s_Argument_index_out_of_range_0_ar, __pyx_k_Argument_index_out_of_range_0_ar, sizeof(__pyx_k_Argument_index_out_of_range_0_ar), 0, 0, 1, 0},
  {&__pyx_kp_s_Arity_of_compound_item_shall_be, __pyx_k_Arity_of_compound_item_shall_be, sizeof(__pyx_k_Arity_of_compound_item_shall_be), 0, 0, 1, 0},
  {&__pyx_n_s_Atom, __pyx_k_Atom, sizeof(__pyx_k_Atom), 0, 0, 1, 1},
  {&__pyx_kp_s_Atom_constructor_accept_only_str, __pyx_k_Atom_constructor_accept_only_str, sizeof(__pyx_k_Atom_constructor_accept_only_str), 0, 0, 1, 0},
  {&__pyx_kp_s_Class_to_support_streams_to_and, __pyx_k_Class_to_support_streams_to_and, sizeof(__pyx_k_Class_to_support_streams_to_and), 0, 0, 1, 0},
  {&__pyx_kp_s_Comparison_between_incompatible, __pyx_k_Comparison_between_incompatible, sizeof(__pyx_k_Comparison_between_incompatible), 0, 0, 1, 0},
  {&__pyx_n_s_Compound, __pyx_k_Compound, sizeof(__pyx_k_Compound), 0, 0, 1, 1},
  {&__pyx_n_s_Compound_arguments, __pyx_k_Compound_arguments, sizeof(__pyx_k_Compound_arguments), 0, 0, 1, 1},
  {&__pyx_kp_s_Cut_it_is_possible_only_after_a, __pyx_k_Cut_it_is_possible_only_after_a, sizeof(__pyx_k_Cut_it_is_possible_only_after_a), 0, 0, 1, 0},
  {&__pyx_n_s_FAIL, __pyx_k_FAIL, sizeof(__pyx_k_FAIL), 0, 0, 1, 1},
  {&__pyx_n_s_FLUSHIO, __pyx_k_FLUSHIO, sizeof(__pyx_k_FLUSHIO), 0, 0, 1, 1},
  {&__pyx_kp_s_Failed_cleanup_operation, __pyx_k_Failed_cleanup_operation, sizeof(__pyx_k_Failed_cleanup_operation), 0, 0, 1, 0},
  {&__pyx_kp_s_Failed_initialization, __pyx_k_Failed_initialization, sizeof(__pyx_k_Failed_initialization), 0, 0, 1, 0},
  {&__pyx_kp_s_Failed_retrieving_of_Atom_dictio, __pyx_k_Failed_retrieving_of_Atom_dictio, sizeof(__pyx_k_Failed_retrieving_of_Atom_dictio), 0, 0, 1, 0},
  {&__pyx_kp_s_Failed_retrieving_of_Functor_dic, __pyx_k_Failed_retrieving_of_Functor_dic, sizeof(__pyx_k_Failed_retrieving_of_Functor_dic), 0, 0, 1, 0},
  {&__pyx_n_s_FunctionType, __pyx_k_FunctionType, sizeof(__pyx_k_FunctionType), 0, 0, 1, 1},
  {&__pyx_kp_s_Functor_arity_bigger_than_availa, __pyx_k_Functor_arity_bigger_than_availa, sizeof(__pyx_k_Functor_arity_bigger_than_availa), 0, 0, 1, 0},
  {&__pyx_n_s_IOError, __pyx_k_IOError, sizeof(__pyx_k_IOError), 0, 0, 1, 1},
  {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
  {&__pyx_kp_s_Index_shall_be_a_integer, __pyx_k_Index_shall_be_a_integer, sizeof(__pyx_k_Index_shall_be_a_integer), 0, 0, 1, 0},
  {&__pyx_kp_s_Invalid_option_in_set_option, __pyx_k_Invalid_option_in_set_option, sizeof(__pyx_k_Invalid_option_in_set_option), 0, 0, 1, 0},
  {&__pyx_n_s_NotImplemented, __pyx_k_NotImplemented, sizeof(__pyx_k_NotImplemented), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_ALLOCATION, __pyx_k_OPTION_ALLOCATION, sizeof(__pyx_k_OPTION_ALLOCATION), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_ARGC, __pyx_k_OPTION_ARGC, sizeof(__pyx_k_OPTION_ARGC), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_ARGV, __pyx_k_OPTION_ARGV, sizeof(__pyx_k_OPTION_ARGV), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_DEBUG_LEVEL, __pyx_k_OPTION_DEBUG_LEVEL, sizeof(__pyx_k_OPTION_DEBUG_LEVEL), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_DEFAULT_MODULE, __pyx_k_OPTION_DEFAULT_MODULE, sizeof(__pyx_k_OPTION_DEFAULT_MODULE), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_ECLIPSEDIR, __pyx_k_OPTION_ECLIPSEDIR, sizeof(__pyx_k_OPTION_ECLIPSEDIR), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_GLOBALSIZE, __pyx_k_OPTION_GLOBALSIZE, sizeof(__pyx_k_OPTION_GLOBALSIZE), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_INIT, __pyx_k_OPTION_INIT, sizeof(__pyx_k_OPTION_INIT), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_IO, __pyx_k_OPTION_IO, sizeof(__pyx_k_OPTION_IO), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_LOCALSIZE, __pyx_k_OPTION_LOCALSIZE, sizeof(__pyx_k_OPTION_LOCALSIZE), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_MAPFILE, __pyx_k_OPTION_MAPFILE, sizeof(__pyx_k_OPTION_MAPFILE), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_PANIC, __pyx_k_OPTION_PANIC, sizeof(__pyx_k_OPTION_PANIC), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_PARALLEL_WORKER, __pyx_k_OPTION_PARALLEL_WORKER, sizeof(__pyx_k_OPTION_PARALLEL_WORKER), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_PRIVATESIZE, __pyx_k_OPTION_PRIVATESIZE, sizeof(__pyx_k_OPTION_PRIVATESIZE), 0, 0, 1, 1},
  {&__pyx_n_s_OPTION_SHAREDSIZE, __pyx_k_OPTION_SHAREDSIZE, sizeof(__pyx_k_OPTION_SHAREDSIZE), 0, 0, 1, 1},
  {&__pyx_n_s_PList, __pyx_k_PList, sizeof(__pyx_k_PList), 0, 0, 1, 1},
  {&__pyx_kp_s_PList_constructor_accept_only_li, __pyx_k_PList_constructor_accept_only_li, sizeof(__pyx_k_PList_constructor_accept_only_li), 0, 0, 1, 0},
  {&__pyx_n_s_PList_head_generator, __pyx_k_PList_head_generator, sizeof(__pyx_k_PList_head_generator), 0, 0, 1, 1},
  {&__pyx_n_s_PList_head_tail_generator, __pyx_k_PList_head_tail_generator, sizeof(__pyx_k_PList_head_tail_generator), 0, 0, 1, 1},
  {&__pyx_kp_s_PList_tail_shall_be_a_list_or_a, __pyx_k_PList_tail_shall_be_a_list_or_a, sizeof(__pyx_k_PList_tail_shall_be_a_list_or_a), 0, 0, 1, 0},
  {&__pyx_kp_s_PList_tail_shall_be_a_list_tuple, __pyx_k_PList_tail_shall_be_a_list_tuple, sizeof(__pyx_k_PList_tail_shall_be_a_list_tuple), 0, 0, 1, 0},
  {&__pyx_kp_s_Pickling_of_struct_members_such, __pyx_k_Pickling_of_struct_members_such, sizeof(__pyx_k_Pickling_of_struct_members_such), 0, 0, 1, 0},
  {&__pyx_kp_s_Range_error_while_getting_args_p, __pyx_k_Range_error_while_getting_args_p, sizeof(__pyx_k_Range_error_while_getting_args_p), 0, 0, 1, 0},
  {&__pyx_n_s_RawIOBase, __pyx_k_RawIOBase, sizeof(__pyx_k_RawIOBase), 0, 0, 1, 1},
  {&__pyx_n_s_Ref, __pyx_k_Ref, sizeof(__pyx_k_Ref), 0, 0, 1, 1},
  {&__pyx_n_s_SUCCEED, __pyx_k_SUCCEED, sizeof(__pyx_k_SUCCEED), 0, 0, 1, 1},
  {&__pyx_n_s_Stream, __pyx_k_Stream, sizeof(__pyx_k_Stream), 0, 0, 1, 1},
  {&__pyx_n_s_Stream___init, __pyx_k_Stream___init, sizeof(__pyx_k_Stream___init), 0, 0, 1, 1},
  {&__pyx_n_s_Stream_fileno, __pyx_k_Stream_fileno, sizeof(__pyx_k_Stream_fileno), 0, 0, 1, 1},
  {&__pyx_n_s_Stream_flush, __pyx_k_Stream_flush, sizeof(__pyx_k_Stream_flush), 0, 0, 1, 1},
  {&__pyx_n_s_Stream_isatty, __pyx_k_Stream_isatty, sizeof(__pyx_k_Stream_isatty), 0, 0, 1, 1},
  {&__pyx_n_s_Stream_read, __pyx_k_Stream_read, sizeof(__pyx_k_Stream_read), 0, 0, 1, 1},
  {&__pyx_n_s_Stream_readable, __pyx_k_Stream_readable, sizeof(__pyx_k_Stream_readable), 0, 0, 1, 1},
  {&__pyx_n_s_Stream_readall, __pyx_k_Stream_readall, sizeof(__pyx_k_Stream_readall), 0, 0, 1, 1},
  {&__pyx_n_s_Stream_readinto, __pyx_k_Stream_readinto, sizeof(__pyx_k_Stream_readinto), 0, 0, 1, 1},
  {&__pyx_n_s_Stream_seekable, __pyx_k_Stream_seekable, sizeof(__pyx_k_Stream_seekable), 0, 0, 1, 1},
  {&__pyx_n_s_Stream_truncate, __pyx_k_Stream_truncate, sizeof(__pyx_k_Stream_truncate), 0, 0, 1, 1},
  {&__pyx_n_s_Stream_write, __pyx_k_Stream_write, sizeof(__pyx_k_Stream_write), 0, 0, 1, 1},
  {&__pyx_n_s_Stream_writeable, __pyx_k_Stream_writeable, sizeof(__pyx_k_Stream_writeable), 0, 0, 1, 1},
  {&__pyx_n_s_THROW, __pyx_k_THROW, sizeof(__pyx_k_THROW), 0, 0, 1, 1},
  {&__pyx_n_s_Term, __pyx_k_Term, sizeof(__pyx_k_Term), 0, 0, 1, 1},
  {&__pyx_kp_s_This_comparison_operation_is_not, __pyx_k_This_comparison_operation_is_not, sizeof(__pyx_k_This_comparison_operation_is_not), 0, 0, 1, 0},
  {&__pyx_kp_s_Tried_to_cleanup_an_already_shut, __pyx_k_Tried_to_cleanup_an_already_shut, sizeof(__pyx_k_Tried_to_cleanup_an_already_shut), 0, 0, 1, 0},
  {&__pyx_kp_s_Tried_to_initialize_an_already_i, __pyx_k_Tried_to_initialize_an_already_i, sizeof(__pyx_k_Tried_to_initialize_an_already_i), 0, 0, 1, 0},
  {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
  {&__pyx_kp_s_Unknow_error_during_args_getting, __pyx_k_Unknow_error_during_args_getting, sizeof(__pyx_k_Unknow_error_during_args_getting), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_type_returned_by_eclipse, __pyx_k_Unknown_type_returned_by_eclipse, sizeof(__pyx_k_Unknown_type_returned_by_eclipse), 0, 0, 1, 0},
  {&__pyx_kp_s_Unrecognized_result_from_ec_resu, __pyx_k_Unrecognized_result_from_ec_resu, sizeof(__pyx_k_Unrecognized_result_from_ec_resu), 0, 0, 1, 0},
  {&__pyx_kp_s_Unsupported_option, __pyx_k_Unsupported_option, sizeof(__pyx_k_Unsupported_option), 0, 0, 1, 0},
  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
  {&__pyx_n_s_Var, __pyx_k_Var, sizeof(__pyx_k_Var), 0, 0, 1, 1},
  {&__pyx_n_s_WAITIO, __pyx_k_WAITIO, sizeof(__pyx_k_WAITIO), 0, 0, 1, 1},
  {&__pyx_n_s_WeakSet, __pyx_k_WeakSet, sizeof(__pyx_k_WeakSet), 0, 0, 1, 1},
  {&__pyx_n_s_YIELD, __pyx_k_YIELD, sizeof(__pyx_k_YIELD), 0, 0, 1, 1},
  {&__pyx_kp_s__2, __pyx_k__2, sizeof(__pyx_k__2), 0, 0, 1, 0},
  {&__pyx_kp_s__24, __pyx_k__24, sizeof(__pyx_k__24), 0, 0, 1, 0},
  {&__pyx_n_s__30, __pyx_k__30, sizeof(__pyx_k__30), 0, 0, 1, 1},
  {&__pyx_n_s_add, __pyx_k_add, sizeof(__pyx_k_add), 0, 0, 1, 1},
  {&__pyx_n_s_addPythonFunction, __pyx_k_addPythonFunction, sizeof(__pyx_k_addPythonFunction), 0, 0, 1, 1},
  {&__pyx_n_s_all_active_refs, __pyx_k_all_active_refs, sizeof(__pyx_k_all_active_refs), 0, 0, 1, 1},
  {&__pyx_n_s_arg, __pyx_k_arg, sizeof(__pyx_k_arg), 0, 0, 1, 1},
  {&__pyx_n_s_args, __pyx_k_args, sizeof(__pyx_k_args), 0, 0, 1, 1},
  {&__pyx_n_s_arguments, __pyx_k_arguments, sizeof(__pyx_k_arguments), 0, 0, 1, 1},
  {&__pyx_n_s_arity, __pyx_k_arity, sizeof(__pyx_k_arity), 0, 0, 1, 1},
  {&__pyx_n_s_ascii, __pyx_k_ascii, sizeof(__pyx_k_ascii), 0, 0, 1, 1},
  {&__pyx_n_s_b, __pyx_k_b, sizeof(__pyx_k_b), 0, 0, 1, 1},
  {&__pyx_n_s_buffer, __pyx_k_buffer, sizeof(__pyx_k_buffer), 0, 0, 1, 1},
  {&__pyx_n_s_c_string, __pyx_k_c_string, sizeof(__pyx_k_c_string), 0, 0, 1, 1},
  {&__pyx_n_s_cinit, __pyx_k_cinit, sizeof(__pyx_k_cinit), 0, 0, 1, 1},
  {&__pyx_n_s_cleanup, __pyx_k_cleanup, sizeof(__pyx_k_cleanup), 0, 0, 1, 1},
  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
  {&__pyx_n_s_close, __pyx_k_close, sizeof(__pyx_k_close), 0, 0, 1, 1},
  {&__pyx_n_s_compare, __pyx_k_compare, sizeof(__pyx_k_compare), 0, 0, 1, 1},
  {&__pyx_kp_s_create_module_pyclp_call_python, __pyx_k_create_module_pyclp_call_python, sizeof(__pyx_k_create_module_pyclp_call_python), 0, 0, 1, 0},
  {&__pyx_n_s_cut, __pyx_k_cut, sizeof(__pyx_k_cut), 0, 0, 1, 1},
  {&__pyx_n_s_dealloc, __pyx_k_dealloc, sizeof(__pyx_k_dealloc), 0, 0, 1, 1},
  {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
  {&__pyx_n_s_eclipse_name, __pyx_k_eclipse_name, sizeof(__pyx_k_eclipse_name), 0, 0, 1, 1},
  {&__pyx_kp_s_eclipse_name_shall_be_a_text_got, __pyx_k_eclipse_name_shall_be_a_text_got, sizeof(__pyx_k_eclipse_name_shall_be_a_text_got), 0, 0, 1, 0},
  {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
  {&__pyx_n_s_encoded_name, __pyx_k_encoded_name, sizeof(__pyx_k_encoded_name), 0, 0, 1, 1},
  {&__pyx_n_s_fileno, __pyx_k_fileno, sizeof(__pyx_k_fileno), 0, 0, 1, 1},
  {&__pyx_n_s_flush, __pyx_k_flush, sizeof(__pyx_k_flush), 0, 0, 1, 1},
  {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
  {&__pyx_n_s_formatTermStr, __pyx_k_formatTermStr, sizeof(__pyx_k_formatTermStr), 0, 0, 1, 1},
  {&__pyx_n_s_func, __pyx_k_func, sizeof(__pyx_k_func), 0, 0, 1, 1},
  {&__pyx_kp_s_func_shall_be_a_function, __pyx_k_func_shall_be_a_function, sizeof(__pyx_k_func_shall_be_a_function), 0, 0, 1, 0},
  {&__pyx_n_s_functor_string, __pyx_k_functor_string, sizeof(__pyx_k_functor_string), 0, 0, 1, 1},
  {&__pyx_n_s_getListTail, __pyx_k_getListTail, sizeof(__pyx_k_getListTail), 0, 0, 1, 1},
  {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
  {&__pyx_n_s_head_generator, __pyx_k_head_generator, sizeof(__pyx_k_head_generator), 0, 0, 1, 1},
  {&__pyx_n_s_head_tail_generator, __pyx_k_head_tail_generator, sizeof(__pyx_k_head_tail_generator), 0, 0, 1, 1},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_in_list, __pyx_k_in_list, sizeof(__pyx_k_in_list), 0, 0, 1, 1},
  {&__pyx_n_s_in_pword, __pyx_k_in_pword, sizeof(__pyx_k_in_pword), 0, 0, 1, 1},
  {&__pyx_n_s_in_ref, __pyx_k_in_ref, sizeof(__pyx_k_in_ref), 0, 0, 1, 1},
  {&__pyx_n_s_in_term, __pyx_k_in_term, sizeof(__pyx_k_in_term), 0, 0, 1, 1},
  {&__pyx_n_s_init, __pyx_k_init, sizeof(__pyx_k_init), 0, 0, 1, 1},
  {&__pyx_n_s_init_2, __pyx_k_init_2, sizeof(__pyx_k_init_2), 0, 0, 1, 1},
  {&__pyx_n_s_init_arg, __pyx_k_init_arg, sizeof(__pyx_k_init_arg), 0, 0, 1, 1},
  {&__pyx_kp_s_init_argument_shall_be_a_string, __pyx_k_init_argument_shall_be_a_string, sizeof(__pyx_k_init_argument_shall_be_a_string), 0, 0, 1, 0},
  {&__pyx_kp_s_init_failed_registering_of_eclip, __pyx_k_init_failed_registering_of_eclip, sizeof(__pyx_k_init_failed_registering_of_eclip), 0, 0, 1, 0},
  {&__pyx_n_s_io, __pyx_k_io, sizeof(__pyx_k_io), 0, 0, 1, 1},
  {&__pyx_n_s_isNil, __pyx_k_isNil, sizeof(__pyx_k_isNil), 0, 0, 1, 1},
  {&__pyx_n_s_isatty, __pyx_k_isatty, sizeof(__pyx_k_isatty), 0, 0, 1, 1},
  {&__pyx_n_s_iterHeadTail, __pyx_k_iterHeadTail, sizeof(__pyx_k_iterHeadTail), 0, 0, 1, 1},
  {&__pyx_n_s_join, __pyx_k_join, sizeof(__pyx_k_join), 0, 0, 1, 1},
  {&__pyx_n_s_last_resume_result, __pyx_k_last_resume_result, sizeof(__pyx_k_last_resume_result), 0, 0, 1, 1},
  {&__pyx_n_s_lenght, __pyx_k_lenght, sizeof(__pyx_k_lenght), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_map, __pyx_k_map, sizeof(__pyx_k_map), 0, 0, 1, 1},
  {&__pyx_n_s_metaclass, __pyx_k_metaclass, sizeof(__pyx_k_metaclass), 0, 0, 1, 1},
  {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
  {&__pyx_n_s_msg, __pyx_k_msg, sizeof(__pyx_k_msg), 0, 0, 1, 1},
  {&__pyx_n_s_n, __pyx_k_n, sizeof(__pyx_k_n), 0, 0, 1, 1},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
  {&__pyx_kp_s_name_shall_be_a_string_or_a_inte, __pyx_k_name_shall_be_a_string_or_a_inte, sizeof(__pyx_k_name_shall_be_a_string_or_a_inte), 0, 0, 1, 0},
  {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
  {&__pyx_n_s_num_bytes_read, __pyx_k_num_bytes_read, sizeof(__pyx_k_num_bytes_read), 0, 0, 1, 1},
  {&__pyx_n_s_option, __pyx_k_option, sizeof(__pyx_k_option), 0, 0, 1, 1},
  {&__pyx_n_s_prepare, __pyx_k_prepare, sizeof(__pyx_k_prepare), 0, 0, 1, 1},
  {&__pyx_n_s_pyPredicatesException, __pyx_k_pyPredicatesException, sizeof(__pyx_k_pyPredicatesException), 0, 0, 1, 1},
  {&__pyx_n_s_py_byte_string, __pyx_k_py_byte_string, sizeof(__pyx_k_py_byte_string), 0, 0, 1, 1},
  {&__pyx_n_s_pyclpEx, __pyx_k_pyclpEx, sizeof(__pyx_k_pyclpEx), 0, 0, 1, 1},
  {&__pyx_n_s_pyclpEx___init, __pyx_k_pyclpEx___init, sizeof(__pyx_k_pyclpEx___init), 0, 0, 1, 1},
  {&__pyx_n_s_pyclpEx___str, __pyx_k_pyclpEx___str, sizeof(__pyx_k_pyclpEx___str), 0, 0, 1, 1},
  {&__pyx_n_s_pyclp_pyclp, __pyx_k_pyclp_pyclp, sizeof(__pyx_k_pyclp_pyclp), 0, 0, 1, 1},
  {&__pyx_n_s_python_buffer, __pyx_k_python_buffer, sizeof(__pyx_k_python_buffer), 0, 0, 1, 1},
  {&__pyx_n_s_python_error, __pyx_k_python_error, sizeof(__pyx_k_python_error), 0, 0, 1, 1},
  {&__pyx_n_s_python_pred2func, __pyx_k_python_pred2func, sizeof(__pyx_k_python_pred2func), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
  {&__pyx_n_s_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 0, 1, 1},
  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
  {&__pyx_n_s_read, __pyx_k_read, sizeof(__pyx_k_read), 0, 0, 1, 1},
  {&__pyx_n_s_readable, __pyx_k_readable, sizeof(__pyx_k_readable), 0, 0, 1, 1},
  {&__pyx_n_s_readall, __pyx_k_readall, sizeof(__pyx_k_readall), 0, 0, 1, 1},
  {&__pyx_n_s_readinto, __pyx_k_readinto, sizeof(__pyx_k_readinto), 0, 0, 1, 1},
  {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
  {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
  {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
  {&__pyx_kp_s_requires_text_input_got_s, __pyx_k_requires_text_input_got_s, sizeof(__pyx_k_requires_text_input_got_s), 0, 0, 1, 0},
  {&__pyx_n_s_result, __pyx_k_result, sizeof(__pyx_k_result), 0, 0, 1, 1},
  {&__pyx_n_s_resume, __pyx_k_resume, sizeof(__pyx_k_resume), 0, 0, 1, 1},
  {&__pyx_n_s_returned_value, __pyx_k_returned_value, sizeof(__pyx_k_returned_value), 0, 0, 1, 1},
  {&__pyx_n_s_seekable, __pyx_k_seekable, sizeof(__pyx_k_seekable), 0, 0, 1, 1},
  {&__pyx_n_s_self, __pyx_k_self, sizeof(__pyx_k_self), 0, 0, 1, 1},
  {&__pyx_kp_s_self_ec_dict_ptr_cannot_be_conve, __pyx_k_self_ec_dict_ptr_cannot_be_conve, sizeof(__pyx_k_self_ec_dict_ptr_cannot_be_conve), 0, 0, 1, 0},
  {&__pyx_n_s_send, __pyx_k_send, sizeof(__pyx_k_send), 0, 0, 1, 1},
  {&__pyx_n_s_set_option, __pyx_k_set_option, sizeof(__pyx_k_set_option), 0, 0, 1, 1},
  {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
  {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
  {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
  {&__pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_k_src_pyclp_pyclp_pyx, sizeof(__pyx_k_src_pyclp_pyclp_pyx), 0, 0, 1, 0},
  {&__pyx_n_s_str, __pyx_k_str, sizeof(__pyx_k_str), 0, 0, 1, 1},
  {&__pyx_n_s_stream_num, __pyx_k_stream_num, sizeof(__pyx_k_stream_num), 0, 0, 1, 1},
  {&__pyx_n_s_string, __pyx_k_string, sizeof(__pyx_k_string), 0, 0, 1, 1},
  {&__pyx_n_s_sys, __pyx_k_sys, sizeof(__pyx_k_sys), 0, 0, 1, 1},
  {&__pyx_n_s_tail, __pyx_k_tail, sizeof(__pyx_k_tail), 0, 0, 1, 1},
  {&__pyx_n_s_term1, __pyx_k_term1, sizeof(__pyx_k_term1), 0, 0, 1, 1},
  {&__pyx_n_s_term1_term, __pyx_k_term1_term, sizeof(__pyx_k_term1_term), 0, 0, 1, 1},
  {&__pyx_n_s_term2, __pyx_k_term2, sizeof(__pyx_k_term2), 0, 0, 1, 1},
  {&__pyx_n_s_term2_term, __pyx_k_term2_term, sizeof(__pyx_k_term2_term), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_n_s_throw, __pyx_k_throw, sizeof(__pyx_k_throw), 0, 0, 1, 1},
  {&__pyx_n_s_truncate, __pyx_k_truncate, sizeof(__pyx_k_truncate), 0, 0, 1, 1},
  {&__pyx_n_s_types, __pyx_k_types, sizeof(__pyx_k_types), 0, 0, 1, 1},
  {&__pyx_n_s_unify, __pyx_k_unify, sizeof(__pyx_k_unify), 0, 0, 1, 1},
  {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
  {&__pyx_kp_s_value_shall_be_a_int, __pyx_k_value_shall_be_a_int, sizeof(__pyx_k_value_shall_be_a_int), 0, 0, 1, 0},
  {&__pyx_kp_s_value_shall_be_a_string, __pyx_k_value_shall_be_a_string, sizeof(__pyx_k_value_shall_be_a_string), 0, 0, 1, 0},
  {&__pyx_n_s_weakref, __pyx_k_weakref, sizeof(__pyx_k_weakref), 0, 0, 1, 1},
  {&__pyx_n_s_write, __pyx_k_write, sizeof(__pyx_k_write), 0, 0, 1, 1},
  {&__pyx_n_s_writeable, __pyx_k_writeable, sizeof(__pyx_k_writeable), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 111, __pyx_L1_error)
  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
  __pyx_builtin_IOError = __Pyx_GetBuiltinName(__pyx_n_s_IOError); if (!__pyx_builtin_IOError) __PYX_ERR(0, 230, __pyx_L1_error)
  __pyx_builtin_NotImplemented = __Pyx_GetBuiltinName(__pyx_n_s_NotImplemented); if (!__pyx_builtin_NotImplemented) __PYX_ERR(0, 302, __pyx_L1_error)
  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 759, __pyx_L1_error)
  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(0, 813, __pyx_L1_error)
  __pyx_builtin_map = __Pyx_GetBuiltinName(__pyx_n_s_map); if (!__pyx_builtin_map) __PYX_ERR(0, 887, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__3);
  __Pyx_GIVEREF(__pyx_tuple__3);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__4);
  __Pyx_GIVEREF(__pyx_tuple__4);

  /* "pyclp/pyclp.pyx":234
 *             self.stream_num=name
 *         else:
 *             raise TypeError("name shall be a string or a integer")             # <<<<<<<<<<<<<<
 *     def seekable(self):
 *         return False
 */
  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_name_shall_be_a_string_or_a_inte); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 234, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__5);
  __Pyx_GIVEREF(__pyx_tuple__5);

  /* "pyclp/pyclp.pyx":266
 *         lenght=ec_queue_avail(<int>self.stream_num)
 *         if n==0:
 *             return bytes(0)             # <<<<<<<<<<<<<<
 *         elif n > 0:
 *             # Don't read more buffer than available.
 */
  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_int_0); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 266, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__6);
  __Pyx_GIVEREF(__pyx_tuple__6);

  /* "pyclp/pyclp.pyx":466
 *         # if exception was raised in external predicate
 *         # re-raise the exception otherwise return value
 *         if returned_value == Atom("python_error"):             # <<<<<<<<<<<<<<
 *             raise pyPredicatesException
 *         else:
 */
  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_n_s_python_error); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(0, 466, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__7);
  __Pyx_GIVEREF(__pyx_tuple__7);

  /* "pyclp/pyclp.pyx":497
 *                 raise pyclpEx("Invalid option in set_option")
 *         else:
 *             raise TypeError("value shall be a string")             # <<<<<<<<<<<<<<
 *     elif option == pyclp.EC_OPTION_LOCALSIZE or option == pyclp.EC_OPTION_GLOBALSIZE:
 *         if isinstance(value,int):
 */
  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_value_shall_be_a_string); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 497, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__8);
  __Pyx_GIVEREF(__pyx_tuple__8);

  /* "pyclp/pyclp.pyx":502
 *             ec_set_option_long(option,value)
 *         else:
 *             raise TypeError("value shall be a int")             # <<<<<<<<<<<<<<
 *     else:
 *         raise pyclpEx("Unsupported option")
 */
  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_value_shall_be_a_int); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 502, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__9);
  __Pyx_GIVEREF(__pyx_tuple__9);

  /* "pyclp/pyclp.pyx":533
 *                 self.ref.set(pyclp.ec_double(init_arg))
 *             else:
 *                 raise TypeError("init argument shall be a string, integer or float")             # <<<<<<<<<<<<<<
 *     cdef pyclp.pword get_pword(self):
 *         return self.ref.get()
 */
  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_init_argument_shall_be_a_string); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 533, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__10);
  __Pyx_GIVEREF(__pyx_tuple__10);

  /* "pyclp/pyclp.pyx":543
 *             return pyclp.ec_compare((<Term>self).get_pword(),(<Term>other).get_pword())
 *         else:
 *             raise TypeError("Comparison between incompatible types")             # <<<<<<<<<<<<<<
 * 
 *     def __cmp__(self,other):
 */
  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_Comparison_between_incompatible); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 543, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__11);
  __Pyx_GIVEREF(__pyx_tuple__11);

  /* "pyclp/pyclp.pyx":564
 *                 return True
 *             else:
 *                 raise TypeError("This comparison operation is not supported with None. Only supported comparison == !=")             # <<<<<<<<<<<<<<
 * 
 *         self_casted=<Term?>self
 */
  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_This_comparison_operation_is_not); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 564, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__12);
  __Pyx_GIVEREF(__pyx_tuple__12);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 */
  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_s_Pickling_of_struct_members_such); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__13);
  __Pyx_GIVEREF(__pyx_tuple__13);

  /* "(tree fragment)":4
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_Pickling_of_struct_members_such); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__14);
  __Pyx_GIVEREF(__pyx_tuple__14);

  /* "pyclp/pyclp.pyx":615
 *     # List is before because a list is also a Compound term.
 *     if pyclp.ec_get_list(in_pword,&head,&tail)== pyclp.PSUCCEED or pyclp.ec_get_nil(in_pword) == pyclp.PSUCCEED:
 *         result=PList(None)             # <<<<<<<<<<<<<<
 *         (<PList>result).set_pword(in_pword)
 *     elif pyclp.ec_get_functor(in_pword,&dummy_dident)== pyclp.PSUCCEED:
 */
  __pyx_tuple__15 = PyTuple_Pack(1, Py_None); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(0, 615, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__15);
  __Pyx_GIVEREF(__pyx_tuple__15);

  /* "pyclp/pyclp.pyx":652
 *         if string is not None:
 *             if not isinstance(string,str):
 *                 raise TypeError("Atom constructor accept only string")             # <<<<<<<<<<<<<<
 *             #Convert to byte array
 *             py_byte_string = tobytes(string)
 */
  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_Atom_constructor_accept_only_str); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 652, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__16);
  __Pyx_GIVEREF(__pyx_tuple__16);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_self_ec_dict_ptr_cannot_be_conve); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__17);
  __Pyx_GIVEREF(__pyx_tuple__17);

  /* "(tree fragment)":4
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_self_ec_dict_ptr_cannot_be_conve); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__18);
  __Pyx_GIVEREF(__pyx_tuple__18);

  /* "pyclp/pyclp.pyx":740
 *         if in_list is not None:
 *             if not( isinstance(in_list,list) or isinstance(in_list,tuple)):
 *                 raise TypeError("PList constructor accept only list or tuple")             # <<<<<<<<<<<<<<
 *             if not(isinstance(tail,list) or isinstance(tail,Term)):
 *                 raise TypeError("PList tail shall be a list or a Term")
 */
  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_s_PList_constructor_accept_only_li); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 740, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__20);
  __Pyx_GIVEREF(__pyx_tuple__20);

  /* "pyclp/pyclp.pyx":742
 *                 raise TypeError("PList constructor accept only list or tuple")
 *             if not(isinstance(tail,list) or isinstance(tail,Term)):
 *                 raise TypeError("PList tail shall be a list or a Term")             # <<<<<<<<<<<<<<
 *             list_lenght=len(in_list)
 *             # If lenght is 0 means an empty list --> []
 */
  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_PList_tail_shall_be_a_list_or_a); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 742, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__21);
  __Pyx_GIVEREF(__pyx_tuple__21);

  /* "pyclp/pyclp.pyx":757
 *                         tail_pword=(<Term>tail).get_pword()
 *                 else:
 *                     raise TypeError("PList tail shall be a list, tuple or  Term")             # <<<<<<<<<<<<<<
 *                 #Convert not Term arguments
 *                 for index in range(list_lenght-1,-1,-1):
 */
  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_PList_tail_shall_be_a_list_tuple); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(0, 757, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__22);
  __Pyx_GIVEREF(__pyx_tuple__22);

  /* "pyclp/pyclp.pyx":813
 *     cdef int get_head_tail(self,pyclp.pword *head_ptr,pyclp.pword *tail_ptr) except -1:
 *         if pyclp.ec_get_list(tail_ptr[0],head_ptr,tail_ptr) != pyclp.PSUCCEED:
 *             raise IndexError("Argument index out of range")             # <<<<<<<<<<<<<<
 *         return 1
 * 
 */
  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_Argument_index_out_of_range); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(0, 813, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__23);
  __Pyx_GIVEREF(__pyx_tuple__23);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 */
  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_Pickling_of_struct_members_such); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__25);
  __Pyx_GIVEREF(__pyx_tuple__25);

  /* "(tree fragment)":4
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_Pickling_of_struct_members_such); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__26);
  __Pyx_GIVEREF(__pyx_tuple__26);

  /* "pyclp/pyclp.pyx":996
 *         arity=self.arity()
 *         if not isinstance(index,int):
 *             raise TypeError("Index shall be a integer")             # <<<<<<<<<<<<<<
 *         else:
 *             c_index=<int>index
 */
  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_Index_shall_be_a_integer); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 996, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__27);
  __Pyx_GIVEREF(__pyx_tuple__27);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_s_self_ec_dict_ptr_cannot_be_conve); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__28);
  __Pyx_GIVEREF(__pyx_tuple__28);

  /* "(tree fragment)":4
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.ec_dict_ptr cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__29 = PyTuple_Pack(1, __pyx_kp_s_self_ec_dict_ptr_cannot_be_conve); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__29);
  __Pyx_GIVEREF(__pyx_tuple__29);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 */
  __pyx_tuple__31 = PyTuple_Pack(1, __pyx_kp_s_Pickling_of_struct_members_such); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__31);
  __Pyx_GIVEREF(__pyx_tuple__31);

  /* "(tree fragment)":4
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("Pickling of struct members such as self.cached_pword must be explicitly requested with @auto_pickle(True)")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__32 = PyTuple_Pack(1, __pyx_kp_s_Pickling_of_struct_members_such); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__32);
  __Pyx_GIVEREF(__pyx_tuple__32);

  /* "pyclp/pyclp.pyx":1111
 *     """
 *     if not isinstance(func,types.FunctionType):
 *         raise TypeError("func shall be a function")             # <<<<<<<<<<<<<<
 * 
 *     if isinstance(eclipse_name,unicode) or isinstance(eclipse_name,str):
 */
  __pyx_tuple__33 = PyTuple_Pack(1, __pyx_kp_s_func_shall_be_a_function); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(0, 1111, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__33);
  __Pyx_GIVEREF(__pyx_tuple__33);

  /* "pyclp/pyclp.pyx":76
 * 
 * class pyclpEx(Exception):
 *     def __init__(self,arg):             # <<<<<<<<<<<<<<
 *         self.msg=arg
 *     def __str__(self):
 */
  __pyx_tuple__34 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_arg); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(0, 76, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__34);
  __Pyx_GIVEREF(__pyx_tuple__34);
  __pyx_codeobj__35 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__34, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_init, 76, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__35)) __PYX_ERR(0, 76, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":78
 *     def __init__(self,arg):
 *         self.msg=arg
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         return self.msg
 * 
 */
  __pyx_tuple__36 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__36)) __PYX_ERR(0, 78, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__36);
  __Pyx_GIVEREF(__pyx_tuple__36);
  __pyx_codeobj__37 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__36, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_str, 78, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__37)) __PYX_ERR(0, 78, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":224
 * 
 *     """
 *     def __init__(self,name):             # <<<<<<<<<<<<<<
 *         if isinstance(name,str):
 *             self.name=name
 */
  __pyx_tuple__38 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_name, __pyx_n_s_encoded_name); if (unlikely(!__pyx_tuple__38)) __PYX_ERR(0, 224, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__38);
  __Pyx_GIVEREF(__pyx_tuple__38);
  __pyx_codeobj__39 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__38, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_init, 224, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__39)) __PYX_ERR(0, 224, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":235
 *         else:
 *             raise TypeError("name shall be a string or a integer")
 *     def seekable(self):             # <<<<<<<<<<<<<<
 *         return False
 *     def readable(self):
 */
  __pyx_tuple__40 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__40)) __PYX_ERR(0, 235, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__40);
  __Pyx_GIVEREF(__pyx_tuple__40);
  __pyx_codeobj__41 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__40, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_seekable, 235, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__41)) __PYX_ERR(0, 235, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":237
 *     def seekable(self):
 *         return False
 *     def readable(self):             # <<<<<<<<<<<<<<
 *         return True
 *     def writeable(self):
 */
  __pyx_tuple__42 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__42)) __PYX_ERR(0, 237, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__42);
  __Pyx_GIVEREF(__pyx_tuple__42);
  __pyx_codeobj__43 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__42, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_readable, 237, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__43)) __PYX_ERR(0, 237, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":239
 *     def readable(self):
 *         return True
 *     def writeable(self):             # <<<<<<<<<<<<<<
 *         return True
 *     def fileno(self):
 */
  __pyx_tuple__44 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__44)) __PYX_ERR(0, 239, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__44);
  __Pyx_GIVEREF(__pyx_tuple__44);
  __pyx_codeobj__45 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__44, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_writeable, 239, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__45)) __PYX_ERR(0, 239, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":241
 *     def writeable(self):
 *         return True
 *     def fileno(self):             # <<<<<<<<<<<<<<
 *         return self.stream_num
 *     def isatty(self):
 */
  __pyx_tuple__46 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__46)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__46);
  __Pyx_GIVEREF(__pyx_tuple__46);
  __pyx_codeobj__47 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__46, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_fileno, 241, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__47)) __PYX_ERR(0, 241, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":243
 *     def fileno(self):
 *         return self.stream_num
 *     def isatty(self):             # <<<<<<<<<<<<<<
 *         return False
 *     def truncate(self,size=None):
 */
  __pyx_tuple__48 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__48)) __PYX_ERR(0, 243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__48);
  __Pyx_GIVEREF(__pyx_tuple__48);
  __pyx_codeobj__49 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__48, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_isatty, 243, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__49)) __PYX_ERR(0, 243, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":245
 *     def isatty(self):
 *         return False
 *     def truncate(self,size=None):             # <<<<<<<<<<<<<<
 *         raise IOError
 *     def flush(self):
 */
  __pyx_tuple__50 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_size); if (unlikely(!__pyx_tuple__50)) __PYX_ERR(0, 245, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__50);
  __Pyx_GIVEREF(__pyx_tuple__50);
  __pyx_codeobj__51 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__50, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_truncate, 245, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__51)) __PYX_ERR(0, 245, __pyx_L1_error)
  __pyx_tuple__52 = PyTuple_Pack(1, ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__52)) __PYX_ERR(0, 245, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__52);
  __Pyx_GIVEREF(__pyx_tuple__52);

  /* "pyclp/pyclp.pyx":247
 *     def truncate(self,size=None):
 *         raise IOError
 *     def flush(self):             # <<<<<<<<<<<<<<
 *         """The semantic is different from usual Stream.
 *         In this case it does nothing
 */
  __pyx_tuple__53 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__53);
  __Pyx_GIVEREF(__pyx_tuple__53);
  __pyx_codeobj__54 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__53, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_flush, 247, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__54)) __PYX_ERR(0, 247, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":252
 *         """
 *         pass
 *     def read(self,int n=-1):             # <<<<<<<<<<<<<<
 *         """
 * 
 */
  __pyx_tuple__55 = PyTuple_Pack(6, __pyx_n_s_self, __pyx_n_s_n, __pyx_n_s_buffer, __pyx_n_s_lenght, __pyx_n_s_num_bytes_read, __pyx_n_s_python_buffer); if (unlikely(!__pyx_tuple__55)) __PYX_ERR(0, 252, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__55);
  __Pyx_GIVEREF(__pyx_tuple__55);
  __pyx_codeobj__56 = (PyObject*)__Pyx_PyCode_New(2, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__55, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_read, 252, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__56)) __PYX_ERR(0, 252, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":279
 *         libc.stdlib.free(buffer)
 *         return python_buffer
 *     def write(self,buffer):             # <<<<<<<<<<<<<<
 *         """
 *         Write a bytes object to stream.
 */
  __pyx_tuple__57 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_buffer, __pyx_n_s_lenght, __pyx_n_s_returned_value, __pyx_n_s_num_bytes_read); if (unlikely(!__pyx_tuple__57)) __PYX_ERR(0, 279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__57);
  __Pyx_GIVEREF(__pyx_tuple__57);
  __pyx_codeobj__58 = (PyObject*)__Pyx_PyCode_New(2, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__57, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_write, 279, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__58)) __PYX_ERR(0, 279, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":295
 *         else:
 *             return returned_value
 *     def readall(self):             # <<<<<<<<<<<<<<
 *         """
 *         Read all available bytes equivalent to :py:func:`pyclp.read`
 */
  __pyx_tuple__59 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__59)) __PYX_ERR(0, 295, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__59);
  __Pyx_GIVEREF(__pyx_tuple__59);
  __pyx_codeobj__60 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__59, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_readall, 295, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__60)) __PYX_ERR(0, 295, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":301
 *         """
 *         return self.read(-1)
 *     def readinto(self,b):             # <<<<<<<<<<<<<<
 *         raise NotImplemented()
 * 
 */
  __pyx_tuple__61 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_b); if (unlikely(!__pyx_tuple__61)) __PYX_ERR(0, 301, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__61);
  __Pyx_GIVEREF(__pyx_tuple__61);
  __pyx_codeobj__62 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__61, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_readinto, 301, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__62)) __PYX_ERR(0, 301, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":315
 *         if prolog_ref is not None and (<Ref?>prolog_ref).ref==NULL:
 *             prolog_ref.cinit()
 * def init():             # <<<<<<<<<<<<<<
 *     """This shall be called before calling any other function.
 *     This initialize Eclipse engine.
 */
  __pyx_codeobj__63 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_init_2, 315, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__63)) __PYX_ERR(0, 315, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":344
 * 
 * 
 * def cleanup():             # <<<<<<<<<<<<<<
 *     """This shutdown the Eclipse engine.
 *     After calling this function any operation on pyclp object or class could crash the program.
 */
  __pyx_codeobj__64 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_cleanup, 344, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__64)) __PYX_ERR(0, 344, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":369
 * 
 * 
 * def cut():             # <<<<<<<<<<<<<<
 *     """
 *     Cut all choice point of succeeded goal.
 */
  __pyx_codeobj__65 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_cut, 369, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__65)) __PYX_ERR(0, 369, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":389
 * 
 * 
 * def resume(in_term=None):             # <<<<<<<<<<<<<<
 *     """
 *     Resume Eclipse engine.
 */
  __pyx_tuple__66 = PyTuple_Pack(5, __pyx_n_s_in_term, __pyx_n_s_result, __pyx_n_s_in_pword, __pyx_n_s_in_ref, __pyx_n_s_returned_value); if (unlikely(!__pyx_tuple__66)) __PYX_ERR(0, 389, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__66);
  __Pyx_GIVEREF(__pyx_tuple__66);
  __pyx_codeobj__67 = (PyObject*)__Pyx_PyCode_New(1, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__66, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_resume, 389, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__67)) __PYX_ERR(0, 389, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":474
 * 
 * 
 * def set_option(option,value):             # <<<<<<<<<<<<<<
 *     """
 *     Set options of eclipse engine. Equivalent to
 */
  __pyx_tuple__68 = PyTuple_Pack(4, __pyx_n_s_option, __pyx_n_s_value, __pyx_n_s_py_byte_string, __pyx_n_s_c_string); if (unlikely(!__pyx_tuple__68)) __PYX_ERR(0, 474, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__68);
  __Pyx_GIVEREF(__pyx_tuple__68);
  __pyx_codeobj__69 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__68, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_set_option, 474, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__69)) __PYX_ERR(0, 474, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":1062
 * 
 * 
 * def unify(term1,term2):             # <<<<<<<<<<<<<<
 *     """
 *     Implements unify as described in
 */
  __pyx_tuple__70 = PyTuple_Pack(4, __pyx_n_s_term1, __pyx_n_s_term2, __pyx_n_s_term1_term, __pyx_n_s_term2_term); if (unlikely(!__pyx_tuple__70)) __PYX_ERR(0, 1062, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__70);
  __Pyx_GIVEREF(__pyx_tuple__70);
  __pyx_codeobj__71 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__70, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_unify, 1062, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__71)) __PYX_ERR(0, 1062, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":1093
 *         return FAIL
 * 
 * def addPythonFunction(eclipse_name,func):             # <<<<<<<<<<<<<<
 *     """
 *     Register a python function to be called from Eclipse using the predicate call_python.
 */
  __pyx_tuple__72 = PyTuple_Pack(2, __pyx_n_s_eclipse_name, __pyx_n_s_func); if (unlikely(!__pyx_tuple__72)) __PYX_ERR(0, 1093, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__72);
  __Pyx_GIVEREF(__pyx_tuple__72);
  __pyx_codeobj__73 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__72, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_pyclp_pyclp_pyx, __pyx_n_s_addPythonFunction, 1093, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__73)) __PYX_ERR(0, 1093, __pyx_L1_error)
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_3 = PyInt_FromLong(3); if (unlikely(!__pyx_int_3)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_4 = PyInt_FromLong(4); if (unlikely(!__pyx_int_4)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_5 = PyInt_FromLong(5); if (unlikely(!__pyx_int_5)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_function_export_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_type_init_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_type_import_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_variable_import_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_function_import_code(void); /*proto*/

static int __Pyx_modinit_global_init_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_global_init_code", 0);
  /*--- Global init code ---*/
  __pyx_v_5pyclp_5pyclp_toPython = ((struct __pyx_obj_5pyclp_5pyclp_Var *)Py_None); Py_INCREF(Py_None);
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_variable_export_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_export_code", 0);
  /*--- Variable export code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_function_export_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_function_export_code", 0);
  /*--- Function export code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_type_init_code(void) {
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
  /*--- Type init code ---*/
  __pyx_vtabptr_5pyclp_5pyclp_Ref = &__pyx_vtable_5pyclp_5pyclp_Ref;
  __pyx_vtable_5pyclp_5pyclp_Ref.get = (pword (*)(struct __pyx_obj_5pyclp_5pyclp_Ref *))__pyx_f_5pyclp_5pyclp_3Ref_get;
  __pyx_vtable_5pyclp_5pyclp_Ref.set = (void (*)(struct __pyx_obj_5pyclp_5pyclp_Ref *, pword))__pyx_f_5pyclp_5pyclp_3Ref_set;
  if (PyType_Ready(&__pyx_type_5pyclp_5pyclp_Ref) < 0) __PYX_ERR(0, 182, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_5pyclp_5pyclp_Ref.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_5pyclp_5pyclp_Ref.tp_dictoffset && __pyx_type_5pyclp_5pyclp_Ref.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_5pyclp_5pyclp_Ref.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  if (__Pyx_SetVtable(__pyx_type_5pyclp_5pyclp_Ref.tp_dict, __pyx_vtabptr_5pyclp_5pyclp_Ref) < 0) __PYX_ERR(0, 182, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Ref, (PyObject *)&__pyx_type_5pyclp_5pyclp_Ref) < 0) __PYX_ERR(0, 182, __pyx_L1_error)
  if (__pyx_type_5pyclp_5pyclp_Ref.tp_weaklistoffset == 0) __pyx_type_5pyclp_5pyclp_Ref.tp_weaklistoffset = offsetof(struct __pyx_obj_5pyclp_5pyclp_Ref, __weakref__);
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_5pyclp_5pyclp_Ref) < 0) __PYX_ERR(0, 182, __pyx_L1_error)
  __pyx_ptype_5pyclp_5pyclp_Ref = &__pyx_type_5pyclp_5pyclp_Ref;
  __pyx_vtabptr_5pyclp_5pyclp_Term = &__pyx_vtable_5pyclp_5pyclp_Term;
  __pyx_vtable_5pyclp_5pyclp_Term.get_pword = (pword (*)(struct __pyx_obj_5pyclp_5pyclp_Term *))__pyx_f_5pyclp_5pyclp_4Term_get_pword;
  __pyx_vtable_5pyclp_5pyclp_Term.set_pword = (int (*)(struct __pyx_obj_5pyclp_5pyclp_Term *, pword))__pyx_f_5pyclp_5pyclp_4Term_set_pword;
  __pyx_vtable_5pyclp_5pyclp_Term.compare_pword = (int (*)(struct __pyx_obj_5pyclp_5pyclp_Term *, PyObject *))__pyx_f_5pyclp_5pyclp_4Term_compare_pword;
  if (PyType_Ready(&__pyx_type_5pyclp_5pyclp_Term) < 0) __PYX_ERR(0, 506, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_5pyclp_5pyclp_Term.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_5pyclp_5pyclp_Term.tp_dictoffset && __pyx_type_5pyclp_5pyclp_Term.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_5pyclp_5pyclp_Term.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  if (__Pyx_SetVtable(__pyx_type_5pyclp_5pyclp_Term.tp_dict, __pyx_vtabptr_5pyclp_5pyclp_Term) < 0) __PYX_ERR(0, 506, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Term, (PyObject *)&__pyx_type_5pyclp_5pyclp_Term) < 0) __PYX_ERR(0, 506, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_5pyclp_5pyclp_Term) < 0) __PYX_ERR(0, 506, __pyx_L1_error)
  __pyx_ptype_5pyclp_5pyclp_Term = &__pyx_type_5pyclp_5pyclp_Term;
  __pyx_vtabptr_5pyclp_5pyclp_Atom = &__pyx_vtable_5pyclp_5pyclp_Atom;
  __pyx_vtable_5pyclp_5pyclp_Atom.__pyx_base = *__pyx_vtabptr_5pyclp_5pyclp_Term;
  __pyx_vtable_5pyclp_5pyclp_Atom.__pyx_base.set_pword = (int (*)(struct __pyx_obj_5pyclp_5pyclp_Term *, pword))__pyx_f_5pyclp_5pyclp_4Atom_set_pword;
  __pyx_type_5pyclp_5pyclp_Atom.tp_base = __pyx_ptype_5pyclp_5pyclp_Term;
  if (PyType_Ready(&__pyx_type_5pyclp_5pyclp_Atom) < 0) __PYX_ERR(0, 638, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_5pyclp_5pyclp_Atom.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_5pyclp_5pyclp_Atom.tp_dictoffset && __pyx_type_5pyclp_5pyclp_Atom.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_5pyclp_5pyclp_Atom.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  #if CYTHON_UPDATE_DESCRIPTOR_DOC
  {
    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_5pyclp_5pyclp_Atom, "__str__"); if (unlikely(!wrapper)) __PYX_ERR(0, 638, __pyx_L1_error)
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_5pyclp_5pyclp_4Atom_2__str__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_5pyclp_5pyclp_4Atom_2__str__.doc = __pyx_doc_5pyclp_5pyclp_4Atom_2__str__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_5pyclp_5pyclp_4Atom_2__str__;
    }
  }
  #endif
  if (__Pyx_SetVtable(__pyx_type_5pyclp_5pyclp_Atom.tp_dict, __pyx_vtabptr_5pyclp_5pyclp_Atom) < 0) __PYX_ERR(0, 638, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Atom, (PyObject *)&__pyx_type_5pyclp_5pyclp_Atom) < 0) __PYX_ERR(0, 638, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_5pyclp_5pyclp_Atom) < 0) __PYX_ERR(0, 638, __pyx_L1_error)
  __pyx_ptype_5pyclp_5pyclp_Atom = &__pyx_type_5pyclp_5pyclp_Atom;
  __pyx_vtabptr_5pyclp_5pyclp_PList = &__pyx_vtable_5pyclp_5pyclp_PList;
  __pyx_vtable_5pyclp_5pyclp_PList.__pyx_base = *__pyx_vtabptr_5pyclp_5pyclp_Term;
  __pyx_vtable_5pyclp_5pyclp_PList.get_head_tail = (int (*)(struct __pyx_obj_5pyclp_5pyclp_PList *, pword *, pword *))__pyx_f_5pyclp_5pyclp_5PList_get_head_tail;
  __pyx_vtable_5pyclp_5pyclp_PList.isNil = (int (*)(struct __pyx_obj_5pyclp_5pyclp_PList *, int __pyx_skip_dispatch))__pyx_f_5pyclp_5pyclp_5PList_isNil;
  __pyx_type_5pyclp_5pyclp_PList.tp_base = __pyx_ptype_5pyclp_5pyclp_Term;
  if (PyType_Ready(&__pyx_type_5pyclp_5pyclp_PList) < 0) __PYX_ERR(0, 679, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_5pyclp_5pyclp_PList.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_5pyclp_5pyclp_PList.tp_dictoffset && __pyx_type_5pyclp_5pyclp_PList.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_5pyclp_5pyclp_PList.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  #if CYTHON_UPDATE_DESCRIPTOR_DOC
  {
    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_5pyclp_5pyclp_PList, "__getitem__"); if (unlikely(!wrapper)) __PYX_ERR(0, 679, __pyx_L1_error)
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_5pyclp_5pyclp_5PList_16__getitem__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_5pyclp_5pyclp_5PList_16__getitem__.doc = __pyx_doc_5pyclp_5pyclp_5PList_16__getitem__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_5pyclp_5pyclp_5PList_16__getitem__;
    }
  }
  #endif
  #if CYTHON_UPDATE_DESCRIPTOR_DOC
  {
    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_5pyclp_5pyclp_PList, "__str__"); if (unlikely(!wrapper)) __PYX_ERR(0, 679, __pyx_L1_error)
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_5pyclp_5pyclp_5PList_22__str__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_5pyclp_5pyclp_5PList_22__str__.doc = __pyx_doc_5pyclp_5pyclp_5PList_22__str__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_5pyclp_5pyclp_5PList_22__str__;
    }
  }
  #endif
  if (__Pyx_SetVtable(__pyx_type_5pyclp_5pyclp_PList.tp_dict, __pyx_vtabptr_5pyclp_5pyclp_PList) < 0) __PYX_ERR(0, 679, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_PList, (PyObject *)&__pyx_type_5pyclp_5pyclp_PList) < 0) __PYX_ERR(0, 679, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_5pyclp_5pyclp_PList) < 0) __PYX_ERR(0, 679, __pyx_L1_error)
  __pyx_ptype_5pyclp_5pyclp_PList = &__pyx_type_5pyclp_5pyclp_PList;
  __pyx_vtabptr_5pyclp_5pyclp_Compound = &__pyx_vtable_5pyclp_5pyclp_Compound;
  __pyx_vtable_5pyclp_5pyclp_Compound.__pyx_base = *__pyx_vtabptr_5pyclp_5pyclp_Term;
  __pyx_vtable_5pyclp_5pyclp_Compound.__pyx_base.set_pword = (int (*)(struct __pyx_obj_5pyclp_5pyclp_Term *, pword))__pyx_f_5pyclp_5pyclp_8Compound_set_pword;
  __pyx_vtable_5pyclp_5pyclp_Compound.arity = (int (*)(struct __pyx_obj_5pyclp_5pyclp_Compound *, int __pyx_skip_dispatch))__pyx_f_5pyclp_5pyclp_8Compound_arity;
  __pyx_vtable_5pyclp_5pyclp_Compound.get_functor_string = (PyObject *(*)(struct __pyx_obj_5pyclp_5pyclp_Compound *))__pyx_f_5pyclp_5pyclp_8Compound_get_functor_string;
  __pyx_type_5pyclp_5pyclp_Compound.tp_base = __pyx_ptype_5pyclp_5pyclp_Term;
  if (PyType_Ready(&__pyx_type_5pyclp_5pyclp_Compound) < 0) __PYX_ERR(0, 898, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_5pyclp_5pyclp_Compound.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_5pyclp_5pyclp_Compound.tp_dictoffset && __pyx_type_5pyclp_5pyclp_Compound.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_5pyclp_5pyclp_Compound.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  if (__Pyx_SetVtable(__pyx_type_5pyclp_5pyclp_Compound.tp_dict, __pyx_vtabptr_5pyclp_5pyclp_Compound) < 0) __PYX_ERR(0, 898, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Compound, (PyObject *)&__pyx_type_5pyclp_5pyclp_Compound) < 0) __PYX_ERR(0, 898, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_5pyclp_5pyclp_Compound) < 0) __PYX_ERR(0, 898, __pyx_L1_error)
  __pyx_ptype_5pyclp_5pyclp_Compound = &__pyx_type_5pyclp_5pyclp_Compound;
  __pyx_vtabptr_5pyclp_5pyclp_Var = &__pyx_vtable_5pyclp_5pyclp_Var;
  __pyx_vtable_5pyclp_5pyclp_Var.__pyx_base = *__pyx_vtabptr_5pyclp_5pyclp_Term;
  __pyx_vtable_5pyclp_5pyclp_Var.value = (PyObject *(*)(struct __pyx_obj_5pyclp_5pyclp_Var *, int __pyx_skip_dispatch))__pyx_f_5pyclp_5pyclp_3Var_value;
  __pyx_type_5pyclp_5pyclp_Var.tp_base = __pyx_ptype_5pyclp_5pyclp_Term;
  if (PyType_Ready(&__pyx_type_5pyclp_5pyclp_Var) < 0) __PYX_ERR(0, 1031, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_5pyclp_5pyclp_Var.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_5pyclp_5pyclp_Var.tp_dictoffset && __pyx_type_5pyclp_5pyclp_Var.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_5pyclp_5pyclp_Var.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  #if CYTHON_UPDATE_DESCRIPTOR_DOC
  {
    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_5pyclp_5pyclp_Var, "__str__"); if (unlikely(!wrapper)) __PYX_ERR(0, 1031, __pyx_L1_error)
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_5pyclp_5pyclp_3Var_4__str__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_5pyclp_5pyclp_3Var_4__str__.doc = __pyx_doc_5pyclp_5pyclp_3Var_4__str__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_5pyclp_5pyclp_3Var_4__str__;
    }
  }
  #endif
  if (__Pyx_SetVtable(__pyx_type_5pyclp_5pyclp_Var.tp_dict, __pyx_vtabptr_5pyclp_5pyclp_Var) < 0) __PYX_ERR(0, 1031, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Var, (PyObject *)&__pyx_type_5pyclp_5pyclp_Var) < 0) __PYX_ERR(0, 1031, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_5pyclp_5pyclp_Var) < 0) __PYX_ERR(0, 1031, __pyx_L1_error)
  __pyx_ptype_5pyclp_5pyclp_Var = &__pyx_type_5pyclp_5pyclp_Var;
  if (PyType_Ready(&__pyx_type_5pyclp_5pyclp___pyx_scope_struct__head_generator) < 0) __PYX_ERR(0, 771, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_5pyclp_5pyclp___pyx_scope_struct__head_generator.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_5pyclp_5pyclp___pyx_scope_struct__head_generator.tp_dictoffset && __pyx_type_5pyclp_5pyclp___pyx_scope_struct__head_generator.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_5pyclp_5pyclp___pyx_scope_struct__head_generator.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_5pyclp_5pyclp___pyx_scope_struct__head_generator = &__pyx_type_5pyclp_5pyclp___pyx_scope_struct__head_generator;
  if (PyType_Ready(&__pyx_type_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator) < 0) __PYX_ERR(0, 781, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator.tp_dictoffset && __pyx_type_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator = &__pyx_type_5pyclp_5pyclp___pyx_scope_struct_1_head_tail_generator;
  if (PyType_Ready(&__pyx_type_5pyclp_5pyclp___pyx_scope_struct_2_arguments) < 0) __PYX_ERR(0, 970, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_5pyclp_5pyclp___pyx_scope_struct_2_arguments.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_5pyclp_5pyclp___pyx_scope_struct_2_arguments.tp_dictoffset && __pyx_type_5pyclp_5pyclp___pyx_scope_struct_2_arguments.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_5pyclp_5pyclp___pyx_scope_struct_2_arguments.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_5pyclp_5pyclp___pyx_scope_struct_2_arguments = &__pyx_type_5pyclp_5pyclp___pyx_scope_struct_2_arguments;
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_modinit_type_import_code(void) {
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
  /*--- Type import code ---*/
  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 9, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
  #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT(PyTypeObject),
  #else
  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT(PyHeapTypeObject),
  #endif
  __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 8, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), __PYX_GET_STRUCT_ALIGNMENT(PyBoolObject),
  __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_4bool_bool) __PYX_ERR(3, 8, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 15, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), __PYX_GET_STRUCT_ALIGNMENT(PyComplexObject),
  __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_7complex_complex) __PYX_ERR(4, 15, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_modinit_variable_import_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_import_code", 0);
  /*--- Variable import code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_function_import_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
  /*--- Function import code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}


#ifndef CYTHON_NO_PYINIT_EXPORT
#define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
#elif PY_MAJOR_VERSION < 3
#ifdef __cplusplus
#define __Pyx_PyMODINIT_FUNC extern "C" void
#else
#define __Pyx_PyMODINIT_FUNC void
#endif
#else
#ifdef __cplusplus
#define __Pyx_PyMODINIT_FUNC extern "C" PyObject *
#else
#define __Pyx_PyMODINIT_FUNC PyObject *
#endif
#endif


#if PY_MAJOR_VERSION < 3
__Pyx_PyMODINIT_FUNC initpyclp(void) CYTHON_SMALL_CODE; /*proto*/
__Pyx_PyMODINIT_FUNC initpyclp(void)
#else
__Pyx_PyMODINIT_FUNC PyInit_pyclp(void) CYTHON_SMALL_CODE; /*proto*/
__Pyx_PyMODINIT_FUNC PyInit_pyclp(void)
#if CYTHON_PEP489_MULTI_PHASE_INIT
{
  return PyModuleDef_Init(&__pyx_moduledef);
}
static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
    #if PY_VERSION_HEX >= 0x030700A1
    static PY_INT64_T main_interpreter_id = -1;
    PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);
    if (main_interpreter_id == -1) {
        main_interpreter_id = current_id;
        return (unlikely(current_id == -1)) ? -1 : 0;
    } else if (unlikely(main_interpreter_id != current_id))
    #else
    static PyInterpreterState *main_interpreter = NULL;
    PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;
    if (!main_interpreter) {
        main_interpreter = current_interpreter;
    } else if (unlikely(main_interpreter != current_interpreter))
    #endif
    {
        PyErr_SetString(
            PyExc_ImportError,
            "Interpreter change detected - this module can only be loaded into one interpreter per process.");
        return -1;
    }
    return 0;
}
static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
    PyObject *value = PyObject_GetAttrString(spec, from_name);
    int result = 0;
    if (likely(value)) {
        if (allow_none || value != Py_None) {
            result = PyDict_SetItemString(moddict, to_name, value);
        }
        Py_DECREF(value);
    } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Clear();
    } else {
        result = -1;
    }
    return result;
}
static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
    PyObject *module = NULL, *moddict, *modname;
    if (__Pyx_check_single_interpreter())
        return NULL;
    if (__pyx_m)
        return __Pyx_NewRef(__pyx_m);
    modname = PyObject_GetAttrString(spec, "name");
    if (unlikely(!modname)) goto bad;
    module = PyModule_NewObject(modname);
    Py_DECREF(modname);
    if (unlikely(!module)) goto bad;
    moddict = PyModule_GetDict(module);
    if (unlikely(!moddict)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__", 0) < 0)) goto bad;
    return module;
bad:
    Py_XDECREF(module);
    return NULL;
}


static CYTHON_SMALL_CODE int __pyx_pymod_exec_pyclp(PyObject *__pyx_pyinit_module)
#endif
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  if (__pyx_m) {
    if (__pyx_m == __pyx_pyinit_module) return 0;
    PyErr_SetString(PyExc_RuntimeError, "Module 'pyclp' has already been imported. Re-initialisation is not supported.");
    return -1;
  }
  #elif PY_MAJOR_VERSION >= 3
  if (__pyx_m) return __Pyx_NewRef(__pyx_m);
  #endif
  #if CYTHON_REFNANNY
__Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
if (!__Pyx_RefNanny) {
  PyErr_Clear();
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
  if (!__Pyx_RefNanny)
      Py_FatalError("failed to import 'refnanny' module");
}
#endif
  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_pyclp(void)", 0);
  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pxy_PyFrame_Initialize_Offsets
  __Pxy_PyFrame_Initialize_Offsets();
  #endif
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pyx_CyFunction_USED
  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Coroutine_USED
  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_AsyncGen_USED
  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_StopAsyncIteration_USED
  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(WITH_THREAD) && PY_VERSION_HEX < 0x030700F0 && defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  PyEval_InitThreads();
  #endif
  /*--- Module creation code ---*/
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  __pyx_m = __pyx_pyinit_module;
  Py_INCREF(__pyx_m);
  #else
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("pyclp", __pyx_methods, __pyx_k_Pyclp_is_a_Python_library_to_in, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_b);
  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_cython_runtime);
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Initialize various global constants etc. ---*/
  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  if (__pyx_module_is_main_pyclp__pyclp) {
    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name_2, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
    if (!PyDict_GetItemString(modules, "pyclp.pyclp")) {
      if (unlikely(PyDict_SetItemString(modules, "pyclp.pyclp", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Constants init code ---*/
  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Global type/function init code ---*/
  (void)__Pyx_modinit_global_init_code();
  (void)__Pyx_modinit_variable_export_code();
  (void)__Pyx_modinit_function_export_code();
  if (unlikely(__Pyx_modinit_type_init_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
  if (unlikely(__Pyx_modinit_type_import_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
  (void)__Pyx_modinit_variable_import_code();
  (void)__Pyx_modinit_function_import_code();
  /*--- Execution code ---*/
  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif

  /* "pyclp/pyclp.pyx":34
 * cimport cpython
 * cimport libc.stdlib
 * import io,sys             # <<<<<<<<<<<<<<
 * import weakref
 * import string
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_io, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 34, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_io, __pyx_t_1) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_sys, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 34, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sys, __pyx_t_1) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":35
 * cimport libc.stdlib
 * import io,sys
 * import weakref             # <<<<<<<<<<<<<<
 * import string
 * import types
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_weakref, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 35, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_weakref, __pyx_t_1) < 0) __PYX_ERR(0, 35, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":36
 * import io,sys
 * import weakref
 * import string             # <<<<<<<<<<<<<<
 * import types
 * from cpython.version cimport PY_MAJOR_VERSION
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_string, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 36, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_string, __pyx_t_1) < 0) __PYX_ERR(0, 36, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":37
 * import weakref
 * import string
 * import types             # <<<<<<<<<<<<<<
 * from cpython.version cimport PY_MAJOR_VERSION
 * 
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_types, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 37, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_types, __pyx_t_1) < 0) __PYX_ERR(0, 37, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":41
 * 
 * #Store a global reference used to return data from eclipse engine.
 * cdef Var toPython=None             # <<<<<<<<<<<<<<
 * python_pred2func={}
 * last_resume_result=None
 */
  __Pyx_INCREF(Py_None);
  __Pyx_XGOTREF(((PyObject *)__pyx_v_5pyclp_5pyclp_toPython));
  __Pyx_DECREF_SET(__pyx_v_5pyclp_5pyclp_toPython, ((struct __pyx_obj_5pyclp_5pyclp_Var *)Py_None));
  __Pyx_GIVEREF(Py_None);

  /* "pyclp/pyclp.pyx":42
 * #Store a global reference used to return data from eclipse engine.
 * cdef Var toPython=None
 * python_pred2func={}             # <<<<<<<<<<<<<<
 * last_resume_result=None
 * # Store a weak reference in order to support cleanup function
 */
  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 42, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_python_pred2func, __pyx_t_1) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":43
 * cdef Var toPython=None
 * python_pred2func={}
 * last_resume_result=None             # <<<<<<<<<<<<<<
 * # Store a weak reference in order to support cleanup function
 * # All reference need to be destroyed before cleanup of eclipse engine
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_last_resume_result, Py_None) < 0) __PYX_ERR(0, 43, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":46
 * # Store a weak reference in order to support cleanup function
 * # All reference need to be destroyed before cleanup of eclipse engine
 * all_active_refs=weakref.WeakSet()             # <<<<<<<<<<<<<<
 * # Flag to signal when eclipse engine is initialized.
 * cdef int eclipse_initialized=0
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_weakref); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 46, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_WeakSet); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 46, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 46, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_all_active_refs, __pyx_t_1) < 0) __PYX_ERR(0, 46, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":48
 * all_active_refs=weakref.WeakSet()
 * # Flag to signal when eclipse engine is initialized.
 * cdef int eclipse_initialized=0             # <<<<<<<<<<<<<<
 * #Store exceptions raised by predicates implemented in Python
 * pyPredicatesException=None
 */
  __pyx_v_5pyclp_5pyclp_eclipse_initialized = 0;

  /* "pyclp/pyclp.pyx":50
 * cdef int eclipse_initialized=0
 * #Store exceptions raised by predicates implemented in Python
 * pyPredicatesException=None             # <<<<<<<<<<<<<<
 * 
 * 
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyPredicatesException, Py_None) < 0) __PYX_ERR(0, 50, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":53
 * 
 * 
 * SUCCEED=True             # <<<<<<<<<<<<<<
 * FLUSHIO=pyclp.PFLUSHIO
 * WAITIO=pyclp.PWAITIO
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_SUCCEED, Py_True) < 0) __PYX_ERR(0, 53, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":54
 * 
 * SUCCEED=True
 * FLUSHIO=pyclp.PFLUSHIO             # <<<<<<<<<<<<<<
 * WAITIO=pyclp.PWAITIO
 * FAIL=False
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(PFLUSHIO); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 54, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FLUSHIO, __pyx_t_1) < 0) __PYX_ERR(0, 54, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":55
 * SUCCEED=True
 * FLUSHIO=pyclp.PFLUSHIO
 * WAITIO=pyclp.PWAITIO             # <<<<<<<<<<<<<<
 * FAIL=False
 * YIELD=pyclp.PYIELD
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(PWAITIO); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 55, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_WAITIO, __pyx_t_1) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":56
 * FLUSHIO=pyclp.PFLUSHIO
 * WAITIO=pyclp.PWAITIO
 * FAIL=False             # <<<<<<<<<<<<<<
 * YIELD=pyclp.PYIELD
 * THROW=pyclp.PTHROW
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FAIL, Py_False) < 0) __PYX_ERR(0, 56, __pyx_L1_error)

  /* "pyclp/pyclp.pyx":57
 * WAITIO=pyclp.PWAITIO
 * FAIL=False
 * YIELD=pyclp.PYIELD             # <<<<<<<<<<<<<<
 * THROW=pyclp.PTHROW
 * OPTION_IO=pyclp.EC_OPTION_IO
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(PYIELD); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 57, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_YIELD, __pyx_t_1) < 0) __PYX_ERR(0, 57, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":58
 * FAIL=False
 * YIELD=pyclp.PYIELD
 * THROW=pyclp.PTHROW             # <<<<<<<<<<<<<<
 * OPTION_IO=pyclp.EC_OPTION_IO
 * OPTION_MAPFILE=pyclp.EC_OPTION_MAPFILE
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(PTHROW); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 58, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_THROW, __pyx_t_1) < 0) __PYX_ERR(0, 58, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":59
 * YIELD=pyclp.PYIELD
 * THROW=pyclp.PTHROW
 * OPTION_IO=pyclp.EC_OPTION_IO             # <<<<<<<<<<<<<<
 * OPTION_MAPFILE=pyclp.EC_OPTION_MAPFILE
 * OPTION_PARALLEL_WORKER=pyclp.EC_OPTION_PARALLEL_WORKER
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_IO); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 59, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_IO, __pyx_t_1) < 0) __PYX_ERR(0, 59, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":60
 * THROW=pyclp.PTHROW
 * OPTION_IO=pyclp.EC_OPTION_IO
 * OPTION_MAPFILE=pyclp.EC_OPTION_MAPFILE             # <<<<<<<<<<<<<<
 * OPTION_PARALLEL_WORKER=pyclp.EC_OPTION_PARALLEL_WORKER
 * OPTION_ARGC=pyclp.EC_OPTION_ARGC
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_MAPFILE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 60, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_MAPFILE, __pyx_t_1) < 0) __PYX_ERR(0, 60, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":61
 * OPTION_IO=pyclp.EC_OPTION_IO
 * OPTION_MAPFILE=pyclp.EC_OPTION_MAPFILE
 * OPTION_PARALLEL_WORKER=pyclp.EC_OPTION_PARALLEL_WORKER             # <<<<<<<<<<<<<<
 * OPTION_ARGC=pyclp.EC_OPTION_ARGC
 * OPTION_ARGV=pyclp.EC_OPTION_ARGV
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_PARALLEL_WORKER); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 61, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_PARALLEL_WORKER, __pyx_t_1) < 0) __PYX_ERR(0, 61, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":62
 * OPTION_MAPFILE=pyclp.EC_OPTION_MAPFILE
 * OPTION_PARALLEL_WORKER=pyclp.EC_OPTION_PARALLEL_WORKER
 * OPTION_ARGC=pyclp.EC_OPTION_ARGC             # <<<<<<<<<<<<<<
 * OPTION_ARGV=pyclp.EC_OPTION_ARGV
 * OPTION_LOCALSIZE=pyclp.EC_OPTION_LOCALSIZE
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_ARGC); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 62, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_ARGC, __pyx_t_1) < 0) __PYX_ERR(0, 62, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":63
 * OPTION_PARALLEL_WORKER=pyclp.EC_OPTION_PARALLEL_WORKER
 * OPTION_ARGC=pyclp.EC_OPTION_ARGC
 * OPTION_ARGV=pyclp.EC_OPTION_ARGV             # <<<<<<<<<<<<<<
 * OPTION_LOCALSIZE=pyclp.EC_OPTION_LOCALSIZE
 * OPTION_GLOBALSIZE=pyclp.EC_OPTION_GLOBALSIZE
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_ARGV); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 63, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_ARGV, __pyx_t_1) < 0) __PYX_ERR(0, 63, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":64
 * OPTION_ARGC=pyclp.EC_OPTION_ARGC
 * OPTION_ARGV=pyclp.EC_OPTION_ARGV
 * OPTION_LOCALSIZE=pyclp.EC_OPTION_LOCALSIZE             # <<<<<<<<<<<<<<
 * OPTION_GLOBALSIZE=pyclp.EC_OPTION_GLOBALSIZE
 * OPTION_PRIVATESIZE=pyclp.EC_OPTION_PRIVATESIZE
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_LOCALSIZE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 64, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_LOCALSIZE, __pyx_t_1) < 0) __PYX_ERR(0, 64, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":65
 * OPTION_ARGV=pyclp.EC_OPTION_ARGV
 * OPTION_LOCALSIZE=pyclp.EC_OPTION_LOCALSIZE
 * OPTION_GLOBALSIZE=pyclp.EC_OPTION_GLOBALSIZE             # <<<<<<<<<<<<<<
 * OPTION_PRIVATESIZE=pyclp.EC_OPTION_PRIVATESIZE
 * OPTION_SHAREDSIZE=pyclp.EC_OPTION_SHAREDSIZE
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_GLOBALSIZE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 65, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_GLOBALSIZE, __pyx_t_1) < 0) __PYX_ERR(0, 65, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":66
 * OPTION_LOCALSIZE=pyclp.EC_OPTION_LOCALSIZE
 * OPTION_GLOBALSIZE=pyclp.EC_OPTION_GLOBALSIZE
 * OPTION_PRIVATESIZE=pyclp.EC_OPTION_PRIVATESIZE             # <<<<<<<<<<<<<<
 * OPTION_SHAREDSIZE=pyclp.EC_OPTION_SHAREDSIZE
 * OPTION_PANIC=pyclp.EC_OPTION_PANIC
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_PRIVATESIZE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 66, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_PRIVATESIZE, __pyx_t_1) < 0) __PYX_ERR(0, 66, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":67
 * OPTION_GLOBALSIZE=pyclp.EC_OPTION_GLOBALSIZE
 * OPTION_PRIVATESIZE=pyclp.EC_OPTION_PRIVATESIZE
 * OPTION_SHAREDSIZE=pyclp.EC_OPTION_SHAREDSIZE             # <<<<<<<<<<<<<<
 * OPTION_PANIC=pyclp.EC_OPTION_PANIC
 * OPTION_ALLOCATION=pyclp.EC_OPTION_ALLOCATION
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_SHAREDSIZE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 67, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_SHAREDSIZE, __pyx_t_1) < 0) __PYX_ERR(0, 67, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":68
 * OPTION_PRIVATESIZE=pyclp.EC_OPTION_PRIVATESIZE
 * OPTION_SHAREDSIZE=pyclp.EC_OPTION_SHAREDSIZE
 * OPTION_PANIC=pyclp.EC_OPTION_PANIC             # <<<<<<<<<<<<<<
 * OPTION_ALLOCATION=pyclp.EC_OPTION_ALLOCATION
 * OPTION_DEFAULT_MODULE=pyclp.EC_OPTION_DEFAULT_MODULE
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_PANIC); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_PANIC, __pyx_t_1) < 0) __PYX_ERR(0, 68, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":69
 * OPTION_SHAREDSIZE=pyclp.EC_OPTION_SHAREDSIZE
 * OPTION_PANIC=pyclp.EC_OPTION_PANIC
 * OPTION_ALLOCATION=pyclp.EC_OPTION_ALLOCATION             # <<<<<<<<<<<<<<
 * OPTION_DEFAULT_MODULE=pyclp.EC_OPTION_DEFAULT_MODULE
 * OPTION_ECLIPSEDIR=pyclp.EC_OPTION_ECLIPSEDIR
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_ALLOCATION); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 69, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_ALLOCATION, __pyx_t_1) < 0) __PYX_ERR(0, 69, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":70
 * OPTION_PANIC=pyclp.EC_OPTION_PANIC
 * OPTION_ALLOCATION=pyclp.EC_OPTION_ALLOCATION
 * OPTION_DEFAULT_MODULE=pyclp.EC_OPTION_DEFAULT_MODULE             # <<<<<<<<<<<<<<
 * OPTION_ECLIPSEDIR=pyclp.EC_OPTION_ECLIPSEDIR
 * OPTION_INIT=pyclp.EC_OPTION_INIT
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_DEFAULT_MODULE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 70, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_DEFAULT_MODULE, __pyx_t_1) < 0) __PYX_ERR(0, 70, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":71
 * OPTION_ALLOCATION=pyclp.EC_OPTION_ALLOCATION
 * OPTION_DEFAULT_MODULE=pyclp.EC_OPTION_DEFAULT_MODULE
 * OPTION_ECLIPSEDIR=pyclp.EC_OPTION_ECLIPSEDIR             # <<<<<<<<<<<<<<
 * OPTION_INIT=pyclp.EC_OPTION_INIT
 * OPTION_DEBUG_LEVEL=pyclp.EC_OPTION_DEBUG_LEVEL
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_ECLIPSEDIR); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 71, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_ECLIPSEDIR, __pyx_t_1) < 0) __PYX_ERR(0, 71, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":72
 * OPTION_DEFAULT_MODULE=pyclp.EC_OPTION_DEFAULT_MODULE
 * OPTION_ECLIPSEDIR=pyclp.EC_OPTION_ECLIPSEDIR
 * OPTION_INIT=pyclp.EC_OPTION_INIT             # <<<<<<<<<<<<<<
 * OPTION_DEBUG_LEVEL=pyclp.EC_OPTION_DEBUG_LEVEL
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_INIT); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 72, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_INIT, __pyx_t_1) < 0) __PYX_ERR(0, 72, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":73
 * OPTION_ECLIPSEDIR=pyclp.EC_OPTION_ECLIPSEDIR
 * OPTION_INIT=pyclp.EC_OPTION_INIT
 * OPTION_DEBUG_LEVEL=pyclp.EC_OPTION_DEBUG_LEVEL             # <<<<<<<<<<<<<<
 * 
 * class pyclpEx(Exception):
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(EC_OPTION_DEBUG_LEVEL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 73, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OPTION_DEBUG_LEVEL, __pyx_t_1) < 0) __PYX_ERR(0, 73, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":75
 * OPTION_DEBUG_LEVEL=pyclp.EC_OPTION_DEBUG_LEVEL
 * 
 * class pyclpEx(Exception):             # <<<<<<<<<<<<<<
 *     def __init__(self,arg):
 *         self.msg=arg
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
  __Pyx_GIVEREF(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 75, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_pyclpEx, __pyx_n_s_pyclpEx, (PyObject *) NULL, __pyx_n_s_pyclp_pyclp, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 75, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "pyclp/pyclp.pyx":76
 * 
 * class pyclpEx(Exception):
 *     def __init__(self,arg):             # <<<<<<<<<<<<<<
 *         self.msg=arg
 *     def __str__(self):
 */
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_7pyclpEx_1__init__, 0, __pyx_n_s_pyclpEx___init, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__35)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 76, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_init, __pyx_t_4) < 0) __PYX_ERR(0, 76, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":78
 *     def __init__(self,arg):
 *         self.msg=arg
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         return self.msg
 * 
 */
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_7pyclpEx_3__str__, 0, __pyx_n_s_pyclpEx___str, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__37)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 78, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_str, __pyx_t_4) < 0) __PYX_ERR(0, 78, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":75
 * OPTION_DEBUG_LEVEL=pyclp.EC_OPTION_DEBUG_LEVEL
 * 
 * class pyclpEx(Exception):             # <<<<<<<<<<<<<<
 *     def __init__(self,arg):
 *         self.msg=arg
 */
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_pyclpEx, __pyx_t_1, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 75, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyclpEx, __pyx_t_4) < 0) __PYX_ERR(0, 75, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":204
 *         pyclp.ec_ref_set(self.ref,pr_word)
 * 
 * class Stream(io.RawIOBase):             # <<<<<<<<<<<<<<
 *     """Class to support streams to and from ECLiPSe.
 *     This is class is derived from io.RawIOBase.
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_io); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_RawIOBase); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_Stream, __pyx_n_s_Stream, (PyObject *) NULL, __pyx_n_s_pyclp_pyclp, __pyx_kp_s_Class_to_support_streams_to_and); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "pyclp/pyclp.pyx":224
 * 
 *     """
 *     def __init__(self,name):             # <<<<<<<<<<<<<<
 *         if isinstance(name,str):
 *             self.name=name
 */
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_6Stream_1__init__, 0, __pyx_n_s_Stream___init, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__39)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 224, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_init, __pyx_t_4) < 0) __PYX_ERR(0, 224, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":235
 *         else:
 *             raise TypeError("name shall be a string or a integer")
 *     def seekable(self):             # <<<<<<<<<<<<<<
 *         return False
 *     def readable(self):
 */
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_6Stream_3seekable, 0, __pyx_n_s_Stream_seekable, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__41)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 235, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_seekable, __pyx_t_4) < 0) __PYX_ERR(0, 235, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":237
 *     def seekable(self):
 *         return False
 *     def readable(self):             # <<<<<<<<<<<<<<
 *         return True
 *     def writeable(self):
 */
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_6Stream_5readable, 0, __pyx_n_s_Stream_readable, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__43)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 237, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_readable, __pyx_t_4) < 0) __PYX_ERR(0, 237, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":239
 *     def readable(self):
 *         return True
 *     def writeable(self):             # <<<<<<<<<<<<<<
 *         return True
 *     def fileno(self):
 */
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_6Stream_7writeable, 0, __pyx_n_s_Stream_writeable, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__45)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 239, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_writeable, __pyx_t_4) < 0) __PYX_ERR(0, 239, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":241
 *     def writeable(self):
 *         return True
 *     def fileno(self):             # <<<<<<<<<<<<<<
 *         return self.stream_num
 *     def isatty(self):
 */
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_6Stream_9fileno, 0, __pyx_n_s_Stream_fileno, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__47)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_fileno, __pyx_t_4) < 0) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":243
 *     def fileno(self):
 *         return self.stream_num
 *     def isatty(self):             # <<<<<<<<<<<<<<
 *         return False
 *     def truncate(self,size=None):
 */
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_6Stream_11isatty, 0, __pyx_n_s_Stream_isatty, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__49)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_isatty, __pyx_t_4) < 0) __PYX_ERR(0, 243, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":245
 *     def isatty(self):
 *         return False
 *     def truncate(self,size=None):             # <<<<<<<<<<<<<<
 *         raise IOError
 *     def flush(self):
 */
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_6Stream_13truncate, 0, __pyx_n_s_Stream_truncate, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__51)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 245, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_4, __pyx_tuple__52);
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_truncate, __pyx_t_4) < 0) __PYX_ERR(0, 245, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":247
 *     def truncate(self,size=None):
 *         raise IOError
 *     def flush(self):             # <<<<<<<<<<<<<<
 *         """The semantic is different from usual Stream.
 *         In this case it does nothing
 */
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_6Stream_15flush, 0, __pyx_n_s_Stream_flush, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__54)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_flush, __pyx_t_4) < 0) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":252
 *         """
 *         pass
 *     def read(self,int n=-1):             # <<<<<<<<<<<<<<
 *         """
 * 
 */
  __pyx_t_4 = __Pyx_PyInt_From_int(((int)-1)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 252, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 252, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
  __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_6Stream_17read, 0, __pyx_n_s_Stream_read, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__56)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 252, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_4, __pyx_t_5);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_read, __pyx_t_4) < 0) __PYX_ERR(0, 252, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":279
 *         libc.stdlib.free(buffer)
 *         return python_buffer
 *     def write(self,buffer):             # <<<<<<<<<<<<<<
 *         """
 *         Write a bytes object to stream.
 */
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_6Stream_19write, 0, __pyx_n_s_Stream_write, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__58)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_write, __pyx_t_4) < 0) __PYX_ERR(0, 279, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":295
 *         else:
 *             return returned_value
 *     def readall(self):             # <<<<<<<<<<<<<<
 *         """
 *         Read all available bytes equivalent to :py:func:`pyclp.read`
 */
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_6Stream_21readall, 0, __pyx_n_s_Stream_readall, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__60)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 295, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_readall, __pyx_t_4) < 0) __PYX_ERR(0, 295, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":301
 *         """
 *         return self.read(-1)
 *     def readinto(self,b):             # <<<<<<<<<<<<<<
 *         raise NotImplemented()
 * 
 */
  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5pyclp_5pyclp_6Stream_23readinto, 0, __pyx_n_s_Stream_readinto, NULL, __pyx_n_s_pyclp_pyclp, __pyx_d, ((PyObject *)__pyx_codeobj__62)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 301, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_readinto, __pyx_t_4) < 0) __PYX_ERR(0, 301, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pyclp/pyclp.pyx":204
 *         pyclp.ec_ref_set(self.ref,pr_word)
 * 
 * class Stream(io.RawIOBase):             # <<<<<<<<<<<<<<
 *     """Class to support streams to and from ECLiPSe.
 *     This is class is derived from io.RawIOBase.
 */
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_Stream, __pyx_t_1, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Stream, __pyx_t_4) < 0) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":315
 *         if prolog_ref is not None and (<Ref?>prolog_ref).ref==NULL:
 *             prolog_ref.cinit()
 * def init():             # <<<<<<<<<<<<<<
 *     """This shall be called before calling any other function.
 *     This initialize Eclipse engine.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5pyclp_5pyclp_3init, NULL, __pyx_n_s_pyclp_pyclp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 315, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_init_2, __pyx_t_1) < 0) __PYX_ERR(0, 315, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":344
 * 
 * 
 * def cleanup():             # <<<<<<<<<<<<<<
 *     """This shutdown the Eclipse engine.
 *     After calling this function any operation on pyclp object or class could crash the program.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5pyclp_5pyclp_5cleanup, NULL, __pyx_n_s_pyclp_pyclp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 344, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_cleanup, __pyx_t_1) < 0) __PYX_ERR(0, 344, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":369
 * 
 * 
 * def cut():             # <<<<<<<<<<<<<<
 *     """
 *     Cut all choice point of succeeded goal.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5pyclp_5pyclp_7cut, NULL, __pyx_n_s_pyclp_pyclp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 369, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_cut, __pyx_t_1) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":389
 * 
 * 
 * def resume(in_term=None):             # <<<<<<<<<<<<<<
 *     """
 *     Resume Eclipse engine.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5pyclp_5pyclp_9resume, NULL, __pyx_n_s_pyclp_pyclp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 389, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_resume, __pyx_t_1) < 0) __PYX_ERR(0, 389, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":474
 * 
 * 
 * def set_option(option,value):             # <<<<<<<<<<<<<<
 *     """
 *     Set options of eclipse engine. Equivalent to
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5pyclp_5pyclp_11set_option, NULL, __pyx_n_s_pyclp_pyclp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 474, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_set_option, __pyx_t_1) < 0) __PYX_ERR(0, 474, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":732
 * 
 *     """
 *     def __init__(self,in_list,tail=[]):             # <<<<<<<<<<<<<<
 *         cdef int list_lenght
 *         cdef int index
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 732, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k__19 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":1062
 * 
 * 
 * def unify(term1,term2):             # <<<<<<<<<<<<<<
 *     """
 *     Implements unify as described in
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5pyclp_5pyclp_13unify, NULL, __pyx_n_s_pyclp_pyclp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1062, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_unify, __pyx_t_1) < 0) __PYX_ERR(0, 1062, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":1093
 *         return FAIL
 * 
 * def addPythonFunction(eclipse_name,func):             # <<<<<<<<<<<<<<
 *     """
 *     Register a python function to be called from Eclipse using the predicate call_python.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5pyclp_5pyclp_15addPythonFunction, NULL, __pyx_n_s_pyclp_pyclp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1093, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_addPythonFunction, __pyx_t_1) < 0) __PYX_ERR(0, 1093, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyclp/pyclp.pyx":1
 * #Simplified BSD License             # <<<<<<<<<<<<<<
 * #Copyright (c) 2023, Oreste Bernardi
 * #All rights reserved.
 */
  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init pyclp.pyclp", __pyx_clineno, __pyx_lineno, __pyx_filename);
    }
    Py_CLEAR(__pyx_m);
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init pyclp.pyclp");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  return (__pyx_m != NULL) ? 0 : -1;
  #elif PY_MAJOR_VERSION >= 3
  return __pyx_m;
  #else
  return;
  #endif
}

/* --- Runtime support code --- */
/* Refnanny */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule(modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, "RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

/* PyObjectGetAttrStr */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#endif

/* GetBuiltinName */
static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

/* RaiseArgTupleInvalid */
static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

/* RaiseDoubleKeywords */
static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

/* ParseKeywords */
static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (__Pyx_PyUnicode_GET_LENGTH(**name) != __Pyx_PyUnicode_GET_LENGTH(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (__Pyx_PyUnicode_GET_LENGTH(**argname) != __Pyx_PyUnicode_GET_LENGTH(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

/* PyObjectSetAttrStr */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_setattro))
        return tp->tp_setattro(obj, attr_name, value);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_setattr))
        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
#endif
    return PyObject_SetAttr(obj, attr_name, value);
}
#endif

/* decode_c_string */
static CYTHON_INLINE PyObject* __Pyx_decode_c_string(
         const char* cstring, Py_ssize_t start, Py_ssize_t stop,
         const char* encoding, const char* errors,
         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
    Py_ssize_t length;
    if (unlikely((start < 0) | (stop < 0))) {
        size_t slen = strlen(cstring);
        if (unlikely(slen > (size_t) PY_SSIZE_T_MAX)) {
            PyErr_SetString(PyExc_OverflowError,
                            "c-string too long to convert to Python");
            return NULL;
        }
        length = (Py_ssize_t) slen;
        if (start < 0) {
            start += length;
            if (start < 0)
                start = 0;
        }
        if (stop < 0)
            stop += length;
    }
    if (unlikely(stop <= start))
        return __Pyx_NewRef(__pyx_empty_unicode);
    length = stop - start;
    cstring += start;
    if (decode_func) {
        return decode_func(cstring, length, errors);
    } else {
        return PyUnicode_Decode(cstring, length, encoding, errors);
    }
}

/* PyCFunctionFastCall */
#if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
    PyObject *self = PyCFunction_GET_SELF(func);
    int flags = PyCFunction_GET_FLAGS(func);
    assert(PyCFunction_Check(func));
    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)));
    assert(nargs >= 0);
    assert(nargs == 0 || args != NULL);
    /* _PyCFunction_FastCallDict() must not be called with an exception set,
       because it may clear it (directly or indirectly) and so the
       caller loses its exception */
    assert(!PyErr_Occurred());
    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
        return (*((__Pyx_PyCFunctionFastWithKeywords)(void*)meth)) (self, args, nargs, NULL);
    } else {
        return (*((__Pyx_PyCFunctionFast)(void*)meth)) (self, args, nargs);
    }
}
#endif

/* PyFunctionFastCall */
#if CYTHON_FAST_PYCALL
static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
                                               PyObject *globals) {
    PyFrameObject *f;
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    PyObject **fastlocals;
    Py_ssize_t i;
    PyObject *result;
    assert(globals != NULL);
    /* XXX Perhaps we should create a specialized
       PyFrame_New() that doesn't take locals, but does
       take builtins without sanity checking them.
       */
    assert(tstate != NULL);
    f = PyFrame_New(tstate, co, globals, NULL);
    if (f == NULL) {
        return NULL;
    }
    fastlocals = __Pyx_PyFrame_GetLocalsplus(f);
    for (i = 0; i < na; i++) {
        Py_INCREF(*args);
        fastlocals[i] = *args++;
    }
    result = PyEval_EvalFrameEx(f,0);
    ++tstate->recursion_depth;
    Py_DECREF(f);
    --tstate->recursion_depth;
    return result;
}
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs) {
    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
    PyObject *globals = PyFunction_GET_GLOBALS(func);
    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
    PyObject *closure;
#if PY_MAJOR_VERSION >= 3
    PyObject *kwdefs;
#endif
    PyObject *kwtuple, **k;
    PyObject **d;
    Py_ssize_t nd;
    Py_ssize_t nk;
    PyObject *result;
    assert(kwargs == NULL || PyDict_Check(kwargs));
    nk = kwargs ? PyDict_Size(kwargs) : 0;
    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
        return NULL;
    }
    if (
#if PY_MAJOR_VERSION >= 3
            co->co_kwonlyargcount == 0 &&
#endif
            likely(kwargs == NULL || nk == 0) &&
            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
        if (argdefs == NULL && co->co_argcount == nargs) {
            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
            goto done;
        }
        else if (nargs == 0 && argdefs != NULL
                 && co->co_argcount == Py_SIZE(argdefs)) {
            /* function called with no arguments, but all parameters have
               a default value: use default values as arguments .*/
            args = &PyTuple_GET_ITEM(argdefs, 0);
            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
            goto done;
        }
    }
    if (kwargs != NULL) {
        Py_ssize_t pos, i;
        kwtuple = PyTuple_New(2 * nk);
        if (kwtuple == NULL) {
            result = NULL;
            goto done;
        }
        k = &PyTuple_GET_ITEM(kwtuple, 0);
        pos = i = 0;
        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
            Py_INCREF(k[i]);
            Py_INCREF(k[i+1]);
            i += 2;
        }
        nk = i / 2;
    }
    else {
        kwtuple = NULL;
        k = NULL;
    }
    closure = PyFunction_GET_CLOSURE(func);
#if PY_MAJOR_VERSION >= 3
    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
#endif
    if (argdefs != NULL) {
        d = &PyTuple_GET_ITEM(argdefs, 0);
        nd = Py_SIZE(argdefs);
    }
    else {
        d = NULL;
        nd = 0;
    }
#if PY_MAJOR_VERSION >= 3
    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
                               args, (int)nargs,
                               k, (int)nk,
                               d, (int)nd, kwdefs, closure);
#else
    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
                               args, (int)nargs,
                               k, (int)nk,
                               d, (int)nd, closure);
#endif
    Py_XDECREF(kwtuple);
done:
    Py_LeaveRecursiveCall();
    return result;
}
#endif
#endif

/* PyObjectCall */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = Py_TYPE(func)->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCall2Args */
static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
    PyObject *args, *result = NULL;
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(function)) {
        PyObject *args[2] = {arg1, arg2};
        return __Pyx_PyFunction_FastCall(function, args, 2);
    }
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(function)) {
        PyObject *args[2] = {arg1, arg2};
        return __Pyx_PyCFunction_FastCall(function, args, 2);
    }
    #endif
    args = PyTuple_New(2);
    if (unlikely(!args)) goto done;
    Py_INCREF(arg1);
    PyTuple_SET_ITEM(args, 0, arg1);
    Py_INCREF(arg2);
    PyTuple_SET_ITEM(args, 1, arg2);
    Py_INCREF(function);
    result = __Pyx_PyObject_Call(function, args, NULL);
    Py_DECREF(args);
    Py_DECREF(function);
done:
    return result;
}

/* PyObjectCallMethO */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCallOneArg */
#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, &arg, 1);
    }
#endif
    if (likely(PyCFunction_Check(func))) {
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
#if CYTHON_FAST_PYCCALL
        } else if (__Pyx_PyFastCFunction_Check(func)) {
            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
#endif
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_Pack(1, arg);
    if (unlikely(!args)) return NULL;
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
#endif

/* PyErrFetchRestore */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}
#endif

/* RaiseException */
#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    __Pyx_PyThreadState_declare
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    if (PyType_Check(type)) {
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
    }
    __Pyx_PyThreadState_assign
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                int is_subclass = PyObject_IsSubclass(instance_class, type);
                if (!is_subclass) {
                    instance_class = NULL;
                } else if (unlikely(is_subclass == -1)) {
                    goto bad;
                } else {
                    type = instance_class;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
    if (cause) {
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
#if CYTHON_FAST_THREAD_STATE
        PyThreadState *tstate = __Pyx_PyThreadState_Current;
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
#else
        PyObject *tmp_type, *tmp_value, *tmp_tb;
        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
        Py_INCREF(tb);
        PyErr_Restore(tmp_type, tmp_value, tb);
        Py_XDECREF(tmp_tb);
#endif
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

/* PyObjectCallNoArg */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, NULL, 0);
    }
#endif
#if defined(__Pyx_CyFunction_USED) && defined(NDEBUG)
    if (likely(PyCFunction_Check(func) || __Pyx_CyFunction_Check(func)))
#else
    if (likely(PyCFunction_Check(func)))
#endif
    {
        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
            return __Pyx_PyObject_CallMethO(func, NULL);
        }
    }
    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
}
#endif

/* PyDictVersioning */
#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
    PyObject *dict = Py_TYPE(obj)->tp_dict;
    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
}
static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
    PyObject **dictptr = NULL;
    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
    if (offset) {
#if CYTHON_COMPILING_IN_CPYTHON
        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
#else
        dictptr = _PyObject_GetDictPtr(obj);
#endif
    }
    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
}
static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
    PyObject *dict = Py_TYPE(obj)->tp_dict;
    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
        return 0;
    return obj_dict_version == __Pyx_get_object_dict_version(obj);
}
#endif

/* GetModuleGlobalName */
#if CYTHON_USE_DICT_VERSIONS
static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
#else
static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
#endif
{
    PyObject *result;
#if !CYTHON_AVOID_BORROWED_REFS
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    } else if (unlikely(PyErr_Occurred())) {
        return NULL;
    }
#else
    result = PyDict_GetItem(__pyx_d, name);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    }
#endif
#else
    result = PyObject_GetItem(__pyx_d, name);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    }
    PyErr_Clear();
#endif
    return __Pyx_GetBuiltinName(name);
}

/* GetItemInt */
static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
    PyObject *r;
    if (!j) return NULL;
    r = PyObject_GetItem(o, j);
    Py_DECREF(j);
    return r;
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    Py_ssize_t wrapped_i = i;
    if (wraparound & unlikely(i < 0)) {
        wrapped_i += PyList_GET_SIZE(o);
    }
    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyList_GET_SIZE(o)))) {
        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    Py_ssize_t wrapped_i = i;
    if (wraparound & unlikely(i < 0)) {
        wrapped_i += PyTuple_GET_SIZE(o);
    }
    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyTuple_GET_SIZE(o)))) {
        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
                                                     CYTHON_NCP_UNUSED int wraparound,
                                                     CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
    if (is_list || PyList_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
        if ((!boundscheck) || (likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o))))) {
            PyObject *r = PyList_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    }
    else if (PyTuple_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
            PyObject *r = PyTuple_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    } else {
        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
        if (likely(m && m->sq_item)) {
            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
                Py_ssize_t l = m->sq_length(o);
                if (likely(l >= 0)) {
                    i += l;
                } else {
                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
                        return NULL;
                    PyErr_Clear();
                }
            }
            return m->sq_item(o, i);
        }
    }
#else
    if (is_list || PySequence_Check(o)) {
        return PySequence_GetItem(o, i);
    }
#endif
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
}

/* ObjectGetItem */
#if CYTHON_USE_TYPE_SLOTS
static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject* index) {
    PyObject *runerr = NULL;
    Py_ssize_t key_value;
    PySequenceMethods *m = Py_TYPE(obj)->tp_as_sequence;
    if (unlikely(!(m && m->sq_item))) {
        PyErr_Format(PyExc_TypeError, "'%.200s' object is not subscriptable", Py_TYPE(obj)->tp_name);
        return NULL;
    }
    key_value = __Pyx_PyIndex_AsSsize_t(index);
    if (likely(key_value != -1 || !(runerr = PyErr_Occurred()))) {
        return __Pyx_GetItemInt_Fast(obj, key_value, 0, 1, 1);
    }
    if (PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError)) {
        PyErr_Clear();
        PyErr_Format(PyExc_IndexError, "cannot fit '%.200s' into an index-sized integer", Py_TYPE(index)->tp_name);
    }
    return NULL;
}
static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key) {
    PyMappingMethods *m = Py_TYPE(obj)->tp_as_mapping;
    if (likely(m && m->mp_subscript)) {
        return m->mp_subscript(obj, key);
    }
    return __Pyx_PyObject_GetIndex(obj, key);
}
#endif

/* GetTopmostException */
#if CYTHON_USE_EXC_INFO_STACK
static _PyErr_StackItem *
__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
{
    _PyErr_StackItem *exc_info = tstate->exc_info;
    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
           exc_info->previous_item != NULL)
    {
        exc_info = exc_info->previous_item;
    }
    return exc_info;
}
#endif

/* SaveResetException */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    #if CYTHON_USE_EXC_INFO_STACK
    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
    *type = exc_info->exc_type;
    *value = exc_info->exc_value;
    *tb = exc_info->exc_traceback;
    #else
    *type = tstate->exc_type;
    *value = tstate->exc_value;
    *tb = tstate->exc_traceback;
    #endif
    Py_XINCREF(*type);
    Py_XINCREF(*value);
    Py_XINCREF(*tb);
}
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    #if CYTHON_USE_EXC_INFO_STACK
    _PyErr_StackItem *exc_info = tstate->exc_info;
    tmp_type = exc_info->exc_type;
    tmp_value = exc_info->exc_value;
    tmp_tb = exc_info->exc_traceback;
    exc_info->exc_type = type;
    exc_info->exc_value = value;
    exc_info->exc_traceback = tb;
    #else
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = type;
    tstate->exc_value = value;
    tstate->exc_traceback = tb;
    #endif
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
#endif

/* PyErrExceptionMatches */
#if CYTHON_FAST_THREAD_STATE
static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
    Py_ssize_t i, n;
    n = PyTuple_GET_SIZE(tuple);
#if PY_MAJOR_VERSION >= 3
    for (i=0; i<n; i++) {
        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
    }
#endif
    for (i=0; i<n; i++) {
        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
    }
    return 0;
}
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
    PyObject *exc_type = tstate->curexc_type;
    if (exc_type == err) return 1;
    if (unlikely(!exc_type)) return 0;
    if (unlikely(PyTuple_Check(err)))
        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
}
#endif

/* GetException */
#if CYTHON_FAST_THREAD_STATE
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
#endif
{
    PyObject *local_type, *local_value, *local_tb;
#if CYTHON_FAST_THREAD_STATE
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    local_type = tstate->curexc_type;
    local_value = tstate->curexc_value;
    local_tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(&local_type, &local_value, &local_tb);
#endif
    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
#if CYTHON_FAST_THREAD_STATE
    if (unlikely(tstate->curexc_type))
#else
    if (unlikely(PyErr_Occurred()))
#endif
        goto bad;
    #if PY_MAJOR_VERSION >= 3
    if (local_tb) {
        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
            goto bad;
    }
    #endif
    Py_XINCREF(local_tb);
    Py_XINCREF(local_type);
    Py_XINCREF(local_value);
    *type = local_type;
    *value = local_value;
    *tb = local_tb;
#if CYTHON_FAST_THREAD_STATE
    #if CYTHON_USE_EXC_INFO_STACK
    {
        _PyErr_StackItem *exc_info = tstate->exc_info;
        tmp_type = exc_info->exc_type;
        tmp_value = exc_info->exc_value;
        tmp_tb = exc_info->exc_traceback;
        exc_info->exc_type = local_type;
        exc_info->exc_value = local_value;
        exc_info->exc_traceback = local_tb;
    }
    #else
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = local_type;
    tstate->exc_value = local_value;
    tstate->exc_traceback = local_tb;
    #endif
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(local_type, local_value, local_tb);
#endif
    return 0;
bad:
    *type = 0;
    *value = 0;
    *tb = 0;
    Py_XDECREF(local_type);
    Py_XDECREF(local_value);
    Py_XDECREF(local_tb);
    return -1;
}

/* WriteUnraisableException */
static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
                                  int full_traceback, CYTHON_UNUSED int nogil) {
    PyObject *old_exc, *old_val, *old_tb;
    PyObject *ctx;
    __Pyx_PyThreadState_declare
#ifdef WITH_THREAD
    PyGILState_STATE state;
    if (nogil)
        state = PyGILState_Ensure();
    else state = (PyGILState_STATE)0;
#endif
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
    if (full_traceback) {
        Py_XINCREF(old_exc);
        Py_XINCREF(old_val);
        Py_XINCREF(old_tb);
        __Pyx_ErrRestore(old_exc, old_val, old_tb);
        PyErr_PrintEx(1);
    }
    #if PY_MAJOR_VERSION < 3
    ctx = PyString_FromString(name);
    #else
    ctx = PyUnicode_FromString(name);
    #endif
    __Pyx_ErrRestore(old_exc, old_val, old_tb);
    if (!ctx) {
        PyErr_WriteUnraisable(Py_None);
    } else {
        PyErr_WriteUnraisable(ctx);
        Py_DECREF(ctx);
    }
#ifdef WITH_THREAD
    if (nogil)
        PyGILState_Release(state);
#endif
}

/* StringJoin */
#if !CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyBytes_Join(PyObject* sep, PyObject* values) {
    return PyObject_CallMethodObjArgs(sep, __pyx_n_s_join, values, NULL);
}
#endif

/* KeywordStringCheck */
static int __Pyx_CheckKeywordStrings(
    PyObject *kwdict,
    const char* function_name,
    int kw_allowed)
{
    PyObject* key = 0;
    Py_ssize_t pos = 0;
#if CYTHON_COMPILING_IN_PYPY
    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
        goto invalid_keyword;
    return 1;
#else
    while (PyDict_Next(kwdict, &pos, &key, 0)) {
        #if PY_MAJOR_VERSION < 3
        if (unlikely(!PyString_Check(key)))
        #endif
            if (unlikely(!PyUnicode_Check(key)))
                goto invalid_keyword_type;
    }
    if ((!kw_allowed) && unlikely(key))
        goto invalid_keyword;
    return 1;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    return 0;
#endif
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
    return 0;
}

/* ExtTypeTest */
static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(__Pyx_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

/* PyIntCompare */
static CYTHON_INLINE PyObject* __Pyx_PyInt_EqObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED long inplace) {
    if (op1 == op2) {
        Py_RETURN_TRUE;
    }
    #if PY_MAJOR_VERSION < 3
    if (likely(PyInt_CheckExact(op1))) {
        const long b = intval;
        long a = PyInt_AS_LONG(op1);
        if (a == b) Py_RETURN_TRUE; else Py_RETURN_FALSE;
    }
    #endif
    #if CYTHON_USE_PYLONG_INTERNALS
    if (likely(PyLong_CheckExact(op1))) {
        int unequal;
        unsigned long uintval;
        Py_ssize_t size = Py_SIZE(op1);
        const digit* digits = ((PyLongObject*)op1)->ob_digit;
        if (intval == 0) {
            if (size == 0) Py_RETURN_TRUE; else Py_RETURN_FALSE;
        } else if (intval < 0) {
            if (size >= 0)
                Py_RETURN_FALSE;
            intval = -intval;
            size = -size;
        } else {
            if (size <= 0)
                Py_RETURN_FALSE;
        }
        uintval = (unsigned long) intval;
#if PyLong_SHIFT * 4 < SIZEOF_LONG*8
        if (uintval >> (PyLong_SHIFT * 4)) {
            unequal = (size != 5) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[3] != ((uintval >> (3 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[4] != ((uintval >> (4 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
        } else
#endif
#if PyLong_SHIFT * 3 < SIZEOF_LONG*8
        if (uintval >> (PyLong_SHIFT * 3)) {
            unequal = (size != 4) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[3] != ((uintval >> (3 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
        } else
#endif
#if PyLong_SHIFT * 2 < SIZEOF_LONG*8
        if (uintval >> (PyLong_SHIFT * 2)) {
            unequal = (size != 3) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
        } else
#endif
#if PyLong_SHIFT * 1 < SIZEOF_LONG*8
        if (uintval >> (PyLong_SHIFT * 1)) {
            unequal = (size != 2) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
        } else
#endif
            unequal = (size != 1) || (((unsigned long) digits[0]) != (uintval & (unsigned long) PyLong_MASK));
        if (unequal == 0) Py_RETURN_TRUE; else Py_RETURN_FALSE;
    }
    #endif
    if (PyFloat_CheckExact(op1)) {
        const long b = intval;
        double a = PyFloat_AS_DOUBLE(op1);
        if ((double)a == (double)b) Py_RETURN_TRUE; else Py_RETURN_FALSE;
    }
    return (
        PyObject_RichCompare(op1, op2, Py_EQ));
}

/* ModInt[int] */
static CYTHON_INLINE int __Pyx_mod_int(int a, int b) {
    int r = a % b;
    r += ((r != 0) & ((r ^ b) < 0)) * b;
    return r;
}

/* ModInt[long] */
static CYTHON_INLINE long __Pyx_mod_long(long a, long b) {
    long r = a % b;
    r += ((r != 0) & ((r ^ b) < 0)) * b;
    return r;
}

/* SwapException */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    #if CYTHON_USE_EXC_INFO_STACK
    _PyErr_StackItem *exc_info = tstate->exc_info;
    tmp_type = exc_info->exc_type;
    tmp_value = exc_info->exc_value;
    tmp_tb = exc_info->exc_traceback;
    exc_info->exc_type = *type;
    exc_info->exc_value = *value;
    exc_info->exc_traceback = *tb;
    #else
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = *type;
    tstate->exc_value = *value;
    tstate->exc_traceback = *tb;
    #endif
    *type = tmp_type;
    *value = tmp_value;
    *tb = tmp_tb;
}
#else
static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyErr_GetExcInfo(&tmp_type, &tmp_value, &tmp_tb);
    PyErr_SetExcInfo(*type, *value, *tb);
    *type = tmp_type;
    *value = tmp_value;
    *tb = tmp_tb;
}
#endif

/* None */
static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
    PyErr_Format(PyExc_UnboundLocalError, "local variable '%s' referenced before assignment", varname);
}

/* RaiseTooManyValuesToUnpack */
static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
    PyErr_Format(PyExc_ValueError,
                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
}

/* RaiseNeedMoreValuesToUnpack */
static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
    PyErr_Format(PyExc_ValueError,
                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
                 index, (index == 1) ? "" : "s");
}

/* IterFinish */
static CYTHON_INLINE int __Pyx_IterFinish(void) {
#if CYTHON_FAST_THREAD_STATE
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    PyObject* exc_type = tstate->curexc_type;
    if (unlikely(exc_type)) {
        if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) {
            PyObject *exc_value, *exc_tb;
            exc_value = tstate->curexc_value;
            exc_tb = tstate->curexc_traceback;
            tstate->curexc_type = 0;
            tstate->curexc_value = 0;
            tstate->curexc_traceback = 0;
            Py_DECREF(exc_type);
            Py_XDECREF(exc_value);
            Py_XDECREF(exc_tb);
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#else
    if (unlikely(PyErr_Occurred())) {
        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
            PyErr_Clear();
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#endif
}

/* UnpackItemEndCheck */
static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
    if (unlikely(retval)) {
        Py_DECREF(retval);
        __Pyx_RaiseTooManyValuesError(expected);
        return -1;
    }
    return __Pyx_IterFinish();
}

/* SetItemInt */
static int __Pyx_SetItemInt_Generic(PyObject *o, PyObject *j, PyObject *v) {
    int r;
    if (!j) return -1;
    r = PyObject_SetItem(o, j, v);
    Py_DECREF(j);
    return r;
}
static CYTHON_INLINE int __Pyx_SetItemInt_Fast(PyObject *o, Py_ssize_t i, PyObject *v, int is_list,
                                               CYTHON_NCP_UNUSED int wraparound, CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
    if (is_list || PyList_CheckExact(o)) {
        Py_ssize_t n = (!wraparound) ? i : ((likely(i >= 0)) ? i : i + PyList_GET_SIZE(o));
        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o)))) {
            PyObject* old = PyList_GET_ITEM(o, n);
            Py_INCREF(v);
            PyList_SET_ITEM(o, n, v);
            Py_DECREF(old);
            return 1;
        }
    } else {
        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
        if (likely(m && m->sq_ass_item)) {
            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
                Py_ssize_t l = m->sq_length(o);
                if (likely(l >= 0)) {
                    i += l;
                } else {
                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
                        return -1;
                    PyErr_Clear();
                }
            }
            return m->sq_ass_item(o, i, v);
        }
    }
#else
#if CYTHON_COMPILING_IN_PYPY
    if (is_list || (PySequence_Check(o) && !PyDict_Check(o)))
#else
    if (is_list || PySequence_Check(o))
#endif
    {
        return PySequence_SetItem(o, i, v);
    }
#endif
    return __Pyx_SetItemInt_Generic(o, PyInt_FromSsize_t(i), v);
}

/* PyObject_GenericGetAttrNoDict */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
    PyErr_Format(PyExc_AttributeError,
#if PY_MAJOR_VERSION >= 3
                 "'%.50s' object has no attribute '%U'",
                 tp->tp_name, attr_name);
#else
                 "'%.50s' object has no attribute '%.400s'",
                 tp->tp_name, PyString_AS_STRING(attr_name));
#endif
    return NULL;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name) {
    PyObject *descr;
    PyTypeObject *tp = Py_TYPE(obj);
    if (unlikely(!PyString_Check(attr_name))) {
        return PyObject_GenericGetAttr(obj, attr_name);
    }
    assert(!tp->tp_dictoffset);
    descr = _PyType_Lookup(tp, attr_name);
    if (unlikely(!descr)) {
        return __Pyx_RaiseGenericGetAttributeError(tp, attr_name);
    }
    Py_INCREF(descr);
    #if PY_MAJOR_VERSION < 3
    if (likely(PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_HAVE_CLASS)))
    #endif
    {
        descrgetfunc f = Py_TYPE(descr)->tp_descr_get;
        if (unlikely(f)) {
            PyObject *res = f(descr, obj, (PyObject *)tp);
            Py_DECREF(descr);
            return res;
        }
    }
    return descr;
}
#endif

/* PyObject_GenericGetAttr */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name) {
    if (unlikely(Py_TYPE(obj)->tp_dictoffset)) {
        return PyObject_GenericGetAttr(obj, attr_name);
    }
    return __Pyx_PyObject_GenericGetAttrNoDict(obj, attr_name);
}
#endif

/* SetVTable */
static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
#if PY_VERSION_HEX >= 0x02070000
    PyObject *ob = PyCapsule_New(vtable, 0, 0);
#else
    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
#endif
    if (!ob)
        goto bad;
    if (PyDict_SetItem(dict, __pyx_n_s_pyx_vtable, ob) < 0)
        goto bad;
    Py_DECREF(ob);
    return 0;
bad:
    Py_XDECREF(ob);
    return -1;
}

/* PyObjectGetAttrStrNoError */
static void __Pyx_PyObject_GetAttrStr_ClearAttributeError(void) {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    if (likely(__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
        __Pyx_PyErr_Clear();
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name) {
    PyObject *result;
#if CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_TYPE_SLOTS && PY_VERSION_HEX >= 0x030700B1
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro == PyObject_GenericGetAttr)) {
        return _PyObject_GenericGetAttrWithDict(obj, attr_name, NULL, 1);
    }
#endif
    result = __Pyx_PyObject_GetAttrStr(obj, attr_name);
    if (unlikely(!result)) {
        __Pyx_PyObject_GetAttrStr_ClearAttributeError();
    }
    return result;
}

/* SetupReduce */
static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
  int ret;
  PyObject *name_attr;
  name_attr = __Pyx_PyObject_GetAttrStr(meth, __pyx_n_s_name_2);
  if (likely(name_attr)) {
      ret = PyObject_RichCompareBool(name_attr, name, Py_EQ);
  } else {
      ret = -1;
  }
  if (unlikely(ret < 0)) {
      PyErr_Clear();
      ret = 0;
  }
  Py_XDECREF(name_attr);
  return ret;
}
static int __Pyx_setup_reduce(PyObject* type_obj) {
    int ret = 0;
    PyObject *object_reduce = NULL;
    PyObject *object_getstate = NULL;
    PyObject *object_reduce_ex = NULL;
    PyObject *reduce = NULL;
    PyObject *reduce_ex = NULL;
    PyObject *reduce_cython = NULL;
    PyObject *setstate = NULL;
    PyObject *setstate_cython = NULL;
    PyObject *getstate = NULL;
#if CYTHON_USE_PYTYPE_LOOKUP
    getstate = _PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate);
#else
    getstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_getstate);
    if (!getstate && PyErr_Occurred()) {
        goto __PYX_BAD;
    }
#endif
    if (getstate) {
#if CYTHON_USE_PYTYPE_LOOKUP
        object_getstate = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_getstate);
#else
        object_getstate = __Pyx_PyObject_GetAttrStrNoError((PyObject*)&PyBaseObject_Type, __pyx_n_s_getstate);
        if (!object_getstate && PyErr_Occurred()) {
            goto __PYX_BAD;
        }
#endif
        if (object_getstate != getstate) {
            goto __PYX_GOOD;
        }
    }
#if CYTHON_USE_PYTYPE_LOOKUP
    object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
#else
    object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
#endif
    reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto __PYX_BAD;
    if (reduce_ex == object_reduce_ex) {
#if CYTHON_USE_PYTYPE_LOOKUP
        object_reduce = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto __PYX_BAD;
#else
        object_reduce = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto __PYX_BAD;
#endif
        reduce = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce); if (unlikely(!reduce)) goto __PYX_BAD;
        if (reduce == object_reduce || __Pyx_setup_reduce_is_named(reduce, __pyx_n_s_reduce_cython)) {
            reduce_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_reduce_cython);
            if (likely(reduce_cython)) {
                ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce, reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
                ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
            } else if (reduce == object_reduce || PyErr_Occurred()) {
                goto __PYX_BAD;
            }
            setstate = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_setstate);
            if (!setstate) PyErr_Clear();
            if (!setstate || __Pyx_setup_reduce_is_named(setstate, __pyx_n_s_setstate_cython)) {
                setstate_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_setstate_cython);
                if (likely(setstate_cython)) {
                    ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate, setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
                    ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
                } else if (!setstate || PyErr_Occurred()) {
                    goto __PYX_BAD;
                }
            }
            PyType_Modified((PyTypeObject*)type_obj);
        }
    }
    goto __PYX_GOOD;
__PYX_BAD:
    if (!PyErr_Occurred())
        PyErr_Format(PyExc_RuntimeError, "Unable to initialize pickling for %s", ((PyTypeObject*)type_obj)->tp_name);
    ret = -1;
__PYX_GOOD:
#if !CYTHON_USE_PYTYPE_LOOKUP
    Py_XDECREF(object_reduce);
    Py_XDECREF(object_reduce_ex);
    Py_XDECREF(object_getstate);
    Py_XDECREF(getstate);
#endif
    Py_XDECREF(reduce);
    Py_XDECREF(reduce_ex);
    Py_XDECREF(reduce_cython);
    Py_XDECREF(setstate);
    Py_XDECREF(setstate_cython);
    return ret;
}

/* TypeImport */
#ifndef __PYX_HAVE_RT_ImportType
#define __PYX_HAVE_RT_ImportType
static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize check_size)
{
    PyObject *result = 0;
    char warning[200];
    Py_ssize_t basicsize;
    Py_ssize_t itemsize;
#ifdef Py_LIMITED_API
    PyObject *py_basicsize;
    PyObject *py_itemsize;
#endif
    result = PyObject_GetAttrString(module, class_name);
    if (!result)
        goto bad;
    if (!PyType_Check(result)) {
        PyErr_Format(PyExc_TypeError,
            "%.200s.%.200s is not a type object",
            module_name, class_name);
        goto bad;
    }
#ifndef Py_LIMITED_API
    basicsize = ((PyTypeObject *)result)->tp_basicsize;
    itemsize = ((PyTypeObject *)result)->tp_itemsize;
#else
    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
    if (!py_basicsize)
        goto bad;
    basicsize = PyLong_AsSsize_t(py_basicsize);
    Py_DECREF(py_basicsize);
    py_basicsize = 0;
    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
        goto bad;
    py_itemsize = PyObject_GetAttrString(result, "__itemsize__");
    if (!py_itemsize)
        goto bad;
    itemsize = PyLong_AsSsize_t(py_itemsize);
    Py_DECREF(py_itemsize);
    py_itemsize = 0;
    if (itemsize == (Py_ssize_t)-1 && PyErr_Occurred())
        goto bad;
#endif
    if (itemsize) {
        if (size % alignment) {
            alignment = size % alignment;
        }
        if (itemsize < (Py_ssize_t)alignment)
            itemsize = (Py_ssize_t)alignment;
    }
    if ((size_t)(basicsize + itemsize) < size) {
        PyErr_Format(PyExc_ValueError,
            "%.200s.%.200s size changed, may indicate binary incompatibility. "
            "Expected %zd from C header, got %zd from PyObject",
            module_name, class_name, size, basicsize);
        goto bad;
    }
    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
        PyErr_Format(PyExc_ValueError,
            "%.200s.%.200s size changed, may indicate binary incompatibility. "
            "Expected %zd from C header, got %zd from PyObject",
            module_name, class_name, size, basicsize);
        goto bad;
    }
    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
        PyOS_snprintf(warning, sizeof(warning),
            "%s.%s size changed, may indicate binary incompatibility. "
            "Expected %zd from C header, got %zd from PyObject",
            module_name, class_name, size, basicsize);
        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
    }
    return (PyTypeObject *)result;
bad:
    Py_XDECREF(result);
    return NULL;
}
#endif

/* Import */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_MAJOR_VERSION < 3
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if ((1) && (strchr(__Pyx_MODULE_NAME, '.'))) {
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_MAJOR_VERSION < 3
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, (PyObject *)NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

/* CalculateMetaclass */
static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases) {
    Py_ssize_t i, nbases = PyTuple_GET_SIZE(bases);
    for (i=0; i < nbases; i++) {
        PyTypeObject *tmptype;
        PyObject *tmp = PyTuple_GET_ITEM(bases, i);
        tmptype = Py_TYPE(tmp);
#if PY_MAJOR_VERSION < 3
        if (tmptype == &PyClass_Type)
            continue;
#endif
        if (!metaclass) {
            metaclass = tmptype;
            continue;
        }
        if (PyType_IsSubtype(metaclass, tmptype))
            continue;
        if (PyType_IsSubtype(tmptype, metaclass)) {
            metaclass = tmptype;
            continue;
        }
        PyErr_SetString(PyExc_TypeError,
                        "metaclass conflict: "
                        "the metaclass of a derived class "
                        "must be a (non-strict) subclass "
                        "of the metaclasses of all its bases");
        return NULL;
    }
    if (!metaclass) {
#if PY_MAJOR_VERSION < 3
        metaclass = &PyClass_Type;
#else
        metaclass = &PyType_Type;
#endif
    }
    Py_INCREF((PyObject*) metaclass);
    return (PyObject*) metaclass;
}

/* FetchCommonType */
static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
    PyObject* fake_module;
    PyTypeObject* cached_type = NULL;
    fake_module = PyImport_AddModule((char*) "_cython_" CYTHON_ABI);
    if (!fake_module) return NULL;
    Py_INCREF(fake_module);
    cached_type = (PyTypeObject*) PyObject_GetAttrString(fake_module, type->tp_name);
    if (cached_type) {
        if (!PyType_Check((PyObject*)cached_type)) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s is not a type object",
                type->tp_name);
            goto bad;
        }
        if (cached_type->tp_basicsize != type->tp_basicsize) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s has the wrong size, try recompiling",
                type->tp_name);
            goto bad;
        }
    } else {
        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
        PyErr_Clear();
        if (PyType_Ready(type) < 0) goto bad;
        if (PyObject_SetAttrString(fake_module, type->tp_name, (PyObject*) type) < 0)
            goto bad;
        Py_INCREF(type);
        cached_type = type;
    }
done:
    Py_DECREF(fake_module);
    return cached_type;
bad:
    Py_XDECREF(cached_type);
    cached_type = NULL;
    goto done;
}

/* CythonFunctionShared */
#include <structmember.h>
static PyObject *
__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *closure)
{
    if (unlikely(op->func_doc == NULL)) {
        if (op->func.m_ml->ml_doc) {
#if PY_MAJOR_VERSION >= 3
            op->func_doc = PyUnicode_FromString(op->func.m_ml->ml_doc);
#else
            op->func_doc = PyString_FromString(op->func.m_ml->ml_doc);
#endif
            if (unlikely(op->func_doc == NULL))
                return NULL;
        } else {
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    Py_INCREF(op->func_doc);
    return op->func_doc;
}
static int
__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
{
    PyObject *tmp = op->func_doc;
    if (value == NULL) {
        value = Py_None;
    }
    Py_INCREF(value);
    op->func_doc = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
{
    if (unlikely(op->func_name == NULL)) {
#if PY_MAJOR_VERSION >= 3
        op->func_name = PyUnicode_InternFromString(op->func.m_ml->ml_name);
#else
        op->func_name = PyString_InternFromString(op->func.m_ml->ml_name);
#endif
        if (unlikely(op->func_name == NULL))
            return NULL;
    }
    Py_INCREF(op->func_name);
    return op->func_name;
}
static int
__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value)))
#else
    if (unlikely(value == NULL || !PyString_Check(value)))
#endif
    {
        PyErr_SetString(PyExc_TypeError,
                        "__name__ must be set to a string object");
        return -1;
    }
    tmp = op->func_name;
    Py_INCREF(value);
    op->func_name = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
{
    Py_INCREF(op->func_qualname);
    return op->func_qualname;
}
static int
__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value)))
#else
    if (unlikely(value == NULL || !PyString_Check(value)))
#endif
    {
        PyErr_SetString(PyExc_TypeError,
                        "__qualname__ must be set to a string object");
        return -1;
    }
    tmp = op->func_qualname;
    Py_INCREF(value);
    op->func_qualname = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_self(__pyx_CyFunctionObject *m, CYTHON_UNUSED void *closure)
{
    PyObject *self;
    self = m->func_closure;
    if (self == NULL)
        self = Py_None;
    Py_INCREF(self);
    return self;
}
static PyObject *
__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
{
    if (unlikely(op->func_dict == NULL)) {
        op->func_dict = PyDict_New();
        if (unlikely(op->func_dict == NULL))
            return NULL;
    }
    Py_INCREF(op->func_dict);
    return op->func_dict;
}
static int
__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
{
    PyObject *tmp;
    if (unlikely(value == NULL)) {
        PyErr_SetString(PyExc_TypeError,
               "function's dictionary may not be deleted");
        return -1;
    }
    if (unlikely(!PyDict_Check(value))) {
        PyErr_SetString(PyExc_TypeError,
               "setting function's dictionary to a non-dict");
        return -1;
    }
    tmp = op->func_dict;
    Py_INCREF(value);
    op->func_dict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
{
    Py_INCREF(op->func_globals);
    return op->func_globals;
}
static PyObject *
__Pyx_CyFunction_get_closure(CYTHON_UNUSED __pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
{
    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
{
    PyObject* result = (op->func_code) ? op->func_code : Py_None;
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
    int result = 0;
    PyObject *res = op->defaults_getter((PyObject *) op);
    if (unlikely(!res))
        return -1;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
    Py_INCREF(op->defaults_tuple);
    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
    Py_INCREF(op->defaults_kwdict);
    #else
    op->defaults_tuple = PySequence_ITEM(res, 0);
    if (unlikely(!op->defaults_tuple)) result = -1;
    else {
        op->defaults_kwdict = PySequence_ITEM(res, 1);
        if (unlikely(!op->defaults_kwdict)) result = -1;
    }
    #endif
    Py_DECREF(res);
    return result;
}
static int
__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyTuple_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__defaults__ must be set to a tuple object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_tuple;
    op->defaults_tuple = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
    PyObject* result = op->defaults_tuple;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_tuple;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__kwdefaults__ must be set to a dict object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_kwdict;
    op->defaults_kwdict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
    PyObject* result = op->defaults_kwdict;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_kwdict;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
    PyObject* tmp;
    if (!value || value == Py_None) {
        value = NULL;
    } else if (!PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__annotations__ must be set to a dict object");
        return -1;
    }
    Py_XINCREF(value);
    tmp = op->func_annotations;
    op->func_annotations = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
    PyObject* result = op->func_annotations;
    if (unlikely(!result)) {
        result = PyDict_New();
        if (unlikely(!result)) return NULL;
        op->func_annotations = result;
    }
    Py_INCREF(result);
    return result;
}
static PyGetSetDef __pyx_CyFunction_getsets[] = {
    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
    {(char *) "__self__", (getter)__Pyx_CyFunction_get_self, 0, 0, 0},
    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
    {0, 0, 0, 0, 0}
};
static PyMemberDef __pyx_CyFunction_members[] = {
    {(char *) "__module__", T_OBJECT, offsetof(PyCFunctionObject, m_module), PY_WRITE_RESTRICTED, 0},
    {0, 0, 0,  0, 0}
};
static PyObject *
__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, CYTHON_UNUSED PyObject *args)
{
#if PY_MAJOR_VERSION >= 3
    Py_INCREF(m->func_qualname);
    return m->func_qualname;
#else
    return PyString_FromString(m->func.m_ml->ml_name);
#endif
}
static PyMethodDef __pyx_CyFunction_methods[] = {
    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
    {0, 0, 0, 0}
};
#if PY_VERSION_HEX < 0x030500A0
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
#else
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func.m_weakreflist)
#endif
static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject *op, PyMethodDef *ml, int flags, PyObject* qualname,
                                       PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
    if (unlikely(op == NULL))
        return NULL;
    op->flags = flags;
    __Pyx_CyFunction_weakreflist(op) = NULL;
    op->func.m_ml = ml;
    op->func.m_self = (PyObject *) op;
    Py_XINCREF(closure);
    op->func_closure = closure;
    Py_XINCREF(module);
    op->func.m_module = module;
    op->func_dict = NULL;
    op->func_name = NULL;
    Py_INCREF(qualname);
    op->func_qualname = qualname;
    op->func_doc = NULL;
    op->func_classobj = NULL;
    op->func_globals = globals;
    Py_INCREF(op->func_globals);
    Py_XINCREF(code);
    op->func_code = code;
    op->defaults_pyobjects = 0;
    op->defaults_size = 0;
    op->defaults = NULL;
    op->defaults_tuple = NULL;
    op->defaults_kwdict = NULL;
    op->defaults_getter = NULL;
    op->func_annotations = NULL;
    return (PyObject *) op;
}
static int
__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
{
    Py_CLEAR(m->func_closure);
    Py_CLEAR(m->func.m_module);
    Py_CLEAR(m->func_dict);
    Py_CLEAR(m->func_name);
    Py_CLEAR(m->func_qualname);
    Py_CLEAR(m->func_doc);
    Py_CLEAR(m->func_globals);
    Py_CLEAR(m->func_code);
    Py_CLEAR(m->func_classobj);
    Py_CLEAR(m->defaults_tuple);
    Py_CLEAR(m->defaults_kwdict);
    Py_CLEAR(m->func_annotations);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_XDECREF(pydefaults[i]);
        PyObject_Free(m->defaults);
        m->defaults = NULL;
    }
    return 0;
}
static void __Pyx__CyFunction_dealloc(__pyx_CyFunctionObject *m)
{
    if (__Pyx_CyFunction_weakreflist(m) != NULL)
        PyObject_ClearWeakRefs((PyObject *) m);
    __Pyx_CyFunction_clear(m);
    PyObject_GC_Del(m);
}
static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
{
    PyObject_GC_UnTrack(m);
    __Pyx__CyFunction_dealloc(m);
}
static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
{
    Py_VISIT(m->func_closure);
    Py_VISIT(m->func.m_module);
    Py_VISIT(m->func_dict);
    Py_VISIT(m->func_name);
    Py_VISIT(m->func_qualname);
    Py_VISIT(m->func_doc);
    Py_VISIT(m->func_globals);
    Py_VISIT(m->func_code);
    Py_VISIT(m->func_classobj);
    Py_VISIT(m->defaults_tuple);
    Py_VISIT(m->defaults_kwdict);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_VISIT(pydefaults[i]);
    }
    return 0;
}
static PyObject *__Pyx_CyFunction_descr_get(PyObject *func, PyObject *obj, PyObject *type)
{
#if PY_MAJOR_VERSION < 3
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    if (m->flags & __Pyx_CYFUNCTION_STATICMETHOD) {
        Py_INCREF(func);
        return func;
    }
    if (m->flags & __Pyx_CYFUNCTION_CLASSMETHOD) {
        if (type == NULL)
            type = (PyObject *)(Py_TYPE(obj));
        return __Pyx_PyMethod_New(func, type, (PyObject *)(Py_TYPE(type)));
    }
    if (obj == Py_None)
        obj = NULL;
#endif
    return __Pyx_PyMethod_New(func, obj, type);
}
static PyObject*
__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
{
#if PY_MAJOR_VERSION >= 3
    return PyUnicode_FromFormat("<cyfunction %U at %p>",
                                op->func_qualname, (void *)op);
#else
    return PyString_FromFormat("<cyfunction %s at %p>",
                               PyString_AsString(op->func_qualname), (void *)op);
#endif
}
static PyObject * __Pyx_CyFunction_CallMethod(PyObject *func, PyObject *self, PyObject *arg, PyObject *kw) {
    PyCFunctionObject* f = (PyCFunctionObject*)func;
    PyCFunction meth = f->m_ml->ml_meth;
    Py_ssize_t size;
    switch (f->m_ml->ml_flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
    case METH_VARARGS:
        if (likely(kw == NULL || PyDict_Size(kw) == 0))
            return (*meth)(self, arg);
        break;
    case METH_VARARGS | METH_KEYWORDS:
        return (*(PyCFunctionWithKeywords)(void*)meth)(self, arg, kw);
    case METH_NOARGS:
        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
            size = PyTuple_GET_SIZE(arg);
            if (likely(size == 0))
                return (*meth)(self, NULL);
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    case METH_O:
        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
            size = PyTuple_GET_SIZE(arg);
            if (likely(size == 1)) {
                PyObject *result, *arg0;
                #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
                arg0 = PyTuple_GET_ITEM(arg, 0);
                #else
                arg0 = PySequence_ITEM(arg, 0); if (unlikely(!arg0)) return NULL;
                #endif
                result = (*meth)(self, arg0);
                #if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
                Py_DECREF(arg0);
                #endif
                return result;
            }
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    default:
        PyErr_SetString(PyExc_SystemError, "Bad call flags in "
                        "__Pyx_CyFunction_Call. METH_OLDARGS is no "
                        "longer supported!");
        return NULL;
    }
    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
                 f->m_ml->ml_name);
    return NULL;
}
static CYTHON_INLINE PyObject *__Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    return __Pyx_CyFunction_CallMethod(func, ((PyCFunctionObject*)func)->m_self, arg, kw);
}
static PyObject *__Pyx_CyFunction_CallAsMethod(PyObject *func, PyObject *args, PyObject *kw) {
    PyObject *result;
    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *) func;
    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
        Py_ssize_t argc;
        PyObject *new_args;
        PyObject *self;
        argc = PyTuple_GET_SIZE(args);
        new_args = PyTuple_GetSlice(args, 1, argc);
        if (unlikely(!new_args))
            return NULL;
        self = PyTuple_GetItem(args, 0);
        if (unlikely(!self)) {
            Py_DECREF(new_args);
#if PY_MAJOR_VERSION > 2
            PyErr_Format(PyExc_TypeError,
                         "unbound method %.200S() needs an argument",
                         cyfunc->func_qualname);
#else
            PyErr_SetString(PyExc_TypeError,
                            "unbound method needs an argument");
#endif
            return NULL;
        }
        result = __Pyx_CyFunction_CallMethod(func, self, new_args, kw);
        Py_DECREF(new_args);
    } else {
        result = __Pyx_CyFunction_Call(func, args, kw);
    }
    return result;
}
static PyTypeObject __pyx_CyFunctionType_type = {
    PyVarObject_HEAD_INIT(0, 0)
    "cython_function_or_method",
    sizeof(__pyx_CyFunctionObject),
    0,
    (destructor) __Pyx_CyFunction_dealloc,
    0,
    0,
    0,
#if PY_MAJOR_VERSION < 3
    0,
#else
    0,
#endif
    (reprfunc) __Pyx_CyFunction_repr,
    0,
    0,
    0,
    0,
    __Pyx_CyFunction_CallAsMethod,
    0,
    0,
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
    0,
    (traverseproc) __Pyx_CyFunction_traverse,
    (inquiry) __Pyx_CyFunction_clear,
    0,
#if PY_VERSION_HEX < 0x030500A0
    offsetof(__pyx_CyFunctionObject, func_weakreflist),
#else
    offsetof(PyCFunctionObject, m_weakreflist),
#endif
    0,
    0,
    __pyx_CyFunction_methods,
    __pyx_CyFunction_members,
    __pyx_CyFunction_getsets,
    0,
    0,
    __Pyx_CyFunction_descr_get,
    0,
    offsetof(__pyx_CyFunctionObject, func_dict),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
#if PY_VERSION_HEX >= 0x030400a1
    0,
#endif
#if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
    0,
#endif
#if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
    0,
#endif
#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
    0,
#endif
};
static int __pyx_CyFunction_init(void) {
    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
    if (unlikely(__pyx_CyFunctionType == NULL)) {
        return -1;
    }
    return 0;
}
static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults = PyObject_Malloc(size);
    if (unlikely(!m->defaults))
        return PyErr_NoMemory();
    memset(m->defaults, 0, size);
    m->defaults_pyobjects = pyobjects;
    m->defaults_size = size;
    return m->defaults;
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_tuple = tuple;
    Py_INCREF(tuple);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_kwdict = dict;
    Py_INCREF(dict);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->func_annotations = dict;
    Py_INCREF(dict);
}

/* CythonFunction */
static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml, int flags, PyObject* qualname,
                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
    PyObject *op = __Pyx_CyFunction_Init(
        PyObject_GC_New(__pyx_CyFunctionObject, __pyx_CyFunctionType),
        ml, flags, qualname, closure, module, globals, code
    );
    if (likely(op)) {
        PyObject_GC_Track(op);
    }
    return op;
}

/* Py3ClassCreate */
static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name,
                                           PyObject *qualname, PyObject *mkw, PyObject *modname, PyObject *doc) {
    PyObject *ns;
    if (metaclass) {
        PyObject *prep = __Pyx_PyObject_GetAttrStr(metaclass, __pyx_n_s_prepare);
        if (prep) {
            PyObject *pargs = PyTuple_Pack(2, name, bases);
            if (unlikely(!pargs)) {
                Py_DECREF(prep);
                return NULL;
            }
            ns = PyObject_Call(prep, pargs, mkw);
            Py_DECREF(prep);
            Py_DECREF(pargs);
        } else {
            if (unlikely(!PyErr_ExceptionMatches(PyExc_AttributeError)))
                return NULL;
            PyErr_Clear();
            ns = PyDict_New();
        }
    } else {
        ns = PyDict_New();
    }
    if (unlikely(!ns))
        return NULL;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_module, modname) < 0)) goto bad;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_qualname, qualname) < 0)) goto bad;
    if (unlikely(doc && PyObject_SetItem(ns, __pyx_n_s_doc, doc) < 0)) goto bad;
    return ns;
bad:
    Py_DECREF(ns);
    return NULL;
}
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases,
                                      PyObject *dict, PyObject *mkw,
                                      int calculate_metaclass, int allow_py2_metaclass) {
    PyObject *result, *margs;
    PyObject *owned_metaclass = NULL;
    if (allow_py2_metaclass) {
        owned_metaclass = PyObject_GetItem(dict, __pyx_n_s_metaclass);
        if (owned_metaclass) {
            metaclass = owned_metaclass;
        } else if (likely(PyErr_ExceptionMatches(PyExc_KeyError))) {
            PyErr_Clear();
        } else {
            return NULL;
        }
    }
    if (calculate_metaclass && (!metaclass || PyType_Check(metaclass))) {
        metaclass = __Pyx_CalculateMetaclass((PyTypeObject*) metaclass, bases);
        Py_XDECREF(owned_metaclass);
        if (unlikely(!metaclass))
            return NULL;
        owned_metaclass = metaclass;
    }
    margs = PyTuple_Pack(3, name, bases, dict);
    if (unlikely(!margs)) {
        result = NULL;
    } else {
        result = PyObject_Call(metaclass, margs, mkw);
        Py_DECREF(margs);
    }
    Py_XDECREF(owned_metaclass);
    return result;
}

/* CLineInTraceback */
#ifndef CYTHON_CLINE_IN_TRACEBACK
static int __Pyx_CLineForTraceback(CYTHON_UNUSED PyThreadState *tstate, int c_line) {
    PyObject *use_cline;
    PyObject *ptype, *pvalue, *ptraceback;
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject **cython_runtime_dict;
#endif
    if (unlikely(!__pyx_cython_runtime)) {
        return c_line;
    }
    __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
#if CYTHON_COMPILING_IN_CPYTHON
    cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
    if (likely(cython_runtime_dict)) {
        __PYX_PY_DICT_LOOKUP_IF_MODIFIED(
            use_cline, *cython_runtime_dict,
            __Pyx_PyDict_GetItemStr(*cython_runtime_dict, __pyx_n_s_cline_in_traceback))
    } else
#endif
    {
      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
      if (use_cline_obj) {
        use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
        Py_DECREF(use_cline_obj);
      } else {
        PyErr_Clear();
        use_cline = NULL;
      }
    }
    if (!use_cline) {
        c_line = 0;
        (void) PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
    }
    else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
        c_line = 0;
    }
    __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
    return c_line;
}
#endif

/* CodeObjectCache */
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = start + (end - start) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, ((size_t)new_max) * sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

/* AddTraceback */
#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
#if PY_VERSION_HEX >= 0x030b00a6
  #ifndef Py_BUILD_CORE
    #define Py_BUILD_CORE 1
  #endif
  #include "internal/pycore_frame.h"
#endif
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = NULL;
    PyObject *py_funcname = NULL;
    #if PY_MAJOR_VERSION < 3
    PyObject *py_srcfile = NULL;
    py_srcfile = PyString_FromString(filename);
    if (!py_srcfile) goto bad;
    #endif
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        if (!py_funcname) goto bad;
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        if (!py_funcname) goto bad;
        funcname = PyUnicode_AsUTF8(py_funcname);
        if (!funcname) goto bad;
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        if (!py_funcname) goto bad;
        #endif
    }
    #if PY_MAJOR_VERSION < 3
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    #else
    py_code = PyCode_NewEmpty(filename, funcname, py_line);
    #endif
    Py_XDECREF(py_funcname);  // XDECREF since it's only set on Py3 if cline
    return py_code;
bad:
    Py_XDECREF(py_funcname);
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(py_srcfile);
    #endif
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    PyObject *ptype, *pvalue, *ptraceback;
    if (c_line) {
        c_line = __Pyx_CLineForTraceback(tstate, c_line);
    }
    py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
    if (!py_code) {
        __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) {
            /* If the code object creation fails, then we should clear the
               fetched exception references and propagate the new exception */
            Py_XDECREF(ptype);
            Py_XDECREF(pvalue);
            Py_XDECREF(ptraceback);
            goto bad;
        }
        __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
        __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        tstate,            /*PyThreadState *tstate,*/
        py_code,           /*PyCodeObject *code,*/
        __pyx_d,    /*PyObject *globals,*/
        0                  /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* CIntFromPyVerify */
#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
    {\
        func_type value = func_value;\
        if (sizeof(target_type) < sizeof(func_type)) {\
            if (unlikely(value != (func_type) (target_type) value)) {\
                func_type zero = 0;\
                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
                    return (target_type) -1;\
                if (is_unsigned && unlikely(value < zero))\
                    goto raise_neg_overflow;\
                else\
                    goto raise_overflow;\
            }\
        }\
        return (target_type) value;\
    }

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
    const int neg_one = (int) -1, const_zero = (int) 0;
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic pop
#endif
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(int) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int),
                                     little, !is_unsigned);
    }
}

/* CIntFromPy */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
    const int neg_one = (int) -1, const_zero = (int) 0;
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic pop
#endif
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

/* CIntFromPy */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
    const long neg_one = (long) -1, const_zero = (long) 0;
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic pop
#endif
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (long) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
    const long neg_one = (long) -1, const_zero = (long) 0;
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic pop
#endif
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

/* FastTypeChecks */
#if CYTHON_COMPILING_IN_CPYTHON
static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
    while (a) {
        a = a->tp_base;
        if (a == b)
            return 1;
    }
    return b == &PyBaseObject_Type;
}
static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
    PyObject *mro;
    if (a == b) return 1;
    mro = a->tp_mro;
    if (likely(mro)) {
        Py_ssize_t i, n;
        n = PyTuple_GET_SIZE(mro);
        for (i = 0; i < n; i++) {
            if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
                return 1;
        }
        return 0;
    }
    return __Pyx_InBases(a, b);
}
#if PY_MAJOR_VERSION == 2
static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
    PyObject *exception, *value, *tb;
    int res;
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&exception, &value, &tb);
    res = exc_type1 ? PyObject_IsSubclass(err, exc_type1) : 0;
    if (unlikely(res == -1)) {
        PyErr_WriteUnraisable(err);
        res = 0;
    }
    if (!res) {
        res = PyObject_IsSubclass(err, exc_type2);
        if (unlikely(res == -1)) {
            PyErr_WriteUnraisable(err);
            res = 0;
        }
    }
    __Pyx_ErrRestore(exception, value, tb);
    return res;
}
#else
static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
    if (!res) {
        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
    }
    return res;
}
#endif
static int __Pyx_PyErr_GivenExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
    Py_ssize_t i, n;
    assert(PyExceptionClass_Check(exc_type));
    n = PyTuple_GET_SIZE(tuple);
#if PY_MAJOR_VERSION >= 3
    for (i=0; i<n; i++) {
        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
    }
#endif
    for (i=0; i<n; i++) {
        PyObject *t = PyTuple_GET_ITEM(tuple, i);
        #if PY_MAJOR_VERSION < 3
        if (likely(exc_type == t)) return 1;
        #endif
        if (likely(PyExceptionClass_Check(t))) {
            if (__Pyx_inner_PyErr_GivenExceptionMatches2(exc_type, NULL, t)) return 1;
        } else {
        }
    }
    return 0;
}
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject* exc_type) {
    if (likely(err == exc_type)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        if (likely(PyExceptionClass_Check(exc_type))) {
            return __Pyx_inner_PyErr_GivenExceptionMatches2(err, NULL, exc_type);
        } else if (likely(PyTuple_Check(exc_type))) {
            return __Pyx_PyErr_GivenExceptionMatchesTuple(err, exc_type);
        } else {
        }
    }
    return PyErr_GivenExceptionMatches(err, exc_type);
}
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *exc_type1, PyObject *exc_type2) {
    assert(PyExceptionClass_Check(exc_type1));
    assert(PyExceptionClass_Check(exc_type2));
    if (likely(err == exc_type1 || err == exc_type2)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
    }
    return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
}
#endif

/* PyObjectGetMethod */
static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method) {
    PyObject *attr;
#if CYTHON_UNPACK_METHODS && CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_PYTYPE_LOOKUP
    PyTypeObject *tp = Py_TYPE(obj);
    PyObject *descr;
    descrgetfunc f = NULL;
    PyObject **dictptr, *dict;
    int meth_found = 0;
    assert (*method == NULL);
    if (unlikely(tp->tp_getattro != PyObject_GenericGetAttr)) {
        attr = __Pyx_PyObject_GetAttrStr(obj, name);
        goto try_unpack;
    }
    if (unlikely(tp->tp_dict == NULL) && unlikely(PyType_Ready(tp) < 0)) {
        return 0;
    }
    descr = _PyType_Lookup(tp, name);
    if (likely(descr != NULL)) {
        Py_INCREF(descr);
#if PY_MAJOR_VERSION >= 3
        #ifdef __Pyx_CyFunction_USED
        if (likely(PyFunction_Check(descr) || (Py_TYPE(descr) == &PyMethodDescr_Type) || __Pyx_CyFunction_Check(descr)))
        #else
        if (likely(PyFunction_Check(descr) || (Py_TYPE(descr) == &PyMethodDescr_Type)))
        #endif
#else
        #ifdef __Pyx_CyFunction_USED
        if (likely(PyFunction_Check(descr) || __Pyx_CyFunction_Check(descr)))
        #else
        if (likely(PyFunction_Check(descr)))
        #endif
#endif
        {
            meth_found = 1;
        } else {
            f = Py_TYPE(descr)->tp_descr_get;
            if (f != NULL && PyDescr_IsData(descr)) {
                attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
                Py_DECREF(descr);
                goto try_unpack;
            }
        }
    }
    dictptr = _PyObject_GetDictPtr(obj);
    if (dictptr != NULL && (dict = *dictptr) != NULL) {
        Py_INCREF(dict);
        attr = __Pyx_PyDict_GetItemStr(dict, name);
        if (attr != NULL) {
            Py_INCREF(attr);
            Py_DECREF(dict);
            Py_XDECREF(descr);
            goto try_unpack;
        }
        Py_DECREF(dict);
    }
    if (meth_found) {
        *method = descr;
        return 1;
    }
    if (f != NULL) {
        attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
        Py_DECREF(descr);
        goto try_unpack;
    }
    if (descr != NULL) {
        *method = descr;
        return 0;
    }
    PyErr_Format(PyExc_AttributeError,
#if PY_MAJOR_VERSION >= 3
                 "'%.50s' object has no attribute '%U'",
                 tp->tp_name, name);
#else
                 "'%.50s' object has no attribute '%.400s'",
                 tp->tp_name, PyString_AS_STRING(name));
#endif
    return 0;
#else
    attr = __Pyx_PyObject_GetAttrStr(obj, name);
    goto try_unpack;
#endif
try_unpack:
#if CYTHON_UNPACK_METHODS
    if (likely(attr) && PyMethod_Check(attr) && likely(PyMethod_GET_SELF(attr) == obj)) {
        PyObject *function = PyMethod_GET_FUNCTION(attr);
        Py_INCREF(function);
        Py_DECREF(attr);
        *method = function;
        return 1;
    }
#endif
    *method = attr;
    return 0;
}

/* PyObjectCallMethod1 */
static PyObject* __Pyx__PyObject_CallMethod1(PyObject* method, PyObject* arg) {
    PyObject *result = __Pyx_PyObject_CallOneArg(method, arg);
    Py_DECREF(method);
    return result;
}
static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg) {
    PyObject *method = NULL, *result;
    int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
    if (likely(is_method)) {
        result = __Pyx_PyObject_Call2Args(method, obj, arg);
        Py_DECREF(method);
        return result;
    }
    if (unlikely(!method)) return NULL;
    return __Pyx__PyObject_CallMethod1(method, arg);
}

/* CoroutineBase */
#include <structmember.h>
#include <frameobject.h>
#if PY_VERSION_HEX >= 0x030b00a6
  #ifndef Py_BUILD_CORE
    #define Py_BUILD_CORE 1
  #endif
  #include "internal/pycore_frame.h"
#endif
#define __Pyx_Coroutine_Undelegate(gen) Py_CLEAR((gen)->yieldfrom)
static int __Pyx_PyGen__FetchStopIterationValue(CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject **pvalue) {
    PyObject *et, *ev, *tb;
    PyObject *value = NULL;
    __Pyx_ErrFetch(&et, &ev, &tb);
    if (!et) {
        Py_XDECREF(tb);
        Py_XDECREF(ev);
        Py_INCREF(Py_None);
        *pvalue = Py_None;
        return 0;
    }
    if (likely(et == PyExc_StopIteration)) {
        if (!ev) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#if PY_VERSION_HEX >= 0x030300A0
        else if (Py_TYPE(ev) == (PyTypeObject*)PyExc_StopIteration) {
            value = ((PyStopIterationObject *)ev)->value;
            Py_INCREF(value);
            Py_DECREF(ev);
        }
#endif
        else if (unlikely(PyTuple_Check(ev))) {
            if (PyTuple_GET_SIZE(ev) >= 1) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
                value = PyTuple_GET_ITEM(ev, 0);
                Py_INCREF(value);
#else
                value = PySequence_ITEM(ev, 0);
#endif
            } else {
                Py_INCREF(Py_None);
                value = Py_None;
            }
            Py_DECREF(ev);
        }
        else if (!__Pyx_TypeCheck(ev, (PyTypeObject*)PyExc_StopIteration)) {
            value = ev;
        }
        if (likely(value)) {
            Py_XDECREF(tb);
            Py_DECREF(et);
            *pvalue = value;
            return 0;
        }
    } else if (!__Pyx_PyErr_GivenExceptionMatches(et, PyExc_StopIteration)) {
        __Pyx_ErrRestore(et, ev, tb);
        return -1;
    }
    PyErr_NormalizeException(&et, &ev, &tb);
    if (unlikely(!PyObject_TypeCheck(ev, (PyTypeObject*)PyExc_StopIteration))) {
        __Pyx_ErrRestore(et, ev, tb);
        return -1;
    }
    Py_XDECREF(tb);
    Py_DECREF(et);
#if PY_VERSION_HEX >= 0x030300A0
    value = ((PyStopIterationObject *)ev)->value;
    Py_INCREF(value);
    Py_DECREF(ev);
#else
    {
        PyObject* args = __Pyx_PyObject_GetAttrStr(ev, __pyx_n_s_args);
        Py_DECREF(ev);
        if (likely(args)) {
            value = PySequence_GetItem(args, 0);
            Py_DECREF(args);
        }
        if (unlikely(!value)) {
            __Pyx_ErrRestore(NULL, NULL, NULL);
            Py_INCREF(Py_None);
            value = Py_None;
        }
    }
#endif
    *pvalue = value;
    return 0;
}
static CYTHON_INLINE
void __Pyx_Coroutine_ExceptionClear(__Pyx_ExcInfoStruct *exc_state) {
    PyObject *t, *v, *tb;
    t = exc_state->exc_type;
    v = exc_state->exc_value;
    tb = exc_state->exc_traceback;
    exc_state->exc_type = NULL;
    exc_state->exc_value = NULL;
    exc_state->exc_traceback = NULL;
    Py_XDECREF(t);
    Py_XDECREF(v);
    Py_XDECREF(tb);
}
#define __Pyx_Coroutine_AlreadyRunningError(gen)  (__Pyx__Coroutine_AlreadyRunningError(gen), (PyObject*)NULL)
static void __Pyx__Coroutine_AlreadyRunningError(CYTHON_UNUSED __pyx_CoroutineObject *gen) {
    const char *msg;
    if ((0)) {
    #ifdef __Pyx_Coroutine_USED
    } else if (__Pyx_Coroutine_Check((PyObject*)gen)) {
        msg = "coroutine already executing";
    #endif
    #ifdef __Pyx_AsyncGen_USED
    } else if (__Pyx_AsyncGen_CheckExact((PyObject*)gen)) {
        msg = "async generator already executing";
    #endif
    } else {
        msg = "generator already executing";
    }
    PyErr_SetString(PyExc_ValueError, msg);
}
#define __Pyx_Coroutine_NotStartedError(gen)  (__Pyx__Coroutine_NotStartedError(gen), (PyObject*)NULL)
static void __Pyx__Coroutine_NotStartedError(CYTHON_UNUSED PyObject *gen) {
    const char *msg;
    if ((0)) {
    #ifdef __Pyx_Coroutine_USED
    } else if (__Pyx_Coroutine_Check(gen)) {
        msg = "can't send non-None value to a just-started coroutine";
    #endif
    #ifdef __Pyx_AsyncGen_USED
    } else if (__Pyx_AsyncGen_CheckExact(gen)) {
        msg = "can't send non-None value to a just-started async generator";
    #endif
    } else {
        msg = "can't send non-None value to a just-started generator";
    }
    PyErr_SetString(PyExc_TypeError, msg);
}
#define __Pyx_Coroutine_AlreadyTerminatedError(gen, value, closing)  (__Pyx__Coroutine_AlreadyTerminatedError(gen, value, closing), (PyObject*)NULL)
static void __Pyx__Coroutine_AlreadyTerminatedError(CYTHON_UNUSED PyObject *gen, PyObject *value, CYTHON_UNUSED int closing) {
    #ifdef __Pyx_Coroutine_USED
    if (!closing && __Pyx_Coroutine_Check(gen)) {
        PyErr_SetString(PyExc_RuntimeError, "cannot reuse already awaited coroutine");
    } else
    #endif
    if (value) {
        #ifdef __Pyx_AsyncGen_USED
        if (__Pyx_AsyncGen_CheckExact(gen))
            PyErr_SetNone(__Pyx_PyExc_StopAsyncIteration);
        else
        #endif
        PyErr_SetNone(PyExc_StopIteration);
    }
}
static
PyObject *__Pyx_Coroutine_SendEx(__pyx_CoroutineObject *self, PyObject *value, int closing) {
    __Pyx_PyThreadState_declare
    PyThreadState *tstate;
    __Pyx_ExcInfoStruct *exc_state;
    PyObject *retval;
    assert(!self->is_running);
    if (unlikely(self->resume_label == 0)) {
        if (unlikely(value && value != Py_None)) {
            return __Pyx_Coroutine_NotStartedError((PyObject*)self);
        }
    }
    if (unlikely(self->resume_label == -1)) {
        return __Pyx_Coroutine_AlreadyTerminatedError((PyObject*)self, value, closing);
    }
#if CYTHON_FAST_THREAD_STATE
    __Pyx_PyThreadState_assign
    tstate = __pyx_tstate;
#else
    tstate = __Pyx_PyThreadState_Current;
#endif
    exc_state = &self->gi_exc_state;
    if (exc_state->exc_type) {
        #if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_PYSTON
        #else
        if (exc_state->exc_traceback) {
            PyTracebackObject *tb = (PyTracebackObject *) exc_state->exc_traceback;
            PyFrameObject *f = tb->tb_frame;
            assert(f->f_back == NULL);
            #if PY_VERSION_HEX >= 0x030B00A1
            f->f_back = PyThreadState_GetFrame(tstate);
            #else
            Py_XINCREF(tstate->frame);
            f->f_back = tstate->frame;
            #endif
        }
        #endif
    }
#if CYTHON_USE_EXC_INFO_STACK
    exc_state->previous_item = tstate->exc_info;
    tstate->exc_info = exc_state;
#else
    if (exc_state->exc_type) {
        __Pyx_ExceptionSwap(&exc_state->exc_type, &exc_state->exc_value, &exc_state->exc_traceback);
    } else {
        __Pyx_Coroutine_ExceptionClear(exc_state);
        __Pyx_ExceptionSave(&exc_state->exc_type, &exc_state->exc_value, &exc_state->exc_traceback);
    }
#endif
    self->is_running = 1;
    retval = self->body((PyObject *) self, tstate, value);
    self->is_running = 0;
#if CYTHON_USE_EXC_INFO_STACK
    exc_state = &self->gi_exc_state;
    tstate->exc_info = exc_state->previous_item;
    exc_state->previous_item = NULL;
    __Pyx_Coroutine_ResetFrameBackpointer(exc_state);
#endif
    return retval;
}
static CYTHON_INLINE void __Pyx_Coroutine_ResetFrameBackpointer(__Pyx_ExcInfoStruct *exc_state) {
    PyObject *exc_tb = exc_state->exc_traceback;
    if (likely(exc_tb)) {
#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_PYSTON
#else
        PyTracebackObject *tb = (PyTracebackObject *) exc_tb;
        PyFrameObject *f = tb->tb_frame;
        Py_CLEAR(f->f_back);
#endif
    }
}
static CYTHON_INLINE
PyObject *__Pyx_Coroutine_MethodReturn(CYTHON_UNUSED PyObject* gen, PyObject *retval) {
    if (unlikely(!retval)) {
        __Pyx_PyThreadState_declare
        __Pyx_PyThreadState_assign
        if (!__Pyx_PyErr_Occurred()) {
            PyObject *exc = PyExc_StopIteration;
            #ifdef __Pyx_AsyncGen_USED
            if (__Pyx_AsyncGen_CheckExact(gen))
                exc = __Pyx_PyExc_StopAsyncIteration;
            #endif
            __Pyx_PyErr_SetNone(exc);
        }
    }
    return retval;
}
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03030000 && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
static CYTHON_INLINE
PyObject *__Pyx_PyGen_Send(PyGenObject *gen, PyObject *arg) {
#if PY_VERSION_HEX <= 0x030A00A1
    return _PyGen_Send(gen, arg);
#else
    PyObject *result;
    if (PyIter_Send((PyObject*)gen, arg ? arg : Py_None, &result) == PYGEN_RETURN) {
        if (PyAsyncGen_CheckExact(gen)) {
            assert(result == Py_None);
            PyErr_SetNone(PyExc_StopAsyncIteration);
        }
        else if (result == Py_None) {
            PyErr_SetNone(PyExc_StopIteration);
        }
        else {
            _PyGen_SetStopIterationValue(result);
        }
        Py_CLEAR(result);
    }
    return result;
#endif
}
#endif
static CYTHON_INLINE
PyObject *__Pyx_Coroutine_FinishDelegation(__pyx_CoroutineObject *gen) {
    PyObject *ret;
    PyObject *val = NULL;
    __Pyx_Coroutine_Undelegate(gen);
    __Pyx_PyGen__FetchStopIterationValue(__Pyx_PyThreadState_Current, &val);
    ret = __Pyx_Coroutine_SendEx(gen, val, 0);
    Py_XDECREF(val);
    return ret;
}
static PyObject *__Pyx_Coroutine_Send(PyObject *self, PyObject *value) {
    PyObject *retval;
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject*) self;
    PyObject *yf = gen->yieldfrom;
    if (unlikely(gen->is_running))
        return __Pyx_Coroutine_AlreadyRunningError(gen);
    if (yf) {
        PyObject *ret;
        gen->is_running = 1;
        #ifdef __Pyx_Generator_USED
        if (__Pyx_Generator_CheckExact(yf)) {
            ret = __Pyx_Coroutine_Send(yf, value);
        } else
        #endif
        #ifdef __Pyx_Coroutine_USED
        if (__Pyx_Coroutine_Check(yf)) {
            ret = __Pyx_Coroutine_Send(yf, value);
        } else
        #endif
        #ifdef __Pyx_AsyncGen_USED
        if (__pyx_PyAsyncGenASend_CheckExact(yf)) {
            ret = __Pyx_async_gen_asend_send(yf, value);
        } else
        #endif
        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03030000 && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
        if (PyGen_CheckExact(yf)) {
            ret = __Pyx_PyGen_Send((PyGenObject*)yf, value == Py_None ? NULL : value);
        } else
        #endif
        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03050000 && defined(PyCoro_CheckExact) && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
        if (PyCoro_CheckExact(yf)) {
            ret = __Pyx_PyGen_Send((PyGenObject*)yf, value == Py_None ? NULL : value);
        } else
        #endif
        {
            if (value == Py_None)
                ret = Py_TYPE(yf)->tp_iternext(yf);
            else
                ret = __Pyx_PyObject_CallMethod1(yf, __pyx_n_s_send, value);
        }
        gen->is_running = 0;
        if (likely(ret)) {
            return ret;
        }
        retval = __Pyx_Coroutine_FinishDelegation(gen);
    } else {
        retval = __Pyx_Coroutine_SendEx(gen, value, 0);
    }
    return __Pyx_Coroutine_MethodReturn(self, retval);
}
static int __Pyx_Coroutine_CloseIter(__pyx_CoroutineObject *gen, PyObject *yf) {
    PyObject *retval = NULL;
    int err = 0;
    #ifdef __Pyx_Generator_USED
    if (__Pyx_Generator_CheckExact(yf)) {
        retval = __Pyx_Coroutine_Close(yf);
        if (!retval)
            return -1;
    } else
    #endif
    #ifdef __Pyx_Coroutine_USED
    if (__Pyx_Coroutine_Check(yf)) {
        retval = __Pyx_Coroutine_Close(yf);
        if (!retval)
            return -1;
    } else
    if (__Pyx_CoroutineAwait_CheckExact(yf)) {
        retval = __Pyx_CoroutineAwait_Close((__pyx_CoroutineAwaitObject*)yf, NULL);
        if (!retval)
            return -1;
    } else
    #endif
    #ifdef __Pyx_AsyncGen_USED
    if (__pyx_PyAsyncGenASend_CheckExact(yf)) {
        retval = __Pyx_async_gen_asend_close(yf, NULL);
    } else
    if (__pyx_PyAsyncGenAThrow_CheckExact(yf)) {
        retval = __Pyx_async_gen_athrow_close(yf, NULL);
    } else
    #endif
    {
        PyObject *meth;
        gen->is_running = 1;
        meth = __Pyx_PyObject_GetAttrStr(yf, __pyx_n_s_close);
        if (unlikely(!meth)) {
            if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {
                PyErr_WriteUnraisable(yf);
            }
            PyErr_Clear();
        } else {
            retval = PyObject_CallFunction(meth, NULL);
            Py_DECREF(meth);
            if (!retval)
                err = -1;
        }
        gen->is_running = 0;
    }
    Py_XDECREF(retval);
    return err;
}
static PyObject *__Pyx_Generator_Next(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject*) self;
    PyObject *yf = gen->yieldfrom;
    if (unlikely(gen->is_running))
        return __Pyx_Coroutine_AlreadyRunningError(gen);
    if (yf) {
        PyObject *ret;
        gen->is_running = 1;
        #ifdef __Pyx_Generator_USED
        if (__Pyx_Generator_CheckExact(yf)) {
            ret = __Pyx_Generator_Next(yf);
        } else
        #endif
        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03030000 && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
        if (PyGen_CheckExact(yf)) {
            ret = __Pyx_PyGen_Send((PyGenObject*)yf, NULL);
        } else
        #endif
        #ifdef __Pyx_Coroutine_USED
        if (__Pyx_Coroutine_Check(yf)) {
            ret = __Pyx_Coroutine_Send(yf, Py_None);
        } else
        #endif
            ret = Py_TYPE(yf)->tp_iternext(yf);
        gen->is_running = 0;
        if (likely(ret)) {
            return ret;
        }
        return __Pyx_Coroutine_FinishDelegation(gen);
    }
    return __Pyx_Coroutine_SendEx(gen, Py_None, 0);
}
static PyObject *__Pyx_Coroutine_Close_Method(PyObject *self, CYTHON_UNUSED PyObject *arg) {
    return __Pyx_Coroutine_Close(self);
}
static PyObject *__Pyx_Coroutine_Close(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    PyObject *retval, *raised_exception;
    PyObject *yf = gen->yieldfrom;
    int err = 0;
    if (unlikely(gen->is_running))
        return __Pyx_Coroutine_AlreadyRunningError(gen);
    if (yf) {
        Py_INCREF(yf);
        err = __Pyx_Coroutine_CloseIter(gen, yf);
        __Pyx_Coroutine_Undelegate(gen);
        Py_DECREF(yf);
    }
    if (err == 0)
        PyErr_SetNone(PyExc_GeneratorExit);
    retval = __Pyx_Coroutine_SendEx(gen, NULL, 1);
    if (unlikely(retval)) {
        const char *msg;
        Py_DECREF(retval);
        if ((0)) {
        #ifdef __Pyx_Coroutine_USED
        } else if (__Pyx_Coroutine_Check(self)) {
            msg = "coroutine ignored GeneratorExit";
        #endif
        #ifdef __Pyx_AsyncGen_USED
        } else if (__Pyx_AsyncGen_CheckExact(self)) {
#if PY_VERSION_HEX < 0x03060000
            msg = "async generator ignored GeneratorExit - might require Python 3.6+ finalisation (PEP 525)";
#else
            msg = "async generator ignored GeneratorExit";
#endif
        #endif
        } else {
            msg = "generator ignored GeneratorExit";
        }
        PyErr_SetString(PyExc_RuntimeError, msg);
        return NULL;
    }
    raised_exception = PyErr_Occurred();
    if (likely(!raised_exception || __Pyx_PyErr_GivenExceptionMatches2(raised_exception, PyExc_GeneratorExit, PyExc_StopIteration))) {
        if (raised_exception) PyErr_Clear();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
}
static PyObject *__Pyx__Coroutine_Throw(PyObject *self, PyObject *typ, PyObject *val, PyObject *tb,
                                        PyObject *args, int close_on_genexit) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    PyObject *yf = gen->yieldfrom;
    if (unlikely(gen->is_running))
        return __Pyx_Coroutine_AlreadyRunningError(gen);
    if (yf) {
        PyObject *ret;
        Py_INCREF(yf);
        if (__Pyx_PyErr_GivenExceptionMatches(typ, PyExc_GeneratorExit) && close_on_genexit) {
            int err = __Pyx_Coroutine_CloseIter(gen, yf);
            Py_DECREF(yf);
            __Pyx_Coroutine_Undelegate(gen);
            if (err < 0)
                return __Pyx_Coroutine_MethodReturn(self, __Pyx_Coroutine_SendEx(gen, NULL, 0));
            goto throw_here;
        }
        gen->is_running = 1;
        if (0
        #ifdef __Pyx_Generator_USED
            || __Pyx_Generator_CheckExact(yf)
        #endif
        #ifdef __Pyx_Coroutine_USED
            || __Pyx_Coroutine_Check(yf)
        #endif
            ) {
            ret = __Pyx__Coroutine_Throw(yf, typ, val, tb, args, close_on_genexit);
        #ifdef __Pyx_Coroutine_USED
        } else if (__Pyx_CoroutineAwait_CheckExact(yf)) {
            ret = __Pyx__Coroutine_Throw(((__pyx_CoroutineAwaitObject*)yf)->coroutine, typ, val, tb, args, close_on_genexit);
        #endif
        } else {
            PyObject *meth = __Pyx_PyObject_GetAttrStr(yf, __pyx_n_s_throw);
            if (unlikely(!meth)) {
                Py_DECREF(yf);
                if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {
                    gen->is_running = 0;
                    return NULL;
                }
                PyErr_Clear();
                __Pyx_Coroutine_Undelegate(gen);
                gen->is_running = 0;
                goto throw_here;
            }
            if (likely(args)) {
                ret = PyObject_CallObject(meth, args);
            } else {
                ret = PyObject_CallFunctionObjArgs(meth, typ, val, tb, NULL);
            }
            Py_DECREF(meth);
        }
        gen->is_running = 0;
        Py_DECREF(yf);
        if (!ret) {
            ret = __Pyx_Coroutine_FinishDelegation(gen);
        }
        return __Pyx_Coroutine_MethodReturn(self, ret);
    }
throw_here:
    __Pyx_Raise(typ, val, tb, NULL);
    return __Pyx_Coroutine_MethodReturn(self, __Pyx_Coroutine_SendEx(gen, NULL, 0));
}
static PyObject *__Pyx_Coroutine_Throw(PyObject *self, PyObject *args) {
    PyObject *typ;
    PyObject *val = NULL;
    PyObject *tb = NULL;
    if (!PyArg_UnpackTuple(args, (char *)"throw", 1, 3, &typ, &val, &tb))
        return NULL;
    return __Pyx__Coroutine_Throw(self, typ, val, tb, args, 1);
}
static CYTHON_INLINE int __Pyx_Coroutine_traverse_excstate(__Pyx_ExcInfoStruct *exc_state, visitproc visit, void *arg) {
    Py_VISIT(exc_state->exc_type);
    Py_VISIT(exc_state->exc_value);
    Py_VISIT(exc_state->exc_traceback);
    return 0;
}
static int __Pyx_Coroutine_traverse(__pyx_CoroutineObject *gen, visitproc visit, void *arg) {
    Py_VISIT(gen->closure);
    Py_VISIT(gen->classobj);
    Py_VISIT(gen->yieldfrom);
    return __Pyx_Coroutine_traverse_excstate(&gen->gi_exc_state, visit, arg);
}
static int __Pyx_Coroutine_clear(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    Py_CLEAR(gen->closure);
    Py_CLEAR(gen->classobj);
    Py_CLEAR(gen->yieldfrom);
    __Pyx_Coroutine_ExceptionClear(&gen->gi_exc_state);
#ifdef __Pyx_AsyncGen_USED
    if (__Pyx_AsyncGen_CheckExact(self)) {
        Py_CLEAR(((__pyx_PyAsyncGenObject*)gen)->ag_finalizer);
    }
#endif
    Py_CLEAR(gen->gi_code);
    Py_CLEAR(gen->gi_frame);
    Py_CLEAR(gen->gi_name);
    Py_CLEAR(gen->gi_qualname);
    Py_CLEAR(gen->gi_modulename);
    return 0;
}
static void __Pyx_Coroutine_dealloc(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    PyObject_GC_UnTrack(gen);
    if (gen->gi_weakreflist != NULL)
        PyObject_ClearWeakRefs(self);
    if (gen->resume_label >= 0) {
        PyObject_GC_Track(self);
#if PY_VERSION_HEX >= 0x030400a1 && CYTHON_USE_TP_FINALIZE
        if (PyObject_CallFinalizerFromDealloc(self))
#else
        Py_TYPE(gen)->tp_del(self);
        if (Py_REFCNT(self) > 0)
#endif
        {
            return;
        }
        PyObject_GC_UnTrack(self);
    }
#ifdef __Pyx_AsyncGen_USED
    if (__Pyx_AsyncGen_CheckExact(self)) {
        /* We have to handle this case for asynchronous generators
           right here, because this code has to be between UNTRACK
           and GC_Del. */
        Py_CLEAR(((__pyx_PyAsyncGenObject*)self)->ag_finalizer);
    }
#endif
    __Pyx_Coroutine_clear(self);
    PyObject_GC_Del(gen);
}
static void __Pyx_Coroutine_del(PyObject *self) {
    PyObject *error_type, *error_value, *error_traceback;
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    __Pyx_PyThreadState_declare
    if (gen->resume_label < 0) {
        return;
    }
#if !CYTHON_USE_TP_FINALIZE
    assert(self->ob_refcnt == 0);
    __Pyx_SET_REFCNT(self, 1);
#endif
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&error_type, &error_value, &error_traceback);
#ifdef __Pyx_AsyncGen_USED
    if (__Pyx_AsyncGen_CheckExact(self)) {
        __pyx_PyAsyncGenObject *agen = (__pyx_PyAsyncGenObject*)self;
        PyObject *finalizer = agen->ag_finalizer;
        if (finalizer && !agen->ag_closed) {
            PyObject *res = __Pyx_PyObject_CallOneArg(finalizer, self);
            if (unlikely(!res)) {
                PyErr_WriteUnraisable(self);
            } else {
                Py_DECREF(res);
            }
            __Pyx_ErrRestore(error_type, error_value, error_traceback);
            return;
        }
    }
#endif
    if (unlikely(gen->resume_label == 0 && !error_value)) {
#ifdef __Pyx_Coroutine_USED
#ifdef __Pyx_Generator_USED
    if (!__Pyx_Generator_CheckExact(self))
#endif
        {
        PyObject_GC_UnTrack(self);
#if PY_MAJOR_VERSION >= 3  || defined(PyErr_WarnFormat)
        if (unlikely(PyErr_WarnFormat(PyExc_RuntimeWarning, 1, "coroutine '%.50S' was never awaited", gen->gi_qualname) < 0))
            PyErr_WriteUnraisable(self);
#else
        {PyObject *msg;
        char *cmsg;
        #if CYTHON_COMPILING_IN_PYPY
        msg = NULL;
        cmsg = (char*) "coroutine was never awaited";
        #else
        char *cname;
        PyObject *qualname;
        qualname = gen->gi_qualname;
        cname = PyString_AS_STRING(qualname);
        msg = PyString_FromFormat("coroutine '%.50s' was never awaited", cname);
        if (unlikely(!msg)) {
            PyErr_Clear();
            cmsg = (char*) "coroutine was never awaited";
        } else {
            cmsg = PyString_AS_STRING(msg);
        }
        #endif
        if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning, cmsg, 1) < 0))
            PyErr_WriteUnraisable(self);
        Py_XDECREF(msg);}
#endif
        PyObject_GC_Track(self);
        }
#endif
    } else {
        PyObject *res = __Pyx_Coroutine_Close(self);
        if (unlikely(!res)) {
            if (PyErr_Occurred())
                PyErr_WriteUnraisable(self);
        } else {
            Py_DECREF(res);
        }
    }
    __Pyx_ErrRestore(error_type, error_value, error_traceback);
#if !CYTHON_USE_TP_FINALIZE
    assert(Py_REFCNT(self) > 0);
    if (--self->ob_refcnt == 0) {
        return;
    }
    {
        Py_ssize_t refcnt = Py_REFCNT(self);
        _Py_NewReference(self);
        __Pyx_SET_REFCNT(self, refcnt);
    }
#if CYTHON_COMPILING_IN_CPYTHON
    assert(PyType_IS_GC(Py_TYPE(self)) &&
           _Py_AS_GC(self)->gc.gc_refs != _PyGC_REFS_UNTRACKED);
    _Py_DEC_REFTOTAL;
#endif
#ifdef COUNT_ALLOCS
    --Py_TYPE(self)->tp_frees;
    --Py_TYPE(self)->tp_allocs;
#endif
#endif
}
static PyObject *
__Pyx_Coroutine_get_name(__pyx_CoroutineObject *self, CYTHON_UNUSED void *context)
{
    PyObject *name = self->gi_name;
    if (unlikely(!name)) name = Py_None;
    Py_INCREF(name);
    return name;
}
static int
__Pyx_Coroutine_set_name(__pyx_CoroutineObject *self, PyObject *value, CYTHON_UNUSED void *context)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value)))
#else
    if (unlikely(value == NULL || !PyString_Check(value)))
#endif
    {
        PyErr_SetString(PyExc_TypeError,
                        "__name__ must be set to a string object");
        return -1;
    }
    tmp = self->gi_name;
    Py_INCREF(value);
    self->gi_name = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_Coroutine_get_qualname(__pyx_CoroutineObject *self, CYTHON_UNUSED void *context)
{
    PyObject *name = self->gi_qualname;
    if (unlikely(!name)) name = Py_None;
    Py_INCREF(name);
    return name;
}
static int
__Pyx_Coroutine_set_qualname(__pyx_CoroutineObject *self, PyObject *value, CYTHON_UNUSED void *context)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value)))
#else
    if (unlikely(value == NULL || !PyString_Check(value)))
#endif
    {
        PyErr_SetString(PyExc_TypeError,
                        "__qualname__ must be set to a string object");
        return -1;
    }
    tmp = self->gi_qualname;
    Py_INCREF(value);
    self->gi_qualname = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_Coroutine_get_frame(__pyx_CoroutineObject *self, CYTHON_UNUSED void *context)
{
    PyObject *frame = self->gi_frame;
    if (!frame) {
        if (unlikely(!self->gi_code)) {
            Py_RETURN_NONE;
        }
        frame = (PyObject *) PyFrame_New(
            PyThreadState_Get(),            /*PyThreadState *tstate,*/
            (PyCodeObject*) self->gi_code,  /*PyCodeObject *code,*/
            __pyx_d,                 /*PyObject *globals,*/
            0                               /*PyObject *locals*/
        );
        if (unlikely(!frame))
            return NULL;
        self->gi_frame = frame;
    }
    Py_INCREF(frame);
    return frame;
}
static __pyx_CoroutineObject *__Pyx__Coroutine_New(
            PyTypeObject* type, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
            PyObject *name, PyObject *qualname, PyObject *module_name) {
    __pyx_CoroutineObject *gen = PyObject_GC_New(__pyx_CoroutineObject, type);
    if (unlikely(!gen))
        return NULL;
    return __Pyx__Coroutine_NewInit(gen, body, code, closure, name, qualname, module_name);
}
static __pyx_CoroutineObject *__Pyx__Coroutine_NewInit(
            __pyx_CoroutineObject *gen, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
            PyObject *name, PyObject *qualname, PyObject *module_name) {
    gen->body = body;
    gen->closure = closure;
    Py_XINCREF(closure);
    gen->is_running = 0;
    gen->resume_label = 0;
    gen->classobj = NULL;
    gen->yieldfrom = NULL;
    gen->gi_exc_state.exc_type = NULL;
    gen->gi_exc_state.exc_value = NULL;
    gen->gi_exc_state.exc_traceback = NULL;
#if CYTHON_USE_EXC_INFO_STACK
    gen->gi_exc_state.previous_item = NULL;
#endif
    gen->gi_weakreflist = NULL;
    Py_XINCREF(qualname);
    gen->gi_qualname = qualname;
    Py_XINCREF(name);
    gen->gi_name = name;
    Py_XINCREF(module_name);
    gen->gi_modulename = module_name;
    Py_XINCREF(code);
    gen->gi_code = code;
    gen->gi_frame = NULL;
    PyObject_GC_Track(gen);
    return gen;
}

/* PatchModuleWithCoroutine */
static PyObject* __Pyx_Coroutine_patch_module(PyObject* module, const char* py_code) {
#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
    int result;
    PyObject *globals, *result_obj;
    globals = PyDict_New();  if (unlikely(!globals)) goto ignore;
    result = PyDict_SetItemString(globals, "_cython_coroutine_type",
    #ifdef __Pyx_Coroutine_USED
        (PyObject*)__pyx_CoroutineType);
    #else
        Py_None);
    #endif
    if (unlikely(result < 0)) goto ignore;
    result = PyDict_SetItemString(globals, "_cython_generator_type",
    #ifdef __Pyx_Generator_USED
        (PyObject*)__pyx_GeneratorType);
    #else
        Py_None);
    #endif
    if (unlikely(result < 0)) goto ignore;
    if (unlikely(PyDict_SetItemString(globals, "_module", module) < 0)) goto ignore;
    if (unlikely(PyDict_SetItemString(globals, "__builtins__", __pyx_b) < 0)) goto ignore;
    result_obj = PyRun_String(py_code, Py_file_input, globals, globals);
    if (unlikely(!result_obj)) goto ignore;
    Py_DECREF(result_obj);
    Py_DECREF(globals);
    return module;
ignore:
    Py_XDECREF(globals);
    PyErr_WriteUnraisable(module);
    if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning, "Cython module failed to patch module with custom type", 1) < 0)) {
        Py_DECREF(module);
        module = NULL;
    }
#else
    py_code++;
#endif
    return module;
}

/* PatchGeneratorABC */
#ifndef CYTHON_REGISTER_ABCS
#define CYTHON_REGISTER_ABCS 1
#endif
#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
static PyObject* __Pyx_patch_abc_module(PyObject *module);
static PyObject* __Pyx_patch_abc_module(PyObject *module) {
    module = __Pyx_Coroutine_patch_module(
        module, ""
"if _cython_generator_type is not None:\n"
"    try: Generator = _module.Generator\n"
"    except AttributeError: pass\n"
"    else: Generator.register(_cython_generator_type)\n"
"if _cython_coroutine_type is not None:\n"
"    try: Coroutine = _module.Coroutine\n"
"    except AttributeError: pass\n"
"    else: Coroutine.register(_cython_coroutine_type)\n"
    );
    return module;
}
#endif
static int __Pyx_patch_abc(void) {
#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
    static int abc_patched = 0;
    if (CYTHON_REGISTER_ABCS && !abc_patched) {
        PyObject *module;
        module = PyImport_ImportModule((PY_MAJOR_VERSION >= 3) ? "collections.abc" : "collections");
        if (!module) {
            PyErr_WriteUnraisable(NULL);
            if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning,
                    ((PY_MAJOR_VERSION >= 3) ?
                        "Cython module failed to register with collections.abc module" :
                        "Cython module failed to register with collections module"), 1) < 0)) {
                return -1;
            }
        } else {
            module = __Pyx_patch_abc_module(module);
            abc_patched = 1;
            if (unlikely(!module))
                return -1;
            Py_DECREF(module);
        }
        module = PyImport_ImportModule("backports_abc");
        if (module) {
            module = __Pyx_patch_abc_module(module);
            Py_XDECREF(module);
        }
        if (!module) {
            PyErr_Clear();
        }
    }
#else
    if ((0)) __Pyx_Coroutine_patch_module(NULL, NULL);
#endif
    return 0;
}

/* Generator */
static PyMethodDef __pyx_Generator_methods[] = {
    {"send", (PyCFunction) __Pyx_Coroutine_Send, METH_O,
     (char*) PyDoc_STR("send(arg) -> send 'arg' into generator,\nreturn next yielded value or raise StopIteration.")},
    {"throw", (PyCFunction) __Pyx_Coroutine_Throw, METH_VARARGS,
     (char*) PyDoc_STR("throw(typ[,val[,tb]]) -> raise exception in generator,\nreturn next yielded value or raise StopIteration.")},
    {"close", (PyCFunction) __Pyx_Coroutine_Close_Method, METH_NOARGS,
     (char*) PyDoc_STR("close() -> raise GeneratorExit inside generator.")},
    {0, 0, 0, 0}
};
static PyMemberDef __pyx_Generator_memberlist[] = {
    {(char *) "gi_running", T_BOOL, offsetof(__pyx_CoroutineObject, is_running), READONLY, NULL},
    {(char*) "gi_yieldfrom", T_OBJECT, offsetof(__pyx_CoroutineObject, yieldfrom), READONLY,
     (char*) PyDoc_STR("object being iterated by 'yield from', or None")},
    {(char*) "gi_code", T_OBJECT, offsetof(__pyx_CoroutineObject, gi_code), READONLY, NULL},
    {0, 0, 0, 0, 0}
};
static PyGetSetDef __pyx_Generator_getsets[] = {
    {(char *) "__name__", (getter)__Pyx_Coroutine_get_name, (setter)__Pyx_Coroutine_set_name,
     (char*) PyDoc_STR("name of the generator"), 0},
    {(char *) "__qualname__", (getter)__Pyx_Coroutine_get_qualname, (setter)__Pyx_Coroutine_set_qualname,
     (char*) PyDoc_STR("qualified name of the generator"), 0},
    {(char *) "gi_frame", (getter)__Pyx_Coroutine_get_frame, NULL,
     (char*) PyDoc_STR("Frame of the generator"), 0},
    {0, 0, 0, 0, 0}
};
static PyTypeObject __pyx_GeneratorType_type = {
    PyVarObject_HEAD_INIT(0, 0)
    "generator",
    sizeof(__pyx_CoroutineObject),
    0,
    (destructor) __Pyx_Coroutine_dealloc,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_HAVE_FINALIZE,
    0,
    (traverseproc) __Pyx_Coroutine_traverse,
    0,
    0,
    offsetof(__pyx_CoroutineObject, gi_weakreflist),
    0,
    (iternextfunc) __Pyx_Generator_Next,
    __pyx_Generator_methods,
    __pyx_Generator_memberlist,
    __pyx_Generator_getsets,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
#if CYTHON_USE_TP_FINALIZE
    0,
#else
    __Pyx_Coroutine_del,
#endif
    0,
#if CYTHON_USE_TP_FINALIZE
    __Pyx_Coroutine_del,
#elif PY_VERSION_HEX >= 0x030400a1
    0,
#endif
#if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
    0,
#endif
#if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
    0,
#endif
#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
    0,
#endif
};
static int __pyx_Generator_init(void) {
    __pyx_GeneratorType_type.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
    __pyx_GeneratorType_type.tp_iter = PyObject_SelfIter;
    __pyx_GeneratorType = __Pyx_FetchCommonType(&__pyx_GeneratorType_type);
    if (unlikely(!__pyx_GeneratorType)) {
        return -1;
    }
    return 0;
}

/* CheckBinaryVersion */
static int __Pyx_check_binary_version(void) {
    char ctversion[5];
    int same=1, i, found_dot;
    const char* rt_from_call = Py_GetVersion();
    PyOS_snprintf(ctversion, 5, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    found_dot = 0;
    for (i = 0; i < 4; i++) {
        if (!ctversion[i]) {
            same = (rt_from_call[i] < '0' || rt_from_call[i] > '9');
            break;
        }
        if (rt_from_call[i] != ctversion[i]) {
            same = 0;
            break;
        }
    }
    if (!same) {
        char rtversion[5] = {'\0'};
        char message[200];
        for (i=0; i<4; ++i) {
            if (rt_from_call[i] == '.') {
                if (found_dot) break;
                found_dot = 1;
            } else if (rt_from_call[i] < '0' || rt_from_call[i] > '9') {
                break;
            }
            rtversion[i] = rt_from_call[i];
        }
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

/* InitStrings */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        if (PyObject_Hash(*t->p) == -1)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
#if !CYTHON_PEP393_ENABLED
static const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    char* defenc_c;
    PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
    if (!defenc) return NULL;
    defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    {
        char* end = defenc_c + PyBytes_GET_SIZE(defenc);
        char* c;
        for (c = defenc_c; c < end; c++) {
            if ((unsigned char) (*c) >= 128) {
                PyUnicode_AsASCIIString(o);
                return NULL;
            }
        }
    }
#endif
    *length = PyBytes_GET_SIZE(defenc);
    return defenc_c;
}
#else
static CYTHON_INLINE const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    if (unlikely(__Pyx_PyUnicode_READY(o) == -1)) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    if (likely(PyUnicode_IS_ASCII(o))) {
        *length = PyUnicode_GET_LENGTH(o);
        return PyUnicode_AsUTF8(o);
    } else {
        PyUnicode_AsASCIIString(o);
        return NULL;
    }
#else
    return PyUnicode_AsUTF8AndSize(o, length);
#endif
}
#endif
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
        return __Pyx_PyUnicode_AsStringAndSize(o, length);
    } else
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject* x) {
    int retval;
    if (unlikely(!x)) return -1;
    retval = __Pyx_PyObject_IsTrue(x);
    Py_DECREF(x);
    return retval;
}
static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
#if PY_MAJOR_VERSION >= 3
    if (PyLong_Check(result)) {
        if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
                "__int__ returned non-int (type %.200s).  "
                "The ability to return an instance of a strict subclass of int "
                "is deprecated, and may be removed in a future version of Python.",
                Py_TYPE(result)->tp_name)) {
            Py_DECREF(result);
            return NULL;
        }
        return result;
    }
#endif
    PyErr_Format(PyExc_TypeError,
                 "__%.4s__ returned non-%.4s (type %.200s)",
                 type_name, type_name, Py_TYPE(result)->tp_name);
    Py_DECREF(result);
    return NULL;
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
#if CYTHON_USE_TYPE_SLOTS
  PyNumberMethods *m;
#endif
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_Check(x) || PyLong_Check(x)))
#else
  if (likely(PyLong_Check(x)))
#endif
    return __Pyx_NewRef(x);
#if CYTHON_USE_TYPE_SLOTS
  m = Py_TYPE(x)->tp_as_number;
  #if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = m->nb_int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = m->nb_long(x);
  }
  #else
  if (likely(m && m->nb_int)) {
    name = "int";
    res = m->nb_int(x);
  }
  #endif
#else
  if (!PyBytes_CheckExact(x) && !PyUnicode_CheckExact(x)) {
    res = PyNumber_Int(x);
  }
#endif
  if (likely(res)) {
#if PY_MAJOR_VERSION < 3
    if (unlikely(!PyInt_Check(res) && !PyLong_Check(res))) {
#else
    if (unlikely(!PyLong_CheckExact(res))) {
#endif
        return __Pyx_PyNumber_IntOrLongWrongResultType(res, name);
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b))) {
    if (sizeof(Py_ssize_t) >= sizeof(long))
        return PyInt_AS_LONG(b);
    else
        return PyInt_AsSsize_t(b);
  }
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_USE_PYLONG_INTERNALS
    const digit* digits = ((PyLongObject*)b)->ob_digit;
    const Py_ssize_t size = Py_SIZE(b);
    if (likely(__Pyx_sst_abs(size) <= 1)) {
        ival = likely(size) ? digits[0] : 0;
        if (size == -1) ival = -ival;
        return ival;
    } else {
      switch (size) {
         case 2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
      }
    }
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject* o) {
  if (sizeof(Py_hash_t) == sizeof(Py_ssize_t)) {
    return (Py_hash_t) __Pyx_PyIndex_AsSsize_t(o);
#if PY_MAJOR_VERSION < 3
  } else if (likely(PyInt_CheckExact(o))) {
    return PyInt_AS_LONG(o);
#endif
  } else {
    Py_ssize_t ival;
    PyObject *x;
    x = PyNumber_Index(o);
    if (!x) return -1;
    ival = PyInt_AsLong(x);
    Py_DECREF(x);
    return ival;
  }
}
static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
  return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
